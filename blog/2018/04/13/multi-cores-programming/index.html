<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>多核编程的相关理论及实践 | MathxH</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="这篇文章主要是看brpc的文档的心得体会吧，brpc算是国内高性能RPC框架中文档写得最好，最有诚意的作品了。就算不看它的源码，看它的文档也能收获很大，干货满满，在这过程中也解答了我以前的困惑。  前言 在开篇之前，我想说点文体风格，由于阅读brpc的文档给了我巨大的收获，所以文体的风格会以问答的方式展开。顺便给出原理解释，还有感受下戈君大神在文档中浸淫多年的软件基础设施工程实践心得体会。我文字">
<meta name="keywords" content="多线程编程,多核编程">
<meta property="og:type" content="article">
<meta property="og:title" content="多核编程的相关理论及实践">
<meta property="og:url" content="https://alexiachen.github.io/blog/2018/04/13/multi-cores-programming/index.html">
<meta property="og:site_name" content="MathxH">
<meta property="og:description" content="这篇文章主要是看brpc的文档的心得体会吧，brpc算是国内高性能RPC框架中文档写得最好，最有诚意的作品了。就算不看它的源码，看它的文档也能收获很大，干货满满，在这过程中也解答了我以前的困惑。  前言 在开篇之前，我想说点文体风格，由于阅读brpc的文档给了我巨大的收获，所以文体的风格会以问答的方式展开。顺便给出原理解释，还有感受下戈君大神在文档中浸淫多年的软件基础设施工程实践心得体会。我文字">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-01-04T15:05:55.861Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="多核编程的相关理论及实践">
<meta name="twitter:description" content="这篇文章主要是看brpc的文档的心得体会吧，brpc算是国内高性能RPC框架中文档写得最好，最有诚意的作品了。就算不看它的源码，看它的文档也能收获很大，干货满满，在这过程中也解答了我以前的困惑。  前言 在开篇之前，我想说点文体风格，由于阅读brpc的文档给了我巨大的收获，所以文体的风格会以问答的方式展开。顺便给出原理解释，还有感受下戈君大神在文档中浸淫多年的软件基础设施工程实践心得体会。我文字">
  
    <link rel="alternate" href="/blog/atom.xml" title="MathxH" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/blog/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog/" id="logo">MathxH</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/blog/" id="subtitle">MathxH</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blog/">Home</a>
        
          <a class="main-nav-link" href="/blog/archives">Archives</a>
        
          <a class="main-nav-link" href="/blog/about">About</a>
        
          <a class="main-nav-link" href="/blog/resume">Resume</a>
        
      </nav>
      <nav id="sub-nav">
        <a></a>
        
          <a id="nav-rss-link" class="nav-icon" href="/blog/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://alexiachen.github.io/blog"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-multi-cores-programming" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2018/04/13/multi-cores-programming/" class="article-date">
  <time datetime="2018-04-13T04:01:23.000Z" itemprop="datePublished">2018-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      多核编程的相关理论及实践
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p><em>这篇文章主要是看brpc的文档的心得体会吧，brpc算是国内高性能RPC框架中文档写得最好，最有诚意的作品了。就算不看它的源码，看它的文档也能收获很大，干货满满，在这过程中也解答了我以前的困惑。</em></p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>在开篇之前，我想说点文体风格，由于阅读<a href="https://github.com/brpc/brpc" target="_blank" rel="noopener">brpc</a>的文档给了我巨大的收获，所以文体的风格会以问答的方式展开。顺便给出原理解释，还有感受下<a href="https://www.linkedin.com/in/gejun" target="_blank" rel="noopener">戈君大神</a>在文档中浸淫多年的软件基础设施工程实践心得体会。我文字理解驾驭不了的地方会选择性地摘抄文档内容。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><hr>
<h3 id="1-如何针对写多读少的场景设计一个多线程计数器？"><a href="#1-如何针对写多读少的场景设计一个多线程计数器？" class="headerlink" title="1. 如何针对写多读少的场景设计一个多线程计数器？"></a>1. 如何针对写多读少的场景设计一个多线程计数器？</h3><p>大部分RPC框架，或者其他中间件或多或少都需要有这样的需求，因为这些中间件基本都是主打高性能的，高效利用多核多线程。既然是高性能，都需要为它设计计数器，目的是为了方<br>便统计各种服务的调用次数，还有其他性能参数（QPS,平均延时），以达到监控服务，调优服务的最终目的。<br>本着最直观的理解，写下了如下最简单的计数器代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> global_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//高并发下，多线程调用这个服务，显而易见需要加锁解锁，构成一个临界区</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">service</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    lock();</span><br><span class="line">    global_count++;</span><br><span class="line">    unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上代码是正确的，global_count在多线程调用的累加下不会出错。但是由于多线程高频率修改global_count，性能可能没你想象的好，因为造成了大量的<a href="https://en.wikipedia.org/wiki/Race_condition" target="_blank" rel="noopener">Race Condition</a>。这时候锁的性能造成了瓶颈。你不得不想方设法的绕开锁的限制。</p>
<p>这里有一点值得注意，C++提供的std::mutex在大部分不压榨性能的场景足够用了，造成std::mutex性能低下的两点，一个是std::mutex的粒度过大，也就是临界区过大限制了并发度。另一个就是频繁的访问导致锁争用，上下文切换非常频繁。</p>
<p>那么如何解决计数器遇到的这个问题呢？ 其实最直观的就是避免共享，避免锁争用。用<a href="https://en.wikipedia.org/wiki/Thread-local_storage" target="_blank" rel="noopener">thread local</a>技术来避免减少大量的Cache Bouncing，该技术原理是每个线程修改（写）global_count只维持线程自己的一个变量累加的副本。等到有线程读global_count的时候，就把各个线程的变量副本的结果合并起来，这个速度就会显得慢了，不过因为是写多读少的场景，所以没有问题。</p>
<h3 id="2-Cache-Bouncing是为何物？"><a href="#2-Cache-Bouncing是为何物？" class="headerlink" title="2. Cache Bouncing是为何物？"></a>2. Cache Bouncing是为何物？</h3><p>为了以较低的成本大幅提高性能，现代CPU都有cache。cpu cache已经发展到了三级缓存结构，基本上现在买的个人电脑都是L3结构。其中L1和L2 cache为每个核独有，L3则所有核共享。为了保证所有的核看到正确的内存数据，一个核在写入自己的L1 cache后，CPU会执行<a href="https://en.wikipedia.org/wiki/Cache_coherence" target="_blank" rel="noopener">Cache一致性算法</a>把对应的Cache Line(一般是64字节)同步到其他核的Cache中。这个过程并不很快，是微秒级的，相比之下写入L1 cache只需要若干纳秒。当很多线程在频繁修改某个共享字段变量时，这个字段所在的Cache Line被不停地同步到不同的核上，就像在核间弹来弹去，这个现象就叫做Cache Bouncing。由于实现cache一致性往往有硬件锁，Cache Bouncing是一种隐式的的全局竞争。</p>
<p>当然Cache一致性算法有多种，其中一种听到的最多的叫<a href="https://en.wikipedia.org/wiki/MESI_protocol" target="_blank" rel="noopener">MESI协议</a>。</p>
<h3 id="3-CAS原子指令为什么会这么难？"><a href="#3-CAS原子指令为什么会这么难？" class="headerlink" title="3. CAS原子指令为什么会这么难？"></a>3. CAS原子指令为什么会这么难？</h3><p>多核多线程编程常用锁避免多个线程在修改同一个数据时产生race condition。当锁成为性能瓶颈时，我们又总想试着绕开它，而不可避免地接触了原子指令（用于实现Lock-Free和Wait-Free等数据结构和算法）。但在实践中，用CAS原子指令写出正确的代码是一件非常困难的事，各种概念接踵而来，琢磨不透的race condition、<a href="https://en.wikipedia.org/wiki/ABA_problem" target="_blank" rel="noopener">ABA problem</a>、<a href="https://en.wikipedia.org/wiki/Memory_barrier" target="_blank" rel="noopener">memory barrier</a>很烧脑。（Memory Barrier又叫内存栅栏，内存屏障）。</p>
<p>顾名思义，原子指令是对软件不可再分的指令，比如x.fetch_add(n)指原子地给x加上n，这个指令对软件要么没做，要么完成，不会观察到中间状态。常见的原子指令有：</p>
<table>
<thead>
<tr>
<th>原子指令 (x均为std::atomic<int>)</int></th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>x.load()</td>
<td>返回x的值。</td>
</tr>
<tr>
<td>x.store(n)</td>
<td>把x设为n，什么都不返回。</td>
</tr>
<tr>
<td>x.exchange(n)</td>
<td>把x设为n，返回设定之前的值。</td>
</tr>
<tr>
<td>x.compare_exchange_strong(expected_ref, desired)</td>
<td>若x等于expected_ref，则设为desired，返回成功；否则把最新值写入expected_ref，返回失败。</td>
</tr>
<tr>
<td>x.compare_exchange_weak(expected_ref, desired)</td>
<td>相比compare_exchange_strong可能有<a href="http://en.wikipedia.org/wiki/Spurious_wakeup" target="_blank" rel="noopener">spurious wakeup</a>。</td>
</tr>
<tr>
<td>x.fetch_add(n), x.fetch_sub(n)</td>
<td>原子地做x += n, x-= n，返回修改之前的值。</td>
</tr>
</tbody>
</table>
<p>你已经可以不用显式加锁用这些指令做原子计数，比如多个线程同时累加一个原子变量，以统计这些线程对一些资源的操作次数。但是，这可能会有两个问题：</p>
<ul>
<li>这个操作没有你想象地快。</li>
<li>如果你尝试通过看似简单的原子操作控制对一些资源的访问，你的程序有很大几率会crash。</li>
</ul>
<h3 id="4-什么情况下多核之间的Cache-Line会频繁同步导致Cache-Bouncing？"><a href="#4-什么情况下多核之间的Cache-Line会频繁同步导致Cache-Bouncing？" class="headerlink" title="4. 什么情况下多核之间的Cache Line会频繁同步导致Cache Bouncing？"></a>4. 什么情况下多核之间的Cache Line会频繁同步导致Cache Bouncing？</h3><p>一个核心写入自己的L1 cache是极快的(4 cycles, ~2ns)，但当另一个核心读或写同一处内存时，它得确认看到其他核心中对应的cache line。对于软件来说，这个过程是原子的，不能在中间穿插其他代码，只能等待CPU完成一致性同步，这个复杂的硬件算法使得原子操作会变得很慢，竞争激烈时fetch_add会耗费数百纳秒左右。访问被多个线程频繁共享的内存往往是比较慢的。比如像一些场景临界区看着很小，但保护它的spin lock性能不佳，因为spin lock使用的exchange, fetch_add等指令必须等待最新的cache line，看上去只有几条指令，花费若干微秒并不奇怪。</p>
<p>要提高性能，就要避免让CPU频繁同步cache line。这不单和原子指令本身的性能有关，还会影响到程序的整体性能。最有效的解决方法很直白：<strong>尽量避免共享</strong>。（比如用之前提到过的Thread Local）。</p>
<p>一个相关的编程陷阱是<a href="https://en.wikipedia.org/wiki/False_sharing" target="_blank" rel="noopener">False Sharing</a>：对那些不怎么被修改甚至只读变量的访问，由于同一个cache line中的其他变量被频繁修改，而不得不经常等待cache line同步而显著变慢了(也就是被别的变量拉低的性能)。多线程中的变量尽量按访问规律排列，频繁被其他线程修改的变量要放在独立的Cache Line中。要让一个变量或结构体按Cache Line对齐。</p>
<h3 id="5-基于CAS原语的原子指令编写的Lock-Free和Wait-Free数据结构和算法性能一定更高吗？"><a href="#5-基于CAS原语的原子指令编写的Lock-Free和Wait-Free数据结构和算法性能一定更高吗？" class="headerlink" title="5. 基于CAS原语的原子指令编写的Lock-Free和Wait-Free数据结构和算法性能一定更高吗？"></a>5. 基于CAS原语的原子指令编写的Lock-Free和Wait-Free数据结构和算法性能一定更高吗？</h3><p>诚然，原子指令基于CAS原语的控制并发的粒度会更小，但是由此带来了更大的复杂性。它能为服务赋予两个重要的概念<a href="https://en.wikipedia.org/wiki/Non-blocking_algorithm#Lock-freedom" target="_blank" rel="noopener">Lock-Free</a>和<a href="https://en.wikipedia.org/wiki/Non-blocking_algorithm#Wait-freedom" target="_blank" rel="noopener">Wait-Free</a>。</p>
<p>当然前者的意思不言自明了，就是无锁编程（算法），后者是无等待编程（算法）。有的人说，那好了，采用Lock-Free的算法，不用加锁了，显然更快了。Wait-Free那更加快了，都不用等待了。当然理论上是这么一回事，但是工程实践上又是一回事。无锁编程采用底层的CAS原语其实上的是硬件粒度的锁，理论上是更加快，因为一些实时系统的关键部分和一些关键的数据结构为了压榨性能，确实是用Lock-Free的算法和Wait-Free算法编写的。但是，值得注意的事情是：</p>
<ul>
<li><p>lock-free和wait-free必须处理更多更复杂的race condition和ABA problem，完成相同目的的代码比用锁更复杂。代码越多，反而比用小粒度的std::mutex耗时长。</p>
</li>
<li><p>使用mutex的算法变相带“后退”效果。后退(backoff)指出现竞争时尝试另一个途径以临时避免竞争，mutex出现竞争时会使调用者睡眠，使拿到锁的那个线程可以很快地独占完成一系列流程，总体吞吐可能反而高了。</p>
</li>
</ul>
<p>mutex导致低性能往往是因为临界区过大（限制了并发度），或竞争过于激烈（上下文切换开销变得突出）。lock-free/wait-free算法的价值在于其保证了一个或所有线程始终在做有用的事，而不是绝对的高性能。但在一种情况下lock-free和wait-free算法的性能多半更高：就是算法本身可以用少量的CAS原子指令实现。实现锁也是要用原子指令的，当算法本身用一两条指令就能完成的时候，相比额外用锁肯定是更快了。</p>
<p>当然，大部分场景几乎不要用Lock-Free和Wait-Free的算法，一个是因为不需要那么极尽变态地压榨性能。另一个是这两种算法其实很复杂，即使写出来了，从形式化的手段也难以证明算法的正确性。对于越复杂的数据结构越是如此。比如Lock-Free的数据结构目前在boost C++中常见的有Queue, Ring Buffer，Stack这些简单的数据结构。但是如果你搜网络上的论文，就很难见到有Lock-Free的树型数据结构。其一是太复杂了，即使实现并证明正确，但是实测性能可能也没加锁的树形数据结构高。如果这样就舍本逐末了。</p>
<h3 id="6-协程是什么？它为什么不能利用多核？"><a href="#6-协程是什么？它为什么不能利用多核？" class="headerlink" title="6.协程是什么？它为什么不能利用多核？"></a>6.协程是什么？它为什么不能利用多核？</h3><p>协程是一种用户态的线程，由用户态的调度器来调度，因为其非常轻量，可以用来部分代替线程从而实现所谓的高并发（看场景），而且由于协程不对应内核中的线程概念，所以用户可以一瞬间创建出成千上万个协程，而不消耗太多性能，它们之前切换可以非常快（100ns-200ns），受缓存一致性的影响很小。但是呢，平常我们所说的协程并不能利用CPU多核，因为是它相当于是N：1的线程库，就是N个协程只跑在一个内核线程上，一个内核线程只会在一个核上运行。</p>
<p>还有一个缺点就是，因为协程无法高效利用多核，代码必须非阻塞，否则所有协程都会被block住，对开发者要求比较苛刻。协程的这种特点使其非常适合写运行时间基本能确定的IO服务器，比如http server，在一些精心调试的场景中，可以达到非常高的吞吐量（实时大流量）。协程的这个特点与Event Loop的单线程异步是类似的，一个callback函数如果需要等待比较长的时间，那么整个Event Loop就被block住了，其他事件得不到及时响应。</p>
<p>所以可以看到了，Node.js之类的适配上协程确实可以达到高并发，高吞吐，这句话本身没问题。但是这是有场景的，Node.js适合处理IO数据密集型实时应用系统，比如Web消息实时推送（知乎的问答提示），Web可视化数据实时展示。Node非常适合如下情况：在响应客户端之前，你预计可能有很高的流量，但所需的服务器端逻辑和处理不一定很多（服务端不能有复杂计算，复杂业务逻辑，复杂事务处理）。</p>
<p>当然有懂一点的人可能会说，可以开启多个Node.js进程（Cluster模块）来以多个内核线程达到利用多核的目的，当然至于这样是不是很方便，很高效就是另一个话题了。但是据我所知，主流大型互联网公司基础框架想高效的利用多核都不会选择这种方案。</p>
<h3 id="7-Go语言中的GoRoutine是协程吗？为什么它却能利用多核？"><a href="#7-Go语言中的GoRoutine是协程吗？为什么它却能利用多核？" class="headerlink" title="7. Go语言中的GoRoutine是协程吗？为什么它却能利用多核？"></a>7. Go语言中的GoRoutine是协程吗？为什么它却能利用多核？</h3><p>不是，因为GoRoutine是可以利用多核的，它实质上就是个M:N的线程库（一般M会远大于N），M个GoRoutine对应N个内核线程（当然，这个特性是以语言内建特性的方式暴露出来的，而不是标准库的形式，所以写起来会更自然些）。一个RoRoutine因复杂的计算或者同步阻塞IO等待而block住也不会影响其他GoRoutine。</p>
<p>Goroutine调度器的实现由一种关键的技术：<a href="https://en.wikipedia.org/wiki/Work_stealing" target="_blank" rel="noopener">Work-Stealing调度算法</a>。这一种算法的目的是想让GoRoutine更快地被调度到更多的CPU核心上。</p>
<h3 id="8-单线程Reactor和多线程Reactor模型有什么不同？"><a href="#8-单线程Reactor和多线程Reactor模型有什么不同？" class="headerlink" title="8. 单线程Reactor和多线程Reactor模型有什么不同？"></a>8. 单线程Reactor和多线程Reactor模型有什么不同？</h3><p>以libevent, libev等event-loop库为典型。这个模型一般由一个event dispatcher等待各类事件，待事件发生后原地调用对应的event handler，全部调用完后等待更多事件，故为”loop”。这个模型的实质是把多段逻辑按事件触发顺序交织在一个系统线程中。一个event-loop只能使用一个核，故此类程序要么是IO-bound，要么是每个handler有确定的较短的运行时间（比如http server)，否则一个耗时漫长的回调就会卡住整个程序，产生高延时。在实践中这类程序不适合多开发者参与，一个人写了阻塞代码可能就会拖慢其他代码的响应。由于event handler不会同时运行，不太会产生复杂的race condition，一般不需要加锁。此类程序主要靠部署更多进程增加扩展性。Redis就是这么干的。</p>
<p>以boost::asio为典型。一般由一个或多个线程分别运行event dispatcher，待事件发生后把event handler交给一个worker线程执行。 这个模型是单线程reactor的自然扩展，叫多线程Reactor，可以利用多核。由于共用地址空间使得线程间交互变得廉价，worker thread间一般会更及时地均衡负载，而多进程一般依赖更前端的服务（Nginx）来分割流量，一个设计良好的多线程reactor程序往往能比同一台机器上的多个单线程reactor进程更均匀地使用不同核心。不过由于cache一致性的限制，多线程reactor并不能获得线性于核心数的性能，在特定的场景中，粗糙的多线程reactor实现跑在24核上甚至没有精致的单线程reactor实现跑在1个核上快。由于多线程reactor包含多个worker线程，单个event handler阻塞未必会延缓其他handler，所以event handler未必得非阻塞，除非所有的worker线程都被阻塞才会影响到整体进展。事实上，大部分RPC框架都使用了这个模型，且回调中常有阻塞部分，比如同步等待访问下游的RPC返回。</p>
<h3 id="9-N：1线程库和M-N线程库又有什么区别？"><a href="#9-N：1线程库和M-N线程库又有什么区别？" class="headerlink" title="9. N：1线程库和M:N线程库又有什么区别？"></a>9. N：1线程库和M:N线程库又有什么区别？</h3><p>之前提到过，平常所说的协程（Coroutine）相当于是一个N：1的线程库。但是这么说并不代表N：1的线程库就是协程，它有另外的名字叫<a href="https://en.wikipedia.org/wiki/Fiber_\(computer_science\" target="_blank" rel="noopener">纤程（Fiber）</a>)。以GNU Pth, StateThreads等为典型，一般是把N个用户线程映射入一个系统内核线程。同时只运行一个用户线程，调用阻塞函数时才会切换至其他用户线程（有调度器，所以跟Event Loop这点细节上又不大一样）。N:1线程库与单线程reactor在能力上是等价的，但事件回调被替换为了上下文(栈,寄存器,signals)，运行回调变成了跳转至上下文。和event loop库一样，单个N:1线程库无法充分发挥多核性能，只适合一些特定的程序。只有一个系统线程对CPU cache较为友好，加上舍弃对signal mask的支持的话，用户线程间的上下文切换可以很快(100~200ns)。N:1线程库的性能一般和event loop库差不多，扩展性也主要靠多进程。</p>
<p>M:N线程库也只是一种实现思想思路，Goroutine就是这样的实现。即把M个用户线程映射入N个系统内核线程。M:N线程库可以决定一段代码何时开始在哪运行，并何时结束，相比多线程reactor在调度上具备更多的灵活度。但实现全功能的M:N线程库是困难的，它一直是个活跃的研究话题。我们这里说的M:N线程库特别针对编写网络服务，在这一前提下一些需求可以简化，比如没有时间片抢占，没有(完备的)优先级等。M:N线程库可以在用户态也可以在内核中实现，用户态的实现以新语言为主，比如GHC threads和goroutine，这些语言可以围绕线程库设计全新的关键字并拦截所有相关的API。而在现有语言中的实现往往得修改内核，比如Windows UMS和google SwicthTo(虽然是1:1，但基于它可以实现M:N的效果)。相比N:1线程库，M:N线程库在使用上更类似于系统内核线程，需要用锁或消息传递（消息总线，Actor模型，Vert.x，Akka库等代表）保证代码的线程安全。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://alexiachen.github.io/blog/2018/04/13/multi-cores-programming/" data-id="cjtctj24v008olbqf3z17j2g9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/多核编程/">多核编程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/多线程编程/">多线程编程</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/blog/2018/06/03/win32-dump/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          windows用户态程序的dump文件生成
        
      </div>
    </a>
  
  
    <a href="/blog/2018/04/01/home-network-design/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">家里面的网络布局方案</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/blog/tags/Bloom-Filter/" style="font-size: 10px;">Bloom Filter</a> <a href="/blog/tags/C-C/" style="font-size: 20px;">C/C++</a> <a href="/blog/tags/CERT/" style="font-size: 18.33px;">CERT</a> <a href="/blog/tags/CMake/" style="font-size: 10px;">CMake</a> <a href="/blog/tags/DLL/" style="font-size: 10px;">DLL</a> <a href="/blog/tags/DNS/" style="font-size: 10px;">DNS</a> <a href="/blog/tags/IM/" style="font-size: 13.33px;">IM</a> <a href="/blog/tags/IO/" style="font-size: 10px;">IO</a> <a href="/blog/tags/Java/" style="font-size: 10px;">Java</a> <a href="/blog/tags/Linux/" style="font-size: 13.33px;">Linux</a> <a href="/blog/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/blog/tags/Oracle/" style="font-size: 10px;">Oracle</a> <a href="/blog/tags/Qos/" style="font-size: 11.67px;">Qos</a> <a href="/blog/tags/RFB协议/" style="font-size: 10px;">RFB协议</a> <a href="/blog/tags/SQLite/" style="font-size: 10px;">SQLite</a> <a href="/blog/tags/Scala/" style="font-size: 10px;">Scala</a> <a href="/blog/tags/TCP-IP/" style="font-size: 10px;">TCP/IP</a> <a href="/blog/tags/VNC协议/" style="font-size: 10px;">VNC协议</a> <a href="/blog/tags/Visual-Studio/" style="font-size: 10px;">Visual Studio</a> <a href="/blog/tags/Win32/" style="font-size: 13.33px;">Win32</a> <a href="/blog/tags/Y组合子/" style="font-size: 10px;">Y组合子</a> <a href="/blog/tags/bat/" style="font-size: 10px;">bat</a> <a href="/blog/tags/ioccc/" style="font-size: 10px;">ioccc</a> <a href="/blog/tags/lambda演算/" style="font-size: 10px;">lambda演算</a> <a href="/blog/tags/windows/" style="font-size: 11.67px;">windows</a> <a href="/blog/tags/上下文无关文法/" style="font-size: 10px;">上下文无关文法</a> <a href="/blog/tags/事业/" style="font-size: 10px;">事业</a> <a href="/blog/tags/互联网/" style="font-size: 10px;">互联网</a> <a href="/blog/tags/人生/" style="font-size: 10px;">人生</a> <a href="/blog/tags/传统行业/" style="font-size: 10px;">传统行业</a> <a href="/blog/tags/信息安全/" style="font-size: 10px;">信息安全</a> <a href="/blog/tags/内存模型/" style="font-size: 10px;">内存模型</a> <a href="/blog/tags/函数式编程/" style="font-size: 11.67px;">函数式编程</a> <a href="/blog/tags/单例模式/" style="font-size: 10px;">单例模式</a> <a href="/blog/tags/双向链表/" style="font-size: 10px;">双向链表</a> <a href="/blog/tags/可计算性/" style="font-size: 10px;">可计算性</a> <a href="/blog/tags/同步异步/" style="font-size: 10px;">同步异步</a> <a href="/blog/tags/团队管理/" style="font-size: 11.67px;">团队管理</a> <a href="/blog/tags/多核编程/" style="font-size: 10px;">多核编程</a> <a href="/blog/tags/多线程编程/" style="font-size: 10px;">多线程编程</a> <a href="/blog/tags/天体物理/" style="font-size: 10px;">天体物理</a> <a href="/blog/tags/套路/" style="font-size: 10px;">套路</a> <a href="/blog/tags/学术/" style="font-size: 10px;">学术</a> <a href="/blog/tags/宇宙学/" style="font-size: 10px;">宇宙学</a> <a href="/blog/tags/性能优化/" style="font-size: 10px;">性能优化</a> <a href="/blog/tags/技术/" style="font-size: 10px;">技术</a> <a href="/blog/tags/指令重排序/" style="font-size: 10px;">指令重排序</a> <a href="/blog/tags/操作系统/" style="font-size: 10px;">操作系统</a> <a href="/blog/tags/敏捷开发/" style="font-size: 10px;">敏捷开发</a> <a href="/blog/tags/数据压缩/" style="font-size: 10px;">数据压缩</a> <a href="/blog/tags/数据库/" style="font-size: 10px;">数据库</a> <a href="/blog/tags/数据恢复/" style="font-size: 10px;">数据恢复</a> <a href="/blog/tags/数据结构与算法/" style="font-size: 11.67px;">数据结构与算法</a> <a href="/blog/tags/旅行/" style="font-size: 10px;">旅行</a> <a href="/blog/tags/无线网卡/" style="font-size: 10px;">无线网卡</a> <a href="/blog/tags/有限自动机/" style="font-size: 10px;">有限自动机</a> <a href="/blog/tags/构建工具/" style="font-size: 10px;">构建工具</a> <a href="/blog/tags/模板元编程/" style="font-size: 10px;">模板元编程</a> <a href="/blog/tags/民主/" style="font-size: 11.67px;">民主</a> <a href="/blog/tags/汇编语言/" style="font-size: 10px;">汇编语言</a> <a href="/blog/tags/消息推送/" style="font-size: 10px;">消息推送</a> <a href="/blog/tags/混乱代码/" style="font-size: 10px;">混乱代码</a> <a href="/blog/tags/物联网/" style="font-size: 10px;">物联网</a> <a href="/blog/tags/猎人/" style="font-size: 10px;">猎人</a> <a href="/blog/tags/理想/" style="font-size: 10px;">理想</a> <a href="/blog/tags/理论计算机/" style="font-size: 10px;">理论计算机</a> <a href="/blog/tags/生活/" style="font-size: 13.33px;">生活</a> <a href="/blog/tags/研究/" style="font-size: 10px;">研究</a> <a href="/blog/tags/程序语言理论/" style="font-size: 15px;">程序语言理论</a> <a href="/blog/tags/类型系统/" style="font-size: 10px;">类型系统</a> <a href="/blog/tags/线程/" style="font-size: 10px;">线程</a> <a href="/blog/tags/线程安全/" style="font-size: 10px;">线程安全</a> <a href="/blog/tags/缓存/" style="font-size: 10px;">缓存</a> <a href="/blog/tags/编程范式/" style="font-size: 10px;">编程范式</a> <a href="/blog/tags/编程语言/" style="font-size: 10px;">编程语言</a> <a href="/blog/tags/编译原理/" style="font-size: 11.67px;">编译原理</a> <a href="/blog/tags/美国/" style="font-size: 10px;">美国</a> <a href="/blog/tags/职业生涯/" style="font-size: 10px;">职业生涯</a> <a href="/blog/tags/自然语言处理/" style="font-size: 10px;">自然语言处理</a> <a href="/blog/tags/自由/" style="font-size: 11.67px;">自由</a> <a href="/blog/tags/英语/" style="font-size: 10px;">英语</a> <a href="/blog/tags/装修/" style="font-size: 10px;">装修</a> <a href="/blog/tags/计算机体系结构/" style="font-size: 10px;">计算机体系结构</a> <a href="/blog/tags/计算机科学/" style="font-size: 10px;">计算机科学</a> <a href="/blog/tags/计算机网络/" style="font-size: 11.67px;">计算机网络</a> <a href="/blog/tags/计算理论/" style="font-size: 11.67px;">计算理论</a> <a href="/blog/tags/词法分析/" style="font-size: 10px;">词法分析</a> <a href="/blog/tags/诗歌/" style="font-size: 10px;">诗歌</a> <a href="/blog/tags/语义学/" style="font-size: 10px;">语义学</a> <a href="/blog/tags/调试/" style="font-size: 11.67px;">调试</a> <a href="/blog/tags/软件工程/" style="font-size: 16.67px;">软件工程</a> <a href="/blog/tags/软件开发/" style="font-size: 10px;">软件开发</a> <a href="/blog/tags/软件调试/" style="font-size: 10px;">软件调试</a> <a href="/blog/tags/远程桌面/" style="font-size: 10px;">远程桌面</a> <a href="/blog/tags/逻辑/" style="font-size: 11.67px;">逻辑</a> <a href="/blog/tags/重构/" style="font-size: 10px;">重构</a> <a href="/blog/tags/错误处理/" style="font-size: 10px;">错误处理</a> <a href="/blog/tags/闭包/" style="font-size: 10px;">闭包</a> <a href="/blog/tags/阻塞非阻塞/" style="font-size: 10px;">阻塞非阻塞</a> <a href="/blog/tags/项目管理/" style="font-size: 11.67px;">项目管理</a> <a href="/blog/tags/马尔科夫链/" style="font-size: 10px;">马尔科夫链</a> <a href="/blog/tags/驱动开发/" style="font-size: 10px;">驱动开发</a> <a href="/blog/tags/黑洞/" style="font-size: 10px;">黑洞</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/02/">February 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/01/">January 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2015/11/">November 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2014/11/">November 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2014/09/">September 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2014/08/">August 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2014/07/">July 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2014/06/">June 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2014/05/">May 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2014/03/">March 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2014/02/">February 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2013/07/">July 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2013/06/">June 2013</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2019/03/17/bloom-filter/">实现一个简单的高性能布隆过滤器</a>
          </li>
        
          <li>
            <a href="/blog/2019/03/10/auto-complete-markov-chain/">用马尔科夫链来做自动补全</a>
          </li>
        
          <li>
            <a href="/blog/2018/12/15/manjaro-rtl8821ce/">manjaro下安装配置无线网卡驱动</a>
          </li>
        
          <li>
            <a href="/blog/2018/11/11/cpp-closure/">C++的闭包</a>
          </li>
        
          <li>
            <a href="/blog/2018/10/15/finite-automaton/">最简单的计算机之有限自动机</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 MathxH Chen<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/blog/" class="mobile-nav-link">Home</a>
  
    <a href="/blog/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/blog/about" class="mobile-nav-link">About</a>
  
    <a href="/blog/resume" class="mobile-nav-link">Resume</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">
  <script src="/blog/fancybox/jquery.fancybox.pack.js"></script>


<script src="/blog/js/script.js"></script>



  </div>
</body>
</html>