<html>
<head><meta name="generator" content="Hexo 3.8.0">
	
	<title>从群环域到椭圆曲线密码学</title>
	<meta name="keywords" content="MathxH Blog">

    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    
	   <link href="/blog/css/main.css?v=3" rel="stylesheet" type="text/css">
    
        <script src="/blog/js/util.js"></script>
        <script>
            if(isMobile()) {
                loadjscssfile('../css/mobile.css', 'css');
            } else {
                loadjscssfile('../css/desktop.css', 'css');
            }
        </script> 
    

    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">

    
	<link rel="shortcut icon" type="image/x-icon" href="/blog/favicon.ico?v=3">
    
    

</head>

<body>


<h2 class="title">从群环域到椭圆曲线密码学</h2>
<!---
<div style="text-align:center;margin-top: -10px;">
<div class="article-category">
发表于2019年6月29日




 </div>
--->


<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#从集合到群"><span class="toc-text">从集合到群</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#阿贝尔群"><span class="toc-text">阿贝尔群</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#从群到环"><span class="toc-text">从群到环</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#交换环"><span class="toc-text">交换环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剩余类环"><span class="toc-text">剩余类环</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#从环到域"><span class="toc-text">从环到域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#椭圆曲线密码学"><span class="toc-text">椭圆曲线密码学</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#椭圆曲线"><span class="toc-text">椭圆曲线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#椭圆曲线上的运算"><span class="toc-text">椭圆曲线上的运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#椭圆曲线上的离散对数问题"><span class="toc-text">椭圆曲线上的离散对数问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#利用有限域这个工具对椭圆曲线进行离散化"><span class="toc-text">利用有限域这个工具对椭圆曲线进行离散化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#椭圆曲线点的坐标运算"><span class="toc-text">椭圆曲线点的坐标运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#椭圆曲线的Diffie-Hellman密钥交换"><span class="toc-text">椭圆曲线的Diffie-Hellman密钥交换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#椭圆曲线的数字签名算法（ECDSA）"><span class="toc-text">椭圆曲线的数字签名算法（ECDSA）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol>
<blockquote>
<p><em>干了区块链这行当，快一年了，还没有写过有关于区块链相关的密码学呢，之前是没有仔细研究这块内容，再不自己写写总结，总有点对不住自己。如果以后不做这行了，哪敢跟别人说我曾经做过区块链啊</em></p>
</blockquote>
<h2 id="从集合到群"><a href="#从集合到群" class="headerlink" title="从集合到群"></a>从集合到群</h2><hr>
<p>首先还是从集合说起吧。</p>
<p>最早的时候，我记得我们应该是在初中的时候就引入集合的概念了。我们知道很多种关于数字的集合（以下字母均为大写字母）：</p>
<ul>
<li>N表示所有自然数集合 {1,2,3,4,5 …}</li>
<li>Z是所有整数的集合 {… -3, -2, -1, 0, 1, 2, 3 …}</li>
<li>Q是所有有理数的集合 （有理数可以写为两个整数的比 a/b 其中a，b为整数，且b不等于0）</li>
<li>R是所有实数的集合 （实数是数轴上所有有理数和无理数的总称）</li>
<li>C是所有复数的集合 （复数是复平面上的所有点 a + b*i 其中a，b为实数）</li>
</ul>
<p>从小学到高中，我们都直接或间接地一直在学习数字的集合，学习加减乘除等运算。换个角度，如果我们把这些运算引入集合会不会发现有趣的性质呢？大家有没有想过？</p>
<p>设集合G，然后我们定义有一个*这个二元运算（注意，这个运算不一定是乘法，也不一定是加法，它表示一个二元运算，仅此而已）。对于集合的任意元素a，b，都有以下关系成立：</p>
<ul>
<li>a * b ∈ G</li>
</ul>
<p>此时，我们称： 关于运算*， 集合G封闭。 （封闭有些时候也称闭包closure）</p>
<p>从集合出发，加入二元运算，从而定义了群的概念，对于某二元运算*, 单单具有封闭性的集合叫原群（magma）。</p>
<p>如果该运算还具有结合律，也就是不拘泥于运算的顺序：</p>
<ul>
<li>(a * b) * c = a * (b * c) ∈ G  且  a, b , c ∈ G 且 a，b，c为G中的任意三个不同的元素</li>
</ul>
<p>如果对于运算 * ，具有封闭性，结合律的集合称为半群（semi-group）。</p>
<p>如果对于运算 *, 满足以下性质：</p>
<ul>
<li>a * e = e * a = a 且 a, e ∈ G 且 a为G中的任意一个元素</li>
</ul>
<p>此时我们称元素e是在集合G下运算*中的单位元。</p>
<p>举个例子， 对于集合Z，在运算 + （加法）里单位元就是0,但是在运算 × （乘法）里单位元是1。</p>
<p>如果对于运算 *, 具有封闭性，结合律和单位元的集合称为幺半群（monoid）。哈哈，看到这里，如果对于Haskell等函数式语言比较熟悉的人是不是经常听过单子（monad）这种概念？他们确实是有关的，这里不打算延伸，感兴趣请看<a href="http://hongjiang.info/semigroup-and-monoid/" target="_blank" rel="noopener">《我所理解的monad(1)：半群(semigroup)与幺半群(monoid)》</a>。</p>
<p>如果对于运算 *, 满足以下性质：</p>
<ul>
<li>a * b = b * a = e   且 a, b, e ∈ G </li>
</ul>
<p>此时我们称元素b是关于运算*的a的逆元。</p>
<p>举个例子，对于集合R，关于运算 + （加法）里，4的逆元就是-4,但是在运算 × （乘法）里4的逆元是1/4。</p>
<p>这么一来，如果对于运算 *, 具有封闭性，结合律，单位元，逆元就称为群（group）。</p>
<p>所以引出了群的定义（公理），将满足以下性质的集合G称为群：</p>
<ul>
<li>关于运算 * 封闭</li>
<li>对于任意的元，都满足结合律</li>
<li>存在单位元</li>
<li>对于任意的元，都有与其对应的逆元</li>
</ul>
<h3 id="阿贝尔群"><a href="#阿贝尔群" class="headerlink" title="阿贝尔群"></a>阿贝尔群</h3><hr>
<p>阿贝尔群是群中的特殊存在，它对群的概念又加上了特殊的限制，也就是在集合G上，对于运算*, 任意元都满足交换律，那么就称为阿贝尔群：</p>
<ul>
<li>a * b = b * a 且 a, b ∈ G 且 a，b为G中的任意两个元素</li>
</ul>
<p>阿贝尔群与普通群的区别就在于是否满足交换律。阿贝尔群的公理如下：</p>
<ul>
<li>关于运算 * 封闭</li>
<li>对于任意的元，都满足结合律</li>
<li>存在单位元</li>
<li>对于任意的元，都有与其对应的逆元</li>
<li>对于任意的元，都满足交换律</li>
</ul>
<p>当然，阿贝尔群又称为交换群，纯数学专业可能会有开设《交换群论》这样的深入点的专业课。</p>
<h2 id="从群到环"><a href="#从群到环" class="headerlink" title="从群到环"></a>从群到环</h2><hr>
<p>环（Ring）又在阿贝尔群的基础上，加入了另一种二元运算，暂且这里叫做乘法二元运算吧，这个乘法与初等代数不大一样。加法运算也与初等代数不大一样。</p>
<p>所以环就是二种不同的二元运算作用在集合G上，并满足以下性质：</p>
<ol>
<li>关于运算 + （加法）：</li>
</ol>
<ul>
<li>封闭</li>
<li>存在单位元</li>
<li>所有元素都满足结合律</li>
<li>所有元素都满足交换律</li>
<li>任意一个元素都存在与其对应的逆元</li>
</ul>
<ol start="2">
<li>关于运算 × （乘法）：</li>
</ol>
<ul>
<li>封闭</li>
<li>存在单位元</li>
<li>所有元素都满足结合律</li>
</ul>
<ol start="3">
<li>关于运算 + 和  ×  ：</li>
</ol>
<ul>
<li>所有元素都满足分配律, 即(a + b) × c = (a × c) + (b × c)</li>
</ul>
<p>如果细心的人仔细看环的公理，并对比之前阿贝尔群的公理，其实会发现：</p>
<ul>
<li>环关于加法一定构成了阿贝尔群</li>
<li>换关于乘法不一定是阿贝尔群（也有可能是阿贝尔群）</li>
<li>环关于乘法一定构成幺半群</li>
</ul>
<h3 id="交换环"><a href="#交换环" class="headerlink" title="交换环"></a>交换环</h3><hr>
<p>交换环就是环关于乘法运算上，所有元素满足交换律：</p>
<ol>
<li>关于运算 + （加法）：</li>
</ol>
<ul>
<li>封闭</li>
<li>存在单位元（0）</li>
<li>所有元素都满足结合律</li>
<li>所有元素都满足交换律</li>
<li>任意一个元素都存在与其对应的逆元</li>
</ul>
<ol start="2">
<li>关于运算 × （乘法）：</li>
</ol>
<ul>
<li>封闭</li>
<li>存在单位元（1）</li>
<li>所有元素都满足结合律</li>
<li>所有元素都满足交换律</li>
</ul>
<ol start="3">
<li>关于运算 + 和  ×  ：</li>
</ol>
<ul>
<li>所有元素都满足分配律, 即(a + b) × c = (a × c) + (b × c)</li>
</ul>
<h3 id="剩余类环"><a href="#剩余类环" class="headerlink" title="剩余类环"></a>剩余类环</h3><hr>
<p>我们举个例子，整数集合Z关于加法和乘法构成环，我们把这个环称为整数环，如果我们把mod运算考虑进加法和乘法运算的话，那么就会变成这样（设m为某个常数）：</p>
<ul>
<li>a + b mod m</li>
<li>a × b mod m</li>
<li>(a + b) × c mod m</li>
</ul>
<p>那么这些运算的结果集合也构成了环： Z/mZ {0,1,2,3,4 … m - 1}。这个环我们称为剩余类环，所以可以把Z和Z/mZ同等看待。</p>
<p>这两种环都满足换的公理，但是，这两种环还是不大相同，Z就像数轴上排列的点，Z/mZ类似于时钟的表盘构成的圆环; Z是无限集合， Z/mZ是有限的集合; Z具有无限性，Z/mZ具体周期性，集合大小被限制在了某个范围。</p>
<p>只要从环中推导出某个定理，那么这个定理一定适用与Z，也同样适用于Z/mZ。这就是抽象代数的魅力，哈哈，这样是不是mod运算有点类似于化简，归整？ 把无限变成有限，将无限宇宙尽收掌心，好利于研究或计算啊。这时候我想起了霍金写的《果壳中的宇宙》。</p>
<h2 id="从环到域"><a href="#从环到域" class="headerlink" title="从环到域"></a>从环到域</h2><hr>
<p>从环（特指交换环）的公理来看，似乎关于乘法运算上与加法运算对比还缺少一个特性： 关于乘法的逆元。 也就是说，环里不一定能进行除法运算，除法运算本质上就是乘法逆元。</p>
<p>说到这里就可以看到，如果一个环关于乘法上，每个非零的元素都要有乘法逆元（非零是因为0不能作除数），那么就可以把这个环称为域（Field）。</p>
<p>哈哈，我们终于从群开始慢慢过渡到了域。</p>
<p>现在来回顾一下，对于群而言，集合中只能定义一种二元运算，对环来说，定义了两种二元运算，而对于域是定义了三种二元运算吗？  不是的。</p>
<p>如果你仔细想想加法和乘法的相反运算都是通过逆元来定义的，那么你就清楚了。存在加法和关于加法上的逆元就能进行减法运算，同理，存在乘法和关于乘法上的逆元（除0以外）就能进行除法运算。所以关于乘法是否存在逆元就是环（交换环）和域的唯一区别。</p>
<p>域的公理自然而然就是这样了：</p>
<ol>
<li>关于运算 + （加法）：</li>
</ol>
<ul>
<li>封闭</li>
<li>存在单位元（0）</li>
<li>所有元素都满足结合律</li>
<li>所有元素都满足交换律</li>
<li>任意一个元素都存在与其对应的逆元</li>
</ul>
<ol start="2">
<li>关于运算 × （乘法）：</li>
</ol>
<ul>
<li>封闭</li>
<li>存在单位元（1）</li>
<li>所有元素都满足结合律</li>
<li>所有元素都满足交换律</li>
<li>除0以外的所有元素都存在与其对应的逆元</li>
</ul>
<ol start="3">
<li>关于运算 + 和  ×  ：</li>
</ol>
<ul>
<li>所有元素都满足分配律, 即(a + b) × c = (a × c) + (b × c)</li>
</ul>
<p>由此可见，域是一种能够进行加减乘除的代数结构，是集合与四则运算的推广。当然，还有一种叫格（lattice）的代数结构，它目前被用在了抗量子算法的密码学领域（基于格的密码学），还有如果你涉及程序语言理论方面的研究，也会用到格的概念。这里不打算深究，因为文章后面的话题暂时似乎是用不到格的概念。</p>
<p>回顾下之前我们提到的整数环Z，整数集合Z是可以构成环的，但是整数环不能构成整数域（逆元不属于整数集合），但是整数环加入除法（乘法逆元），能够构成有理数域。</p>
<p>考虑整数集合Z {… -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5}, 它构成一个整数环Z，我们回到剩余类环的概念，既然整数环是无限的，那么我们就来研究有限的剩余类环吧，反正是一样的，它也是环，对吧。剩余类环Z/mZ是对运算结果加入了mod操作。那我们就来测试一下（设m为5）：</p>
<p>那么剩余类环Z/mZ {0, 1, 2, 3, 4}</p>
<p>3 + 4 mod 5 = 2</p>
<ul>
<li>4 + 1 mod 5 = 0   （对于加法，1的逆元是4） </li>
<li>1 + 4 mod 5 = 0   </li>
<li>3 + 2 mod 5 = 0   （对于加法，3的逆元为2）</li>
<li>2 + 3 mod 5 = 0</li>
<li>0 + 0 mod 5 = 0   （0的加法逆元还是它本身）</li>
</ul>
<p>1 × 3 mod 5 = 3</p>
<ul>
<li>3 × 2 mod 5 = 1   （对于乘法，3的逆元是2）</li>
<li>2 × 3 mod 5 = 1</li>
<li>4 × 4 mod 5 = 1   （对于乘法，4的逆元是4）   </li>
<li>1 × 1 mod 5 = 1   （对于乘法，1的逆元是1）</li>
</ul>
<p>这里例子中为什么没有零？注意，之前提到过，除0以外的任何元素才有乘法逆元，这样才是域。这点要一定记住。</p>
<p>因为 (3 + 4) × 2 = 3 × 2 + 4 × 2 满足分配律 </p>
<p>（3 + 4 mod 5）× 2 mod 5 = 4 mod 5 = 4</p>
<p>3 × 2 mod 5 + 4 × 2 mod 5 = 1 + 3 = 4</p>
<p>(3 + 4) × 2 = 3 × 2 + 4 × 2 = 14 mod 5 = 4</p>
<p>经过以上运算的结果得知，在m = 5的时候，剩余类环Z/mZ是域，因为满足域公理。</p>
<p>那么这样说来，对于剩余类环Z/mZ就一定是域吗？不是的，不信你可以用m = 6来做运算看看，最后结果就不是域。慢慢经过你的m测试越来越多，你会发现，居然要m是质数（素数）的情况下，剩余类环Z/mZ才是域。m = 质数的情况下，剩余类环这个域也被称为有限域。记作：</p>
<p>设p是质数，m = p</p>
<ul>
<li>Fp = Z/pZ</li>
</ul>
<p>如果把剩余类环看作是整数的微缩模型，那么用质数p构造出的有限域Fp也可以说是有理数的微缩模型吧。这个有理数域的微缩模型被限定在了p内，并且有限域都是整数！ 能够化简到如此简单，数学真的很美妙，此时我的眼眶是湿润的。</p>
<p>这时候你就可以想象下，在平滑无限细分的有理数域把它化简到有限域Fp，那么这个离散化的过程最终的成果就是，计算机就可以处理有限并且离散的数据了，因为最开始，计算机是不能精确求光滑无限细分的问题的</p>
<p>有限域，这个概念，慢慢会出现在椭圆曲线密码学中。接下来我们就开始接触椭圆曲线密码学吧。</p>
<h2 id="椭圆曲线密码学"><a href="#椭圆曲线密码学" class="headerlink" title="椭圆曲线密码学"></a>椭圆曲线密码学</h2><hr>
<h3 id="椭圆曲线"><a href="#椭圆曲线" class="headerlink" title="椭圆曲线"></a>椭圆曲线</h3><hr>
<p>其实椭圆曲线是非欧几何下引伸出来的一种几何。大家都知道在欧式几何里面平面上的两条平行线不相交吧？如果修改欧几里德第五公设（过直线外一点，有且仅有一条与该直线的平行线），那么就可以导出了非欧几何。非欧几何大概有两种：</p>
<ul>
<li>罗氏几何（双曲几何）（修改后的第五公设：过直线外一点至少有两条不同的直线和已知直线平行）</li>
<li>黎曼几何（椭圆几何） （修改后的第五公设：过直线外一点所作任何直线都与该直线相交，也就是没有任何一条平行线）</li>
</ul>
<p><img src="http://wx4.sinaimg.cn/mw690/a1ac93f3gy1g4romaswt8j20dm05d3yt.jpg" alt=""></p>
<p>在非欧几何的研究中，可以导出很多更加有趣的几何性质。</p>
<p>比如：</p>
<ul>
<li>罗氏几何中，在马鞍面（双曲抛物面）上画一个三角形，其内角和就小于180度。</li>
<li>黎曼几何中，在球面上画一个三角形，其内角和就大于180度。</li>
</ul>
<p><img src="http://wx3.sinaimg.cn/mw690/a1ac93f3gy1g4romabr0fj20go06b3z0.jpg" alt=""></p>
<p>理解了黎曼几何，那么就理解了黎曼面上看似平行的平行线其实是会有交点的。可以理解为相交在很远很远的地方，即定义了平行线相交于无穷远点（point at infinity）。</p>
<p>好了，这样我们假设在欧几里德平面上画一条直线A，我们想像一下，我们为直线A添加一个无穷远点P，那么我们得到一个扩大的直线（直线A的有穷点和无穷远点P构成），这个直线专业点的叫法叫射影直线（projective line），也称一维射影空间。然后我们在该平面上画一条直线B，它平行于A，我们假设这条线B与A相交于无穷远点P。（因为欧几里德平面的平行线是不可能有交点的，所以只能用无限的思维假设AB两条平行线在无穷远处相交于点P）</p>
<p>这样我们试着导出了以下三个性质：</p>
<ul>
<li>一条直线只有一个无穷远点；所有平行线有公共的无穷远点P</li>
<li>任何两条不平行的直线有不同的无穷远点（否则会造成有两个交点）（P1,P2，P3….. Pn）</li>
<li>射影平面上所有无穷远点(P1,P2,P3….Pn)构成连接成一条无穷远直线</li>
</ul>
<p>那么，根据以上三个性质，我们定义了射影平面：所有的欧式平常直线和那一条无穷远直线构成了射影平面。也可以说，所有平常点与所有无穷远点构成了射影平面，还或者可以说，所有的射影直线构成了射影平面，本质都是一样的</p>
<p>哈哈，小学大家都知道，点构成线，线构成了面，面构成体，是吧。</p>
<p>因为在欧式平面上的平行线都有相同的无穷远点，不同的线又有不同的无穷远点，无穷远点又构成一条无穷远直线，所以射影平面上的任何一点都可以用三维的齐次坐标（X，Y，Z）表示，其中X，Y，Z不能全为0。</p>
<p>其中</p>
<ul>
<li>当 Z 不为 0，则该点表示欧氏平面上的点(X/Z,Y/Z)。 （欧式平面的平常点，构成了所有欧式直线）</li>
<li>当 Z 为0, 则该点表示无穷远点 （无穷个无穷远点构成了无穷远直线）</li>
</ul>
<p>这样我们就可以根据以上的坐标表示，把欧式平面上的点投影到射影平面中去。</p>
<p>例如，把一个欧式平面上的点（x,y）,令 x = X/Z， y = Y/Z, Z != 0, 则投影到射影平面上的点就是（X，Y，Z）。 用具体数字代换进去就是，点（1,2）投影到射影平面的点就是（Z，2Z，Z），所以，诸如(1,2,1),(2,4,2)等这样形式的坐标表示是点，在射影平面内都算同一个点。</p>
<p>这时候关键的人物上场了，就是我们期待已久的椭圆曲线，它的定义就是：</p>
<ul>
<li>在射影平面上满足威尔斯特拉斯椭圆方程（Weierstrass）所有点的集合</li>
</ul>
<p>该方程的表示是（注意，是三元方程）：</p>
<p><img src="http://wx4.sinaimg.cn/mw690/a1ac93f3gy1g4rom94twwj20dg01idfo.jpg" alt=""></p>
<p>该方程可以归整到欧式二维平面的方程表示形式：</p>
<p><img src="http://wx3.sinaimg.cn/mw690/a1ac93f3gy1g4rom8opvgj2050017dfl.jpg" alt=""></p>
<p>其中a,b为常数系数，以下是a，b不同的取值，表现的椭圆曲线的欧式二维图像：</p>
<p><img src="http://wx1.sinaimg.cn/mw690/a1ac93f3gy1g4rom8aszvj20fg03dt8m.jpg" alt=""></p>
<p>所以可以看到，椭圆曲线并不是椭圆形，这个是有历史原因的，因为椭圆曲线方程与求椭圆弧长的椭圆积分的反函数很像。</p>
<p>到这里大部分网络上会直接把上面的方程写出来，没有讲述过多的来源和发展历史。所以就以为椭圆曲线是一个二维的东西，实际上不是。因为投影的关系，我们可以降维到用二维的图像来研究它。</p>
<p>还有一个要注意的一点就是，椭圆曲线是非奇异的，也就是是光滑的，也就是各个分量的偏导数不能全为0。而且欧式二维平面的椭圆曲线因为有y^2项，所以一定关于x轴对称的，这个性质之后会用得到。</p>
<h3 id="椭圆曲线上的运算"><a href="#椭圆曲线上的运算" class="headerlink" title="椭圆曲线上的运算"></a>椭圆曲线上的运算</h3><hr>
<p>之前我们看到，椭圆曲线那么奇怪，歪瓜咧枣的线条是怎样跟密码学里关联上了？曲线上的这些点有什么联系呢？ 依靠点与点之间的心灵感应吗？ 哈哈，这里开个玩笑。</p>
<p>回顾下之前我们学的关于群的部分，我们要定义个点与点之间的的二元加法运算，这个运算在曲线上的点的集合上构成一个阿贝尔群。所以就涉及到怎样设计这个二元加法运算满足阿贝尔群公理就是个问题，跟初等代数的加法不一样哈。</p>
<p>那么设两个在椭圆曲线上的点P，点Q，那么P + Q就是连接PQ两点作直线，相交于椭圆曲线于一个点R’，那么过交点R‘作与x轴的垂线并延长再次与椭圆曲线相交于一个点R，那么P + Q = R。也就是点R’与点R关于曲线的x轴对称。</p>
<p>以下就是椭圆曲线上P + Q = R的加法运算的图像（网络上很多，随便找的）：</p>
<p><img src="http://wx3.sinaimg.cn/mw690/a1ac93f3gy1g4rom7r27qj20dt0bj0td.jpg" alt=""></p>
<p>根据上图，你可以在草稿纸上画，第一眼就可以看出来满足交换律， P + Q = Q + P = R，</p>
<p>然后你在设一个点K，然后再画直线，你会发现（P + Q） + K = P + （ Q + K）也满足结合律。</p>
<p>按照上面的定义，前提假设是P ！= Q，没法解释 P = Q 也就是P，Q两点重合的情况下，无法过两点作一条直线，这时候的加法运算是怎么定义的呢？其实只要过两点的重合点画出该点在椭圆曲线上的切线就可以了，然后规则与上一个图例是一样的：</p>
<p><img src="http://wx1.sinaimg.cn/mw690/a1ac93f3gy1g4xzcjcdk0j20d80c3q46.jpg" alt=""></p>
<p>上图就定义了P + P = 2P = R，这样的运算称为椭圆曲线上的二倍运算。</p>
<p>此外，如果我们将某一点A关于x轴对称位置的点定义为-A，这样的运算称为椭圆曲线上的正负取反运算，如下图：</p>
<p><img src="http://wx3.sinaimg.cn/mw690/a1ac93f3gy1g4xzor8tj4j20lk0fawep.jpg" alt=""></p>
<p>上图就定义了类似我们印象中的负数，好了，如果我们将A和-A相加会怎样呢？ 上图也说明了A+（-A）的情况，就是过这两点作一条直线，这条直线是与y轴平行的，唉？不对啊，这条直线与椭圆曲线没有第三个交点了啊？ 其实不是的，因为椭圆曲线实际上并不是欧式二维平面的东西，它来自于非欧几何中的黎曼几何（黎曼球面），二维平面也展示不出来交点，我们就认为过点A和-A的这条直线与椭圆曲线相交在无穷远点，这个无穷远点我们一般记作O。所以就定义了 A + （-A） = O 。 </p>
<p>好了，至此为止，我们对椭圆曲线上的点（包括无穷远点）的加法运算进行了定义，细心的人会发现，这个在椭圆曲线的点集和无穷远点点集上定义的加法运算满足了之前阿贝尔群（交换群）的公理， 无穷远点O就是单位元，任意一点A的逆元就是-A，并满足交换律，结合律。完美啊，perfect。</p>
<p>曲线上的运算规则已经清晰，当给定椭圆曲线方程及点的坐标时，我们就可以用坐标进行加，减，倍乘运算。比如，给定曲线上的一个点G（基点，base point），我们可以求2G，3G。其中3G = G + 2G，以此类推。也就是说，当给定G点时，已知标量k，求点kG（G的k倍）的问题并不困难。但反过来，已知点kG求标量k则非常困难。这就是椭圆曲线密码学中所利用的“椭圆曲线上的离散对数问题”，英文简称也就是所谓的ECDLP。</p>
<p>通过以上解释，已知G点的情况下，其实标量k也可以看作是私钥，kG看作公钥。从私钥计算公钥很简单，但是根据公钥推私钥，几乎不可能。这就是非对称的密钥对。</p>
<h3 id="椭圆曲线上的离散对数问题"><a href="#椭圆曲线上的离散对数问题" class="headerlink" title="椭圆曲线上的离散对数问题"></a>椭圆曲线上的离散对数问题</h3><hr>
<p>ECC利用了ECDLP的复杂度，RSA利用了质因数分解的复杂度，其本质都是利用了计算困难的问题，这深入的话题，研究计算理论，计算复杂度的学者会更有了解。</p>
<h3 id="利用有限域这个工具对椭圆曲线进行离散化"><a href="#利用有限域这个工具对椭圆曲线进行离散化" class="headerlink" title="利用有限域这个工具对椭圆曲线进行离散化"></a>利用有限域这个工具对椭圆曲线进行离散化</h3><hr>
<p>椭圆曲线要形成光滑的曲线，其点的坐标（x，y）都必须是实数，即实数域R上的椭圆曲线。实数域R的椭圆曲线不合适用在密码学当中，计算机擅长于处理有限，并且离散的整数数据，所以要用在有限域Fp上的椭圆曲线（p为素数）。所以点坐标（x，y）这些都在有限域下了。更直观一点的话，就是在有限域限定的整数下来进行点的坐标运算，并且将结果除以p求余数。</p>
<p>例如： y^2 = x^3 + x + 1 (mod 23) 就是位于有限域F（23）上。也就是说对于在有限域F（23）下的任意一点（x，y），对于方程左侧的y^2的结果mod 23 与右侧的x^3 + x + 1的结果mod 23的结果相等。</p>
<p>上面的例子给定的素数p是23,这个素数很小，构成的椭圆曲线在有限域上的离散点的数量太少，所以在这个有限域上的ECDLP不难解，但是当素数p非常大的时候，要解这个问题就非常困难了，通常工业级的椭圆曲线的密码算法库给定的素数p都非常大。</p>
<p>以NIST推荐的一种椭圆曲线Curve P-521为例，其质数p就是下面这个长达157位（十进制位）的数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> ** <span class="number">521</span> - <span class="number">1</span></span><br><span class="line"><span class="number">6864797660130609714981900799081393217269435300143305409394463459185543183397656052122559640661454554977296311391480858037121987999716643812574028291115057151</span></span><br></pre></td></tr></table></figure>
<p>当然，为了提高计算效率，NIST推荐p的值使用梅森素数（或伪梅森素数），例如，在椭圆曲线P-256中，p = 2^156 - 2^224 + 2^192 + 2^96 - 1。</p>
<p>梅森素数目前仅发现51个。梅森数是指2^p - 1这类形式的数，其中p是素数，如果2^p - 1刚好也是素数，那么2^p - 1这个数就是梅森素数。梅森素数很少，梅森数越大，梅森素数就越难出现。</p>
<p>到现在，终于知道为什么人类一直在致力于发现新的素数了吧，其实素数是很有价值的，对科学。当然，也不尽然，因为我看了相关专业的人士评价，其实素数的发现，也仅仅集中在密码学领域有用途，其他方面素数价值并不是很大，人类致力于探寻也只是好奇驱使而已。有兴趣的可以看一看这个世界性的分布式网格计算项目<a href="https://www.mersenne.org/" target="_blank" rel="noopener">GIMPS</a>，该项目就是利用世界上计算机的闲置资源来计算并发现更大的素数。</p>
<h3 id="椭圆曲线点的坐标运算"><a href="#椭圆曲线点的坐标运算" class="headerlink" title="椭圆曲线点的坐标运算"></a>椭圆曲线点的坐标运算</h3><hr>
<p>设点P（x1,y1）,点Q(x2,y2)的坐标，点R（x3,y3），那么计算R点的代换公式分以下几种情况：</p>
<ul>
<li><p>若P为无穷点（单位元），即P = O，此时R = P + Q = O + Q = Q；若Q为无穷点，即Q = O，此时R = P + Q = P + O = P；若P和Q都为无穷点，即 P= Q = O，则 R= P + Q = O + O = O。</p>
</li>
<li><p>若 x1 = x2而 y1 = -y2，此时称Q点为P点的逆元，记为P = -Q = -P，且R = P + Q = O。（也就是P，Q两点关于x轴对称）</p>
</li>
<li><p>若x1 = x2且y1 = y2，即P = Q，此时R = P + Q = 2P = 2Q，其中</p>
</li>
</ul>
<p><img src="http://wx1.sinaimg.cn/mw690/a1ac93f3gy1g4ycfedu0yj20ag06it8o.jpg" alt=""></p>
<p>上图的lambda是值是椭圆方程等式两边同时求导，这样就是当前切点的斜率</p>
<ul>
<li>除上述特殊情况之外的一般情况，即P ！= ±Q时，R = P + Q，其中</li>
</ul>
<p><img src="http://wx3.sinaimg.cn/mw690/a1ac93f3gy1g4yckt86v1j20ak05ymx5.jpg" alt=""></p>
<p>上图的lambda就是过两点求直线斜率的公式了。</p>
<p>以上公式给出来了，代码应该会写了吧，这里就不写了，因为椭圆曲线的坐标加法运算要在有限域Fp下进行，所以上面的公式后面都得mod p。</p>
<p>比如:</p>
<p>lambda = ((3*x1^2 + a) / 2*y1) mod p</p>
<p>x3 = (lambda^2 - 2*x1) mod p</p>
<p>y3 = (lambda*(x1 - x3) - y1) mod p</p>
<p>如果你细心观察上面的运算公式，你会发现lambda的值可能在计算机下会有错误，这种错误就是除数和被除数之前可能并不是一个整除关系的时候，得到的可能是0,或者小数，而有限域下，是不可能有小数存在的，这样计算会有错误。</p>
<p>比如 a = 3, b = 4, p = 7, lambda = （3 / 4） mod 7的计算结果就会有问题，3/4并不是一个整除关系，如果这样计算，计算机最后计算的lambda结果就是0。所以需要把除发转化到乘法逆元，（3 / 4） mod 7 = （3 * 4的逆元） mod 7。</p>
<p>在mod运算下，计算乘法逆元最朴素的方案是用扩展欧几里德算法去求。但是求逆运算性能贼慢，优化方法有很多， 主要思路都是尽量避免求逆，一个是降低总计算步骤中的求逆次数，一个是转换椭圆曲线的坐标系直接避免求逆。这里深入的暂时不介绍，网上论文很多，比如： <a href="https://image.hanspub.org/pdf/CSA20120100000_70975142.pdf" target="_blank" rel="noopener">《GF（3^n）下的椭圆曲线快速算法研究》</a>,这篇论文是北航的，主要是降低求逆次数，对于kG点，其中标量k需要满足3^n的形式，并且对于椭圆方程y^2 = x^3 + a*x + b中的a,b系数也限定在有限域F（3^n）的形式。</p>
<p>就拿普通的点加运算来说，注意看P ！= Q的点加公式，lambda计算上是1次逆运算，1次乘法运算，x3的计算上又是1次平方运算，y3的计算上是1次乘法运算，当然，公式中的加减法的运算开销可以忽略不计，关键就是以上的三种运算，逆运算，平方运算，乘法运算开销最大，其中1次逆运算更是相当于1次乘法运算开销的10倍。</p>
<p>下面来举个例子就知道了，为了方面直观,直接a，b满足整除关系就好了：</p>
<p>（4 / 2） mod 7 = 2</p>
<p>上式可以转换为 (4 <em> inverse(2，7)) mod 7 = (4 </em> 4) mod 7 = 16 mod 7 = 2</p>
<p>其中inverse(2，7)是求2在模7运算下的乘法逆元，我用python计算的，结果为4。可以看出，转化为乘法逆元，其结果是一样的，最终都是等于2。</p>
<p>至此为止，不考虑运算性能的话，只要求逆搞定了，那么椭圆曲线上的所有运算都可以根据公式搞定了。P + Q， kP = P + （k - 1）P， 2P = P + P，3P = 2P + P。反正点的标量乘法，最终都可以退化成点加法。</p>
<h3 id="椭圆曲线的Diffie-Hellman密钥交换"><a href="#椭圆曲线的Diffie-Hellman密钥交换" class="headerlink" title="椭圆曲线的Diffie-Hellman密钥交换"></a>椭圆曲线的Diffie-Hellman密钥交换</h3><hr>
<p>（to be continued）</p>
<h3 id="椭圆曲线的数字签名算法（ECDSA）"><a href="#椭圆曲线的数字签名算法（ECDSA）" class="headerlink" title="椭圆曲线的数字签名算法（ECDSA）"></a>椭圆曲线的数字签名算法（ECDSA）</h3><hr>
<p>（to be continued）</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><hr>
<p>本文只给出了ECC的线性知识的思路，包括从哪里到哪里，但是没有涉及算法优化等细节。有机会我再研究研究，并再写个文章分享出来吧。：）</p>


<!--<a href="https://alexiachen.github.io/blog/2019/06/29/from-group-ring-field-to-ecc/#disqus_thread" class="article-comment-link">Comments</a>
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = ''; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
-->
<div style="display:none">
<script src="http://s4.cnzz.com/stat.php?id=&web_id=" language="JavaScript"></script>script>
</div>






</body>
</html>