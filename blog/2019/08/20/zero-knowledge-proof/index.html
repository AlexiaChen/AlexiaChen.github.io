<html>
<head><meta name="generator" content="Hexo 3.8.0">
	
	<title>给小白看的零知识证明</title>
	<meta name="keywords" content="MathxH Blog">

    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    
	   <link href="/blog/css/main.css?v=3" rel="stylesheet" type="text/css">
    
        <script src="/blog/js/util.js"></script>
        <script>
            if(isMobile()) {
                loadjscssfile('../css/mobile.css', 'css');
            } else {
                loadjscssfile('../css/desktop.css', 'css');
            }
        </script> 
    

    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">

    
	<link rel="shortcut icon" type="image/x-icon" href="/blog/favicon.ico?v=3">
    
    

</head>

<body>


<h2 class="title">给小白看的零知识证明</h2>
<!---
<div style="text-align:center;margin-top: -10px;">
<div class="article-category">
发表于2019年8月20日




 </div>
--->


<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#研究背景"><span class="toc-text">研究背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#简介"><span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ZKP中的参与者"><span class="toc-text">ZKP中的参与者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一个简单的例子"><span class="toc-text">一个简单的例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ZKP的特性"><span class="toc-text">ZKP的特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#互交式证明系统"><span class="toc-text">互交式证明系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#模拟器"><span class="toc-text">模拟器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#零知识证明的基本定义外延"><span class="toc-text">零知识证明的基本定义外延</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对互交式证明系统的总结评论"><span class="toc-text">对互交式证明系统的总结评论</span></a></li></ol></li></ol>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>零知识证明看样子是很复杂的一个过程，其实不是，网络上对这个概念的讲解杂七杂八，质量参差不齐，今天我就打算讲一讲有关话题，我会循序渐进，每个小节我会逐渐加深理解难度，然后最后导出工业界的做法。所以读者最终要的是，首先要做到不要畏惧。实在想不明白可以用手稿纸画一画，推一推。我写文章通常的做法会在专业的名词用括号注释英文，目的是让读者不混淆，并且英文搜索到的资料更准确。</p>
<h2 id="研究背景"><a href="#研究背景" class="headerlink" title="研究背景"></a>研究背景</h2><p>传统的通信协议中的一个共同弱点就是容易遭遇到信道的窃听，所以零知识证明（又叫零知识协议Zero Knownledge protocol，ZKP）就这样诞生了。目的是构造这样一个系统，该系统中的证明人（Prover）可以在不暴露任何信息（Zero Knowledge）的情况下，让验证者（Verifer）进行验证。简而言之，对于监听者，就是你监听了，也没用，你监听到的信息也推导不出来任何有用的东西。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这里要注意下，虽说到这里反复提到了证明（Proof）这个词，但是这个证明不是数学上的证明，数学证明是严格的，使用自证陈述或从预先建立好的证明中获得陈述。ZKP更类似于人类在信息交换过程中建立一个陈述的动态过程，所以它是互交式的（当然，也有非互交式的，这个到后面会提到，而工业界的zk-SNARK用的就是非互交式的）。</p>
<p>简而言之，在ZKP中，所谓互交式就是证明者（Prover）不为它持有的秘密（Secret）直接提供证据，而是双方在一个互交来回“对话”的过程中证明者（Prover）逐渐的说服验证者（Verfier）他持有某个秘密是真实的。Prover也不用暴露秘密就可以说服对方，这样太好了。比如，我可以宣称对外界粉丝说，刘亦菲是我老婆，也不用把结婚证（Secret）拿出来，就能向粉丝们证明我说的是真的（刘亦菲是我老婆），即真命题。哈哈，结婚证是我的秘密隐私啊，怎么可能拿出来给粉丝看。</p>
<h3 id="ZKP中的参与者"><a href="#ZKP中的参与者" class="headerlink" title="ZKP中的参与者"></a>ZKP中的参与者</h3><p>在ZKP中，参与者也就是2方：</p>
<ul>
<li><p>Alice （Prover） Alice想向Bob传达某种知识的证明，但是同时又不想暴露她的秘密</p>
</li>
<li><p>Bob （Verifier） Bob向Alice提出一些问题，这有助于让Bob确认Alice是否知道她声称知道的某些东西， Bob无法从这些互动中学到有用的任何东西，即使Bob在欺骗或从事ZKP以外的活动。</p>
</li>
</ul>
<h3 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h3><p><img src="https://wx4.sinaimg.cn/mw690/a1ac93f3gy1g779gv51ldj20e60cdjta.jpg" alt=""></p>
<p>为了举例，考虑一个由圆形隧道组成的洞穴。与这个洞穴的入口正好相反，有一扇门只能通过密码打开。尽管这种情况可能不是真实的场景，但这个场景演示基本涵盖了ZKP的基本特性，现在Alice知道了这扇门的密码，她想向Bob证明这一点，但又不想把门的密码暴露出来。他们两个人要互动地完成以下任务：</p>
<ul>
<li><p>Alice(绿脸)随机选择一个洞穴的分支进去（左或者右都行），这个不能让Bob（黑脸）知道她选择了哪一个分支</p>
</li>
<li><p>站在洞穴入口处的Bob，他随机选择一个分支，然后让Alice从他选择的那个分支出来</p>
</li>
<li><p>如果Alice真的知道门（红色的线条）的密码，没有撒谎的话，她就可以每次做到从Bob选择的分支出来。如果她不知道门的密码，那她在最开始就有百分之50的概率蒙骗过关，随着这样次数的逐渐增加，Alice蒙骗过关的概率越来越低，在达到一个特定的次数的时候，她蒙骗过关的概率可以小到忽略不计了，比中彩票的概率还要小。</p>
</li>
</ul>
<p>这一个例子也展示了ZKP的另一个特性，Bob确信了Alice有门的密码，但是Bob不能使别人相信Alice有门的密码，这个过程只有他两知道，把过程录下来也无济于事，因为录像带可以造假。所有没有任何有用的信息可以暴露给Bob，更不可能流向协议系统之外，只有Alice自己知道门的密码。</p>
<h3 id="ZKP的特性"><a href="#ZKP的特性" class="headerlink" title="ZKP的特性"></a>ZKP的特性</h3><p>所以ZKP的特性可以总结如下：</p>
<ul>
<li><p>验证者（Verifier）无法从协议中学习到任何有用的知识。这是ZKP的核心特性，也就是说零数量的知识被暴露出来。当然有个类似的协议叫最小披露协议（Minimum Disclosure Protocol），它适当放宽了这个特性要求，试图暴露一个尽可能最小的知识出去。</p>
</li>
<li><p>证明者（Prover）无法欺骗验证者（Verifier）。随着协议互交轮次的数量提高，Prover欺骗Verifier的概率急剧降低，慢慢小到可以忽略不计。</p>
</li>
<li><p>验证者（Verifier）也无法欺骗证明者（Prover）。即使验证者不遵守协议规则，验证者也无法从协议中获取任何信息，验证者只能慢慢确信证明者陈述的某个命题是真的。</p>
</li>
<li><p>验证者（Verifier）无法向外界证明证明者（Prover）所说的是真的。比如，我（Prover）通过ZKP向某个刘亦菲的粉丝（Verifier）证明了刘亦菲是我老婆，但是这个粉丝（Verifier）不能向其他粉丝证明刘亦菲是我老婆。只有天知地知，你知我知。</p>
</li>
</ul>
<p>好的，接下来在引出ZKP的定义之前，我们需要讨论一些诸如此类证明系统一些必要属性，这些属性包括正确性和完备性。</p>
<h2 id="互交式证明系统"><a href="#互交式证明系统" class="headerlink" title="互交式证明系统"></a>互交式证明系统</h2><p>零知识协议是交互式证明系统的实例之一，其中证明者和验证者互相交换挑战，然后响应，通常依赖于允许他们保密的随机数（理想情况下，公平投币的结果）。正如我们前面所说，在这种情况下，证明是概率的，而不是数学意义上那种绝对的。这些证明只需要在一定的有界概率下才是正确的（尽管这个概率可以任意接近100%）。交互证明有时被称为协议证明。</p>
<p>用于识别的交互证明可以被表述为知识的证明。Prover有一个秘密（记为s），他希望通过正确地回答出需要秘密s作为依据推导而出的知识才能回答Verifier的提问，使Verifier相信Prover他知道s。值得注意的是，证明s的知识与证明s的存在性是完全不同的，例如，证明某个x是模n的二次剩余与证明x的平方根模n的知识是不同的，表示出来就是 k^2 = x mod n 给定x和n，如果k在该二次同余方程下有解，那么则得出 k = square(x) mod n。（实在不明白搜二次剩余，数论的东西）</p>
<p>如果一个交互式的证明具有完备性和可靠性，那么它就是知识证明。</p>
<ul>
<li>完备性的定义</li>
</ul>
<p>如果给定一个诚实的Prover和一个诚实的Verifier，协议以几乎100%的概率成功（即，Verifier接受Prover的声明），则交互式证明协议是完备的。当然，几乎100%的定义取决于应用，但通常意味着失败的概率在这个场景下并不具有实际意义。（也就是低到可以忽略了）</p>
<p>当然，还可以用形式化点的方式来描述，设Prover和Verifier是一对互交的概率图灵机，随机变量&lt;P(i),V(j)&gt;(x)表示图灵机Verifier与Prover完成互交问答后的输出（这个输出是一个概率值），&lt;&gt;其中x为它们的公共输入，所以可以化简为&lt;P(i),V(j)&gt;(x) = 1表示V接受P给出的证明，&lt;P(i),V(j)&gt;(x) = 0表示V拒绝P给出的证明。其中i，j都是P和V各自的随机输入变量（均匀独立的）。&lt;P,V&gt;这对互交图灵机表示语言L的互交证明系统。</p>
<p>Probability（&lt;P(i),V(j)&gt;(x) = 1） &gt; 1 - c(|x|) 其中函数c表示完备性错误概率，可忽略。 x属于语言L</p>
<p>以上式子表示完备性成功的概率极大。</p>
<ul>
<li>可靠性的定义</li>
</ul>
<p>如果存在具有以下性质的期望多项式时间算法m，则交互式证明协议是可靠的：如果不诚实的Prover能够以不可忽略的概率与Verfier成功执行协议（成功概率极大，反过来就是说失败率极小），则m可用于从该Prover中提取知识（本质上等同于Prover的秘密）以几乎100%的概率允许随后（下一轮，依次递推）的协议执行</p>
<p>用形式化的方式来说就是：</p>
<p>B代表任意的Prover，也就是可以认为是不诚实的Prover</p>
<p>Probability（&lt;B(i),V(j)&gt;(x) = 1） &lt; s(|x|) 其中函数s为可靠性错误概率，可忽略。x不属于语言L</p>
<p>以上式子表示可靠性失败的概率极小。</p>
<p>所以总而言之，可以这么说，对于任意的Verifier，存在一个多项式时间的算法m（x）（通常成为模拟器），使得Verifier在互交过程中得到的所有信息都可以直接利用算法m（x）模拟出来，也就是说Verifier从Prover那里得到的所有信息都可以用算法m计算得到。简而言之就是，Verifier没有从Prover那里获得任何额外的信息。</p>
<p>因为想冒充Prover就必须拥有这个secret，所以协议的可靠性就是靠提供与secret的等价的知识证明来保证的，这个属性条件保证了不诚实（作恶，假冒）的Prover成功。所以又可以反向得出一个方法，就是，证明某个协议是正确的标准方法就是是假设有一个不诚实（作恶，假冒）的Prover能够成功地执行该协议，并说明他是如何在多项式时间内计算出secret的。</p>
<p>这种“知识证明”思想是零知识证明的基础。然而，很明显，这两个属性都没有提到零知识本身。此外，ZKP还应该具有这样的属性，即在Prover和Verifier之间不应该传递Verifier没有Prover的帮助来识别的知识量。换句话说就是，Prover和Verifier之间传播的知识都是经过Prover认同的。此属性简单地称为零知识属性，将在引入模拟器的概念后定义，如下所述。</p>
<h3 id="模拟器"><a href="#模拟器" class="headerlink" title="模拟器"></a>模拟器</h3><p>让我们再考虑一下之前Alice和Bob洞穴例子。假设Bob给他的朋友Jack发了一盘录像带，上面是他和Alice一起证明所采取的一系列步骤。我们将这种磁带称为证据的一个视图（或记录本）。Jack指Bob伯伪造录音带，很明显Bob不能做任何事情来说服Jack。Bob没有任何不可伪造的、不可否认的证据，来证明Alice确实知道门的密码。Bob所能做的就是让Alice再次为Jack演示一遍，Jack将为Alice挑选她出来的分支序列，比如左右左右左（这保证了随机性）。如果有一种方法可以伪造一个与真实的证据不可区分的证据（比如录像带），我们就说有一个模拟器可以模拟所讨论的证据。</p>
<p>相当于模拟器就是那个录像机，录像机就是那个多项式算法m。多项式算法m生成的结果就是那个录像带，录像带就是视图。</p>
<ul>
<li>模拟器（simulator）</li>
</ul>
<p>模拟器是一种方法或算法过程（多项式算法m，），它生成的假（生成不需要Prover参与）视图与证明的真（生成时需要Prover参与）视图是不可区分的。也就是说，无论录像带真假，反正Jack是看不出来真假的，只能一股脑认为是假的，没办法，只有他自己与Alice跑协议去，自己去验证。</p>
<p>所以模拟器这个概念是上述零知识属性定义的关键。</p>
<ul>
<li>零知识属性（zero knowledge property）</li>
</ul>
<p>如果存在证明的模拟器，则知识证明具有零知识属性。</p>
<p>这使得文章前面几节所描述的内容都用上了，意思是说，在zkp的上下文中，Verifier除了获得secret的有效性之外，不会获得有关该secret的更多信息。此外，这类协议的一个非常理想的特性是，Prover参与协议的次数不会改变模拟攻击成功的机会。这样零知识属性使我们可以得到如下零知识证明的定义。</p>
<ul>
<li>零知识证明</li>
</ul>
<p>零知识证明是同时具有零知识属性的知识证明。</p>
<h3 id="零知识证明的基本定义外延"><a href="#零知识证明的基本定义外延" class="headerlink" title="零知识证明的基本定义外延"></a>零知识证明的基本定义外延</h3><p>还有一些基本定义的外延是比较重要的，需要了解。</p>
<p>说如果一个交互式证明是零知识的，那么存在一个simulator（算法m），使得Verifier与真正的Prover交互产生的证明副本（录像带）的整体分布（ensemble distribution）和与一个simulator交互产生的证明副本（录像带）的整体分布等价。</p>
<ul>
<li>完全零知识（Perfect Zero knowledge）</li>
</ul>
<p>如果真实和模拟的记录本（录像带）彼此之间完全不可区分，则协议称为完全零知识。即两个分布完全等价，这个定义是好理解的，但却是最苛刻的。</p>
<ul>
<li>统计零知识（Statistical Zero Knowledge）</li>
</ul>
<p>如果真实和模拟的记录本（录像带）的概率分布之间存在可忽略的差异，则协议是统计零知识。两个分布是统计闭合的（statistical close）。统计闭这个名词，它是说两个分布本身相差很小很小（可忽略）</p>
<ul>
<li>计算零知识（Computational Zero Knowledge）</li>
</ul>
<p>如果受限于概率多项式时间测试的观察者不能区分真实和模拟的记录本（录像带），则协议的计算零知识。即两个分布多项式不可区分。</p>
<p>所以， 完全零知识强于 &gt; 统计零知识强于 &gt; 计算零知识</p>
<p>显然，计算零知识是对基本概念的采取的是一个最宽松的限制。尽管如此，它仍然是非常有用的，因为在实践中，“攻击者”通常被认为拥有对我们的系统进行攻击的多项式时间能力。已经定义了其他外延，例如非交互式零知识协议，其中Prover不必在场以使Verifier相信其知识。本文将不讨论这些外延。</p>
<p>还有其他类型的证明虽然不是零知识的，但是也不是没用到零知识和最小披露协议。这些证明中与零知识证明的区别变化仅仅是在协议执行过程中，允许从Prover流向Verifier的信息量和信息类型在可控或很小的范围内。</p>
<h3 id="对互交式证明系统的总结评论"><a href="#对互交式证明系统的总结评论" class="headerlink" title="对互交式证明系统的总结评论"></a>对互交式证明系统的总结评论</h3><p>（To be continued）</p>


<!--<a href="https://alexiachen.github.io/blog/2019/08/20/zero-knowledge-proof/#disqus_thread" class="article-comment-link">Comments</a>
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = ''; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
-->
<div style="display:none">
<script src="http://s4.cnzz.com/stat.php?id=&web_id=" language="JavaScript"></script>script>
</div>






</body>
</html>