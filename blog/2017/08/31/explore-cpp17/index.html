<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>C++ 17的特性探索 | MathxH</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="前言 随着C++ 17标准今年出来以后，各大社区都有C++ 17的讨论，C++的爱好者们都希望这门语言变得更像现代编程语言一样，越来越好用，拥有越来越高级的抽象语义。以下是知乎上的几个讨论：  怎样看待C++17众多功能流产? C++17 有哪些值得注意的新特性? C++17 基本完成，对于新特性大家怎么看? C++ 17的19个基本特性  另外，各大编译器产商也对C++ 17的标准实现进行了跟进">
<meta name="keywords" content="C&#x2F;C++">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ 17的特性探索">
<meta property="og:url" content="https://alexiachen.github.io/blog/2017/08/31/explore-cpp17/index.html">
<meta property="og:site_name" content="MathxH">
<meta property="og:description" content="前言 随着C++ 17标准今年出来以后，各大社区都有C++ 17的讨论，C++的爱好者们都希望这门语言变得更像现代编程语言一样，越来越好用，拥有越来越高级的抽象语义。以下是知乎上的几个讨论：  怎样看待C++17众多功能流产? C++17 有哪些值得注意的新特性? C++17 基本完成，对于新特性大家怎么看? C++ 17的19个基本特性  另外，各大编译器产商也对C++ 17的标准实现进行了跟进">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-01-04T15:05:55.855Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++ 17的特性探索">
<meta name="twitter:description" content="前言 随着C++ 17标准今年出来以后，各大社区都有C++ 17的讨论，C++的爱好者们都希望这门语言变得更像现代编程语言一样，越来越好用，拥有越来越高级的抽象语义。以下是知乎上的几个讨论：  怎样看待C++17众多功能流产? C++17 有哪些值得注意的新特性? C++17 基本完成，对于新特性大家怎么看? C++ 17的19个基本特性  另外，各大编译器产商也对C++ 17的标准实现进行了跟进">
  
    <link rel="alternate" href="/blog/atom.xml" title="MathxH" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/blog/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog/" id="logo">MathxH</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/blog/" id="subtitle">MathxH</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blog/">Home</a>
        
          <a class="main-nav-link" href="/blog/archives">Archives</a>
        
          <a class="main-nav-link" href="/blog/about">About</a>
        
          <a class="main-nav-link" href="/blog/resume">Resume</a>
        
      </nav>
      <nav id="sub-nav">
        <a></a>
        
          <a id="nav-rss-link" class="nav-icon" href="/blog/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://alexiachen.github.io/blog"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-explore-cpp17" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2017/08/31/explore-cpp17/" class="article-date">
  <time datetime="2017-08-31T06:38:18.000Z" itemprop="datePublished">2017-08-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      C++ 17的特性探索
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>随着C++ 17标准今年出来以后，各大社区都有C++ 17的讨论，C++的爱好者们都希望这门语言变得更像现代编程语言一样，越来越好用，拥有越来越高级的抽象语义。以下是知乎上的几个讨论：</p>
<ul>
<li><a href="https://www.zhihu.com/question/42152208" target="_blank" rel="noopener">怎样看待C++17众多功能流产?</a></li>
<li><a href="https://www.zhihu.com/question/32222337" target="_blank" rel="noopener">C++17 有哪些值得注意的新特性?</a></li>
<li><a href="https://www.zhihu.com/question/56943731" target="_blank" rel="noopener">C++17 基本完成，对于新特性大家怎么看?</a></li>
<li><a href="https://www.oschina.net/news/85129/top-19-new-features-of-c17-you-need-to-know" target="_blank" rel="noopener">C++ 17的19个基本特性</a></li>
</ul>
<p>另外，各大编译器产商也对C++ 17的标准实现进行了跟进。本着垠神的文章<a href="http://www.yinwang.org/blog-cn/2017/07/06/master-pl" target="_blank" rel="noopener">《如何掌握所有的程序语言》</a>里面所说，不要关注语言的语法细节，而着重关注学习语言的特性，我打算探索下C++ 17的语言特性，当然，有些特性在其他语言也有对应的概念，比如any，variant，optional等在Java 8中也有了。</p>
<h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><hr>
<p>C++17提供了optional这个特性，该特性以类的形式提供，管理一个可选的值。它的常用场景其实没什么高深的，类似于lambda表达式简化了代码，该特性可以用来表示函数的返回值，该返回值可以表现函数可能会调用失败的信息。（注：boost也实现了此特性）</p>
<p>比如你想实现一个把字符串转换为整数的函数，你采用最传统的方法来实现:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">parse_int</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; s, <span class="keyword">int</span>&amp; i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 实现算法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个函数的签名其实并不美观，简洁。第一个参数为需要处理的输入字符串，第二个参数是处理成功时候通过引用的输出参数。最后用了bool返回值来告诉caller是否处理失败。</p>
<p>或者为了减少参数，降低干扰信息，还可以用一个方法，但是还是比较丑陋:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">parse_int</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 实现算法</span></span><br><span class="line">   <span class="comment">// 如果失败，返回nullptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的函数用空指针代替了失败的信息。函数签名还是不美观，而且这样的用法极少，需要动态内存分配。很少有开发人员会通过内部new一个int对象，等到caller使用完毕，caller需要自己手动delete:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *result = parse_int(<span class="string">"12334"</span>);</span><br><span class="line"><span class="keyword">if</span>(result)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *result &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> result; <span class="comment">// 如果使用完毕忘记释放，内存泄漏</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"none"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用optional就方便了:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::optional&lt;<span class="keyword">int</span>&gt; parse_int(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">int</span> result;</span><br><span class="line">   <span class="comment">//....</span></span><br><span class="line">   <span class="keyword">if</span>(isSuccess)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"result is: "</span> &lt;&lt; parse_int(<span class="string">"123456"</span>).value_or(<span class="string">"invalid paramter"</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"result is: "</span> &lt;&lt; parse_int(<span class="string">"dwafawf"</span>).value_or(<span class="string">"invalid paramter"</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">auto</span> result = parse_int(<span class="string">"5643"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"result is: "</span> &lt;&lt; *result &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码会输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result is: 123456</span><br><span class="line">result is: invalid parameter</span><br><span class="line">result is: 5643</span><br></pre></td></tr></table></figure>
<p>还有一个让代码简洁的例子:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lookup</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::optional&lt;Value&gt; get(Key key);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Lookup&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; location_lookup;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> location = location_lookup.get(<span class="string">"waldo"</span>).value_or(<span class="string">"unknown"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="Variant"><a href="#Variant" class="headerlink" title="Variant"></a>Variant</h2><hr>
<p>在C++ 17中以std::variant这个类提供，表示一个类型安全的Union类型。当然，boost有对应的<a href="http://www.boost.org/doc/libs/1_57_0/doc/html/variant.html" target="_blank" rel="noopener">Boost.Variant</a>, Qt有对应的<a href="http://doc.qt.io/qt-5/qvariant.html" target="_blank" rel="noopener">QVariant</a>。 这个类类型的一个实例在给定任何一个时刻保留其中一个类型的值。</p>
<p>设计的动机：</p>
<p>在很多时候，在开发C++程序的过程中，你需要一个类型表示多种类型其中的任何一个类型的时候，你可能相当，union这个关键字来实现以下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> &#123; <span class="keyword">int</span> i; <span class="keyword">double</span> d; &#125; u;</span><br><span class="line">u.d = <span class="number">3.14</span>;</span><br><span class="line">u.i = <span class="number">3</span>; <span class="comment">// overwrites u.d (OK: u.d is a POD type)</span></span><br></pre></td></tr></table></figure>
<p>变量u既可以保存int类型的值，又可以保存double类型的值，但是同一个时刻，只有其中一个类型的值保存在其中，但是很遗憾，union关键字一般只支持基本类型，比如int，char，double之类的POD类型，如果用C++使用面向对象的方式编程，以下非POD的类型就不支持:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> s; <span class="comment">// illegal: std::string is not a POD type!</span></span><br><span class="line">&#125; u;</span><br></pre></td></tr></table></figure>
<p>于是std::variant就产生了:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">std</span>::variant&lt; <span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">string</span> &gt; u(<span class="string">"hello world"</span>);</span><br><span class="line"> <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; u; <span class="comment">// output: hello world</span></span><br><span class="line"> u = <span class="number">13</span>;</span><br><span class="line"> <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; u; <span class="comment">// output: 13</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::variant&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt; v&#123; <span class="number">12</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::get&lt;<span class="keyword">int</span>&gt;(v); <span class="comment">// == 12</span></span><br><span class="line"><span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(v); <span class="comment">// == 12</span></span><br><span class="line">v = <span class="number">12.0</span>;</span><br><span class="line"><span class="built_in">std</span>::get&lt;<span class="keyword">double</span>&gt;(v); <span class="comment">// == 12.0</span></span><br><span class="line"><span class="built_in">std</span>::get&lt;<span class="number">1</span>&gt;(v); <span class="comment">// == 12.0</span></span><br></pre></td></tr></table></figure>
<p>当然，std::variant确实有点用，但是有点鸡肋的感觉。相比Qt的QVariant相差十万八千里。</p>
<h2 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h2><hr>
<p>在C++17中，这玩意儿以std::any的类提供，表示对于一个任意类型的类型安全的单值容器。当然了，Boost库也有对应的<a href="http://www.boost.org/doc/libs/develop/doc/html/any.html" target="_blank" rel="noopener">Boost.Any</a>,当然了这玩意儿跟Variant很像，所以在boost的官方文档中，有了这两个类型的对比:</p>
<blockquote>
<p>As a discriminated union container, the Variant library shares many of the same features of the Any library. However, since neither library wholly encapsulates the features of the other, one library cannot be generally recommended for use over the other.</p>
</blockquote>
<blockquote>
<p>That said, Boost.Variant has several advantages over Boost.Any, such as:</p>
<ul>
<li>Boost.Variant guarantees the type of its content is one of a finite, user-specified set of types.</li>
<li>Boost.Variant provides compile-time checked visitation of its content. (By contrast, the current version of Boost.Any provides no visitation mechanism at all; but even if it did, it would need to be checked at run-time.)</li>
<li>Boost.Variant enables generic visitation of its content. (Even if Boost.Any did provide a visitation mechanism, it would enable visitation only of explicitly-specified types.)</li>
<li>Boost.Variant offers an efficient, stack-based storage scheme (avoiding the overhead of dynamic allocation).</li>
</ul>
</blockquote>
<blockquote>
<p>Of course, Boost.Any has several advantages over Boost.Variant, such as:</p>
</blockquote>
<blockquote>
<ul>
<li>Boost.Any, as its name implies, allows virtually any type for its content, providing great flexibility.</li>
<li>Boost.Any provides the no-throw guarantee of exception safety for its swap operation.</li>
<li>Boost.Any makes little use of template metaprogramming techniques (avoiding potentially hard-to-read error messages and significant compile-time processor and memory demands).</li>
</ul>
</blockquote>
<p>以下是std::any的用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::any x&#123; <span class="number">5</span> &#125;;</span><br><span class="line">x.has_value() <span class="comment">// == true</span></span><br><span class="line"><span class="built_in">std</span>::any_cast&lt;<span class="keyword">int</span>&gt;(x) <span class="comment">// == 5</span></span><br><span class="line"><span class="built_in">std</span>::any_cast&lt;<span class="keyword">int</span>&amp;&gt;(x) = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">std</span>::any_cast&lt;<span class="keyword">int</span>&gt;(x) <span class="comment">// == 10</span></span><br></pre></td></tr></table></figure>
<p>还有更详细的用法:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;any&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// simple example </span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> a = <span class="built_in">std</span>::any(<span class="number">12</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::any_cast&lt;<span class="keyword">int</span>&gt;(a) &lt;&lt; <span class="string">'\n'</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::any_cast&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(a) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(<span class="keyword">const</span> <span class="built_in">std</span>::bad_any_cast&amp; e) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; e.what() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// advanced example</span></span><br><span class="line"> </span><br><span class="line">    a = <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"hello"</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span>&amp; ra = <span class="built_in">std</span>::any_cast&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&amp;&gt;(a); <span class="comment">//&lt; reference</span></span><br><span class="line">    ra[<span class="number">1</span>] = <span class="string">'o'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"a: "</span> &lt;&lt; <span class="built_in">std</span>::any_cast&lt;<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;&gt;(a) &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//&lt; const reference</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> b = <span class="built_in">std</span>::any_cast&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&amp;&amp;&gt;(a); <span class="comment">//&lt; rvalue reference (no need for std::move)</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Note, 'b' is a move-constructed std::string, 'a' is now empty</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"a: "</span> &lt;&lt; *<span class="built_in">std</span>::any_cast&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(&amp;a) <span class="comment">//&lt; pointer</span></span><br><span class="line">        &lt;&lt; <span class="string">"b: "</span> &lt;&lt; b &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从以上代码可以看出来，std::any的使用场景旨在提供类型安全的void<em> ，你会发现，在很多C/C++开发的系统软件的源码里面都用void</em> 来传递上下文（context），无论是线程上下文也好还是其他也罢，但是用void* 来传递上下文信息，原来的类型信息就丢失了，到了要使用上下文的时候，需要强制转换成原来的类型，但是万一转换的类型不对，出错怎么办？如果出错，程序会直接崩溃，不会有任何提示，如果使用了std::any在转换的过程中，如果出错，还会以抛异常的方式来提示用户。</p>
<p><a href="https://www.zhihu.com/question/56317879" target="_blank" rel="noopener">所以大多数情况下使用Any，既可以消除void*的隐患问题，又一样的保证了之前void*的低开发成本，一举两得。</a></p>
<h2 id="std-string-view"><a href="#std-string-view" class="headerlink" title="std::string_view"></a>std::string_view</h2><hr>
<p>这个东西呢，是非真正意义地引用一个字符串，一般用来提供一个字符串之上的抽象，也就是这个view是std::string的一个抽象，可以简单理解为，view是std::string对象的展示层，它不存储实际的数据，只读，不可修改。std::string是Model层，与软件工程中的Model和View对应。</p>
<p>由于以上的一些特点，通常会用到在字符串操作上<a href="https://www.zhihu.com/question/63164644" target="_blank" rel="noopener">性能比较苛刻的场景</a>。</p>
<p>stackoverflow上也有一个<a href="https://stackoverflow.com/questions/20803826/what-is-string-view" target="_blank" rel="noopener">讨论</a>以说明这个库特性的设计动机。</p>
<p>以下是用法:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str&#123; <span class="string">"   trim me"</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::string_view v&#123; str &#125;;</span><br><span class="line"></span><br><span class="line">v.remove_prefix(<span class="built_in">std</span>::min(v.find_first_not_of(<span class="string">" "</span>), v.size()));</span><br><span class="line"></span><br><span class="line">str; <span class="comment">//  == "   trim me"</span></span><br><span class="line">v; <span class="comment">// == "trim me"</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str = <span class="string">"Exemplar"</span>;</span><br><span class="line">    <span class="built_in">std</span>::string_view v = str;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v[<span class="number">2</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="comment">//  v[2] = 'y'; // Error: cannot modify through a string view</span></span><br><span class="line">    str[<span class="number">2</span>] = <span class="string">'y'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v[<span class="number">2</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在以上的第二个代码片段，可以看到把在Model层的str对象修改了，与它关联的view对象立即内容就随之改变了，反之就不能通过view层的v对象来修改Model层的str对象。如果是C++之前的引用概念的话，就能通过引用来修改原对象了。</p>
<p>以前端开发中的React和Vue的状态管理来说，就是说，View的状态变化与Model的状态变化一致，View的状态随着Model的状态改变而改变。但是View自身的状态改变却不能影响Model的状态改变。这个状态传递是单向的，不是双向的。</p>
<h2 id="std-invoke"><a href="#std-invoke" class="headerlink" title="std::invoke"></a>std::invoke</h2><hr>
<p>这个没多少要说的，就是调用一个callable的对象，还可以传递参数。</p>
<p>Callable对象顾名思义就是，可以像普通函数那样调用的对象，比如std::function等等。</p>
<p>以下为用法:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">    Foo(<span class="keyword">int</span> num) : num_(num) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_add</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="keyword">const</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; num_+i &lt;&lt; <span class="string">'\n'</span>; &#125;</span><br><span class="line">    <span class="keyword">int</span> num_;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_num</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PrintNum</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// invoke a free function</span></span><br><span class="line">    <span class="built_in">std</span>::invoke(print_num, <span class="number">-9</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// invoke a lambda</span></span><br><span class="line">    <span class="built_in">std</span>::invoke([]() &#123; print_num(<span class="number">42</span>); &#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// invoke a member function</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> Foo <span class="title">foo</span><span class="params">(<span class="number">314159</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::invoke(&amp;Foo::print_add, foo, <span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// invoke (access) a data member</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"num_: "</span> &lt;&lt; <span class="built_in">std</span>::invoke(&amp;Foo::num_, foo) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// invoke a function object</span></span><br><span class="line">    <span class="built_in">std</span>::invoke(PrintNum(), <span class="number">18</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-9</span><br><span class="line">42</span><br><span class="line">314160</span><br><span class="line">num_: 314159</span><br><span class="line">18</span><br></pre></td></tr></table></figure>
<p>然而，还可以再复杂一点，创建一个代理调用函数的模版类:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Callable&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> &#123;</span></span><br><span class="line">    Callable c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Proxy(Callable c): c(c) &#123;&#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">decltype</span>(<span class="title">auto</span>) <span class="title">operator</span>()(<span class="title">Args</span>&amp;&amp;... <span class="title">args</span>) &#123;</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::invoke(c, <span class="built_in">std</span>::forward&lt;Args&gt;(args)...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> add = [] (<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Proxy&lt;<span class="keyword">decltype</span>(add)&gt; p&#123; add &#125;;</span><br><span class="line">p(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// == 3</span></span><br></pre></td></tr></table></figure>
<p>该模板类可以接收任何函数并作为其代理。</p>
<h2 id="std-apply"><a href="#std-apply" class="headerlink" title="std::apply"></a>std::apply</h2><hr>
<p>这个函数是调用Callable对象并把元组（Tuple）化的参数序列传递给Callable对象，这样就方便了:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> add = [] (<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::apply(add, <span class="built_in">std</span>::make_tuple( <span class="number">1</span>, <span class="number">2</span> )); <span class="comment">// == 3</span></span><br></pre></td></tr></table></figure>
<p>这个特性在类似的函数式语言都会有，比如<a href="https://www.zhihu.com/question/54627596" target="_blank" rel="noopener">Scheme</a>中。</p>
<h2 id="类模版参数推导"><a href="#类模版参数推导" class="headerlink" title="类模版参数推导"></a>类模版参数推导</h2><hr>
<p>自动模版参数推导类似已经完成的函数的参数推导，但是现在可以推导模版类构造函数了:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T = <span class="keyword">float</span>&gt;</span><br><span class="line">struct MyContainer &#123;</span><br><span class="line">  T val;</span><br><span class="line">  MyContainer() : val() &#123;&#125;</span><br><span class="line">  MyContainer(T val) : val(val) &#123;&#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyContainer c1&#123; <span class="number">1</span> &#125;; <span class="comment">// OK MyContainer&lt;int&gt;</span></span><br><span class="line">MyContainer c2; <span class="comment">// OK MyContainer&lt;float&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="用auto声明无类型的模版参数"><a href="#用auto声明无类型的模版参数" class="headerlink" title="用auto声明无类型的模版参数"></a>用auto声明无类型的模版参数</h2><hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">emplate &lt;<span class="keyword">auto</span> ... seq&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_integer_sequence</span> &#123;</span></span><br><span class="line">  <span class="comment">// Implementation here ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Explicitly pass type `int` as template argument.</span></span><br><span class="line"><span class="keyword">auto</span> seq = <span class="built_in">std</span>::integer_sequence&lt;<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&gt;();</span><br><span class="line"><span class="comment">// Type is deduced to be `int`.</span></span><br><span class="line"><span class="keyword">auto</span> seq2 = my_integer_sequence&lt;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&gt;();</span><br></pre></td></tr></table></figure>
<h2 id="Folding表达式"><a href="#Folding表达式" class="headerlink" title="Folding表达式"></a>Folding表达式</h2><hr>
<p>一个folding表达式执行一个封装了对模版参数二元操作的折叠。</p>
<ul>
<li><p>一个类似(… op expr)或(expr op …)这样形式的表达式，其中op为fold操作符，expr为未展开的参数包裹，这样的形式叫一元折叠(unary fold)。</p>
</li>
<li><p>一个类似(expr1 op … op expr2)这样形式的表达式，其中op为fold操作符，叫二元折叠(binary fold)。expr1和expr2都是未展开的参数包裹，但也可能不都是未展开的。</p>
</li>
</ul>
<p>二元折叠:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">logicalAnd</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Binary folding.</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="literal">true</span> &amp;&amp; ... &amp;&amp; args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> b = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">bool</span>&amp; b2 = b;</span><br><span class="line">logicalAnd(b, b2, <span class="literal">true</span>); <span class="comment">// == true</span></span><br></pre></td></tr></table></figure>
<p>一元折叠:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Unary folding.</span></span><br><span class="line">    <span class="keyword">return</span> (... + args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="number">1.0</span>, <span class="number">2.0f</span>, <span class="number">3</span>); <span class="comment">// == 6.0</span></span><br></pre></td></tr></table></figure>
<h2 id="在花括号初始化列表中的auto推导的新规则"><a href="#在花括号初始化列表中的auto推导的新规则" class="headerlink" title="在花括号初始化列表中的auto推导的新规则"></a>在花括号初始化列表中的auto推导的新规则</h2><hr>
<p>改变了当采用统一初始化语法auto的推导规则。原来，auto x{3}被推导为std::initializer_list<int>类型，现在变为直接推导为int类型</int></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x1&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;; <span class="comment">// error: not a single element</span></span><br><span class="line"><span class="keyword">auto</span> x2 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;; <span class="comment">// decltype(x2) is std::initializer_list&lt;int&gt;</span></span><br><span class="line"><span class="keyword">auto</span> x3&#123; <span class="number">3</span> &#125;; <span class="comment">// decltype(x3) is int</span></span><br><span class="line"><span class="keyword">auto</span> x4&#123; <span class="number">3.0</span> &#125;; <span class="comment">// decltype(x4) is double</span></span><br></pre></td></tr></table></figure>
<h2 id="constexpr的lambda表达式"><a href="#constexpr的lambda表达式" class="headerlink" title="constexpr的lambda表达式"></a>constexpr的lambda表达式</h2><hr>
<p>使用constexpr构造编译时lambda表达式:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> identity = [] (<span class="keyword">int</span> n) <span class="keyword">constexpr</span> &#123; <span class="keyword">return</span> n; &#125;;</span><br><span class="line"><span class="keyword">static_assert</span>(identity(<span class="number">123</span>) == <span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> add = [] (<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;</span><br><span class="line">  <span class="keyword">auto</span> L = [=] &#123; <span class="keyword">return</span> x; &#125;;</span><br><span class="line">  <span class="keyword">auto</span> R = [=] &#123; <span class="keyword">return</span> y; &#125;;</span><br><span class="line">  <span class="keyword">return</span> [=] &#123; <span class="keyword">return</span> L() + R(); &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static_assert</span>(add(<span class="number">1</span>, <span class="number">2</span>)() == <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">addOne</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [n] &#123; <span class="keyword">return</span> n + <span class="number">1</span>; &#125;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static_assert</span>(addOne(<span class="number">1</span>) == <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<h2 id="lambda以值方式捕获this指针"><a href="#lambda以值方式捕获this指针" class="headerlink" title="lambda以值方式捕获this指针"></a>lambda以值方式捕获this指针</h2><hr>
<p>之前的C++标准只能以引用的方式捕获this指针，现在可以以值来捕获了。因为以前在使用callback函数的异步代码中，必须要求一个合法对象，万一对象超过其生命周期，那么程序就挂了。所以在C++17中*this是对当前的对象拷贝了一个副本，而this还是类似C++11的标准一样以引用捕获:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyObj</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> value&#123; <span class="number">123</span> &#125;;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">getValueCopy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [*<span class="keyword">this</span>] &#123; <span class="keyword">return</span> value; &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">getValueRef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> value; &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyObj mo;</span><br><span class="line"><span class="keyword">auto</span> valueCopy = mo.getValueCopy();</span><br><span class="line"><span class="keyword">auto</span> valueRef = mo.getValueRef();</span><br><span class="line">mo.value = <span class="number">321</span>;</span><br><span class="line">valueCopy(); <span class="comment">// 123</span></span><br><span class="line">valueRef(); <span class="comment">// 321</span></span><br></pre></td></tr></table></figure>
<h2 id="内联变量"><a href="#内联变量" class="headerlink" title="内联变量"></a>内联变量</h2><hr>
<p>在该标准中，inline关键字既能作用于函数也能作用于变量了，作用于变量和作用于函数的语义都是一样的。使用场景嘛，都是为了提高性能。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Disassembly example using compiler explorer.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span> <span class="keyword">int</span> x; &#125;;</span><br><span class="line"><span class="keyword">inline</span> S x1 = S&#123;<span class="number">321</span>&#125;; <span class="comment">// mov esi, dword ptr [x1]</span></span><br><span class="line">                      <span class="comment">// x1: .long 321</span></span><br><span class="line"></span><br><span class="line">S x2 = S&#123;<span class="number">123</span>&#125;;        <span class="comment">// mov eax, dword ptr [.L_ZZ4mainE2x2]</span></span><br><span class="line">                      <span class="comment">// mov dword ptr [rbp - 8], eax</span></span><br><span class="line">                      <span class="comment">// .L_ZZ4mainE2x2: .long 123</span></span><br></pre></td></tr></table></figure>
<h2 id="嵌套namespace"><a href="#嵌套namespace" class="headerlink" title="嵌套namespace"></a>嵌套namespace</h2><hr>
<p>这个不必多说，主要是书写代码更简洁了:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ 11</span></span><br><span class="line"><span class="keyword">namespace</span> A &#123;</span><br><span class="line">  <span class="keyword">namespace</span> B &#123;</span><br><span class="line">    <span class="keyword">namespace</span> C &#123;</span><br><span class="line">      <span class="keyword">int</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++ 17</span></span><br><span class="line"><span class="keyword">namespace</span> A::B::C &#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Structured-bindings"><a href="#Structured-bindings" class="headerlink" title="Structured bindings"></a>Structured bindings</h2><hr>
<p>其实这个特性Python里面也有类似的。这个标准提案的目的是解构初始化，它是这样使用的： auto [x,y,z] = expr。 expr作为一个表达式，它需要返回tuple-like的对象，这个对象的元素必须与x，y，z进行绑定。tuple-like的对象包括std::tuple, std::pair , std::array和聚合结构体。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Coordinate = <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="function">Coordinate <span class="title">origin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Coordinate&#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> [ x, y ] = origin();</span><br><span class="line">x; <span class="comment">// == 0</span></span><br><span class="line">y; <span class="comment">// == 0</span></span><br></pre></td></tr></table></figure>
<h2 id="constexpr-if"><a href="#constexpr-if" class="headerlink" title="constexpr if"></a>constexpr if</h2><hr>
<p>这个特性还是相当有用的，让代码实例化依赖于编译时的条件。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="title">isIntegral</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="built_in">std</span>::is_integral&lt;T&gt;::value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static_assert</span>(isIntegral&lt;<span class="keyword">int</span>&gt;() == <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">static_assert</span>(isIntegral&lt;<span class="keyword">char</span>&gt;() == <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">static_assert</span>(isIntegral&lt;<span class="keyword">double</span>&gt;() == <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span>&#125;;</span><br><span class="line"><span class="keyword">static_assert</span>(isIntegral&lt;S&gt;() == <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<h2 id="UTF-8字符字面量"><a href="#UTF-8字符字面量" class="headerlink" title="UTF-8字符字面量"></a>UTF-8字符字面量</h2><hr>
<p>UTF-8终于被纳入标准了:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> x = u8'x'; <span class="comment">//被编码为UTF-8</span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://alexiachen.github.io/blog/2017/08/31/explore-cpp17/" data-id="cjtctj24t008ilbqfagp9y7fk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/C-C/">C/C++</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/blog/2017/09/10/about-im/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          有关于即时通讯的开发
        
      </div>
    </a>
  
  
    <a href="/blog/2017/08/21/cert-cpp-ten/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">CERT C++ 编码规范翻译（MSC）</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/blog/tags/Bloom-Filter/" style="font-size: 10px;">Bloom Filter</a> <a href="/blog/tags/C-C/" style="font-size: 20px;">C/C++</a> <a href="/blog/tags/CERT/" style="font-size: 18.33px;">CERT</a> <a href="/blog/tags/CMake/" style="font-size: 10px;">CMake</a> <a href="/blog/tags/DLL/" style="font-size: 10px;">DLL</a> <a href="/blog/tags/DNS/" style="font-size: 10px;">DNS</a> <a href="/blog/tags/IM/" style="font-size: 13.33px;">IM</a> <a href="/blog/tags/IO/" style="font-size: 10px;">IO</a> <a href="/blog/tags/Java/" style="font-size: 10px;">Java</a> <a href="/blog/tags/Linux/" style="font-size: 13.33px;">Linux</a> <a href="/blog/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/blog/tags/Oracle/" style="font-size: 10px;">Oracle</a> <a href="/blog/tags/Qos/" style="font-size: 11.67px;">Qos</a> <a href="/blog/tags/RFB协议/" style="font-size: 10px;">RFB协议</a> <a href="/blog/tags/SQLite/" style="font-size: 10px;">SQLite</a> <a href="/blog/tags/Scala/" style="font-size: 10px;">Scala</a> <a href="/blog/tags/TCP-IP/" style="font-size: 10px;">TCP/IP</a> <a href="/blog/tags/VNC协议/" style="font-size: 10px;">VNC协议</a> <a href="/blog/tags/Visual-Studio/" style="font-size: 10px;">Visual Studio</a> <a href="/blog/tags/Win32/" style="font-size: 13.33px;">Win32</a> <a href="/blog/tags/Y组合子/" style="font-size: 10px;">Y组合子</a> <a href="/blog/tags/bat/" style="font-size: 10px;">bat</a> <a href="/blog/tags/ioccc/" style="font-size: 10px;">ioccc</a> <a href="/blog/tags/lambda演算/" style="font-size: 10px;">lambda演算</a> <a href="/blog/tags/windows/" style="font-size: 11.67px;">windows</a> <a href="/blog/tags/上下文无关文法/" style="font-size: 10px;">上下文无关文法</a> <a href="/blog/tags/事业/" style="font-size: 10px;">事业</a> <a href="/blog/tags/互联网/" style="font-size: 10px;">互联网</a> <a href="/blog/tags/人生/" style="font-size: 10px;">人生</a> <a href="/blog/tags/传统行业/" style="font-size: 10px;">传统行业</a> <a href="/blog/tags/信息安全/" style="font-size: 10px;">信息安全</a> <a href="/blog/tags/内存模型/" style="font-size: 10px;">内存模型</a> <a href="/blog/tags/函数式编程/" style="font-size: 11.67px;">函数式编程</a> <a href="/blog/tags/单例模式/" style="font-size: 10px;">单例模式</a> <a href="/blog/tags/双向链表/" style="font-size: 10px;">双向链表</a> <a href="/blog/tags/可计算性/" style="font-size: 10px;">可计算性</a> <a href="/blog/tags/同步异步/" style="font-size: 10px;">同步异步</a> <a href="/blog/tags/团队管理/" style="font-size: 11.67px;">团队管理</a> <a href="/blog/tags/多核编程/" style="font-size: 10px;">多核编程</a> <a href="/blog/tags/多线程编程/" style="font-size: 10px;">多线程编程</a> <a href="/blog/tags/天体物理/" style="font-size: 10px;">天体物理</a> <a href="/blog/tags/套路/" style="font-size: 10px;">套路</a> <a href="/blog/tags/学术/" style="font-size: 10px;">学术</a> <a href="/blog/tags/宇宙学/" style="font-size: 10px;">宇宙学</a> <a href="/blog/tags/性能优化/" style="font-size: 10px;">性能优化</a> <a href="/blog/tags/技术/" style="font-size: 10px;">技术</a> <a href="/blog/tags/指令重排序/" style="font-size: 10px;">指令重排序</a> <a href="/blog/tags/操作系统/" style="font-size: 10px;">操作系统</a> <a href="/blog/tags/敏捷开发/" style="font-size: 10px;">敏捷开发</a> <a href="/blog/tags/数据压缩/" style="font-size: 10px;">数据压缩</a> <a href="/blog/tags/数据库/" style="font-size: 10px;">数据库</a> <a href="/blog/tags/数据恢复/" style="font-size: 10px;">数据恢复</a> <a href="/blog/tags/数据结构与算法/" style="font-size: 11.67px;">数据结构与算法</a> <a href="/blog/tags/旅行/" style="font-size: 10px;">旅行</a> <a href="/blog/tags/无线网卡/" style="font-size: 10px;">无线网卡</a> <a href="/blog/tags/有限自动机/" style="font-size: 10px;">有限自动机</a> <a href="/blog/tags/构建工具/" style="font-size: 10px;">构建工具</a> <a href="/blog/tags/模板元编程/" style="font-size: 10px;">模板元编程</a> <a href="/blog/tags/民主/" style="font-size: 11.67px;">民主</a> <a href="/blog/tags/汇编语言/" style="font-size: 10px;">汇编语言</a> <a href="/blog/tags/消息推送/" style="font-size: 10px;">消息推送</a> <a href="/blog/tags/混乱代码/" style="font-size: 10px;">混乱代码</a> <a href="/blog/tags/物联网/" style="font-size: 10px;">物联网</a> <a href="/blog/tags/猎人/" style="font-size: 10px;">猎人</a> <a href="/blog/tags/理想/" style="font-size: 10px;">理想</a> <a href="/blog/tags/理论计算机/" style="font-size: 10px;">理论计算机</a> <a href="/blog/tags/生活/" style="font-size: 13.33px;">生活</a> <a href="/blog/tags/研究/" style="font-size: 10px;">研究</a> <a href="/blog/tags/程序语言理论/" style="font-size: 15px;">程序语言理论</a> <a href="/blog/tags/类型系统/" style="font-size: 10px;">类型系统</a> <a href="/blog/tags/线程/" style="font-size: 10px;">线程</a> <a href="/blog/tags/线程安全/" style="font-size: 10px;">线程安全</a> <a href="/blog/tags/缓存/" style="font-size: 10px;">缓存</a> <a href="/blog/tags/编程范式/" style="font-size: 10px;">编程范式</a> <a href="/blog/tags/编程语言/" style="font-size: 10px;">编程语言</a> <a href="/blog/tags/编译原理/" style="font-size: 11.67px;">编译原理</a> <a href="/blog/tags/美国/" style="font-size: 10px;">美国</a> <a href="/blog/tags/职业生涯/" style="font-size: 10px;">职业生涯</a> <a href="/blog/tags/自然语言处理/" style="font-size: 10px;">自然语言处理</a> <a href="/blog/tags/自由/" style="font-size: 11.67px;">自由</a> <a href="/blog/tags/英语/" style="font-size: 10px;">英语</a> <a href="/blog/tags/装修/" style="font-size: 10px;">装修</a> <a href="/blog/tags/计算机体系结构/" style="font-size: 10px;">计算机体系结构</a> <a href="/blog/tags/计算机科学/" style="font-size: 10px;">计算机科学</a> <a href="/blog/tags/计算机网络/" style="font-size: 11.67px;">计算机网络</a> <a href="/blog/tags/计算理论/" style="font-size: 11.67px;">计算理论</a> <a href="/blog/tags/词法分析/" style="font-size: 10px;">词法分析</a> <a href="/blog/tags/诗歌/" style="font-size: 10px;">诗歌</a> <a href="/blog/tags/语义学/" style="font-size: 10px;">语义学</a> <a href="/blog/tags/调试/" style="font-size: 11.67px;">调试</a> <a href="/blog/tags/软件工程/" style="font-size: 16.67px;">软件工程</a> <a href="/blog/tags/软件开发/" style="font-size: 10px;">软件开发</a> <a href="/blog/tags/软件调试/" style="font-size: 10px;">软件调试</a> <a href="/blog/tags/远程桌面/" style="font-size: 10px;">远程桌面</a> <a href="/blog/tags/逻辑/" style="font-size: 11.67px;">逻辑</a> <a href="/blog/tags/重构/" style="font-size: 10px;">重构</a> <a href="/blog/tags/错误处理/" style="font-size: 10px;">错误处理</a> <a href="/blog/tags/闭包/" style="font-size: 10px;">闭包</a> <a href="/blog/tags/阻塞非阻塞/" style="font-size: 10px;">阻塞非阻塞</a> <a href="/blog/tags/项目管理/" style="font-size: 11.67px;">项目管理</a> <a href="/blog/tags/马尔科夫链/" style="font-size: 10px;">马尔科夫链</a> <a href="/blog/tags/驱动开发/" style="font-size: 10px;">驱动开发</a> <a href="/blog/tags/黑洞/" style="font-size: 10px;">黑洞</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/02/">February 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/01/">January 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2015/11/">November 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2014/11/">November 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2014/09/">September 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2014/08/">August 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2014/07/">July 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2014/06/">June 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2014/05/">May 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2014/03/">March 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2014/02/">February 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2013/07/">July 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2013/06/">June 2013</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2019/03/17/bloom-filter/">实现一个简单的高性能布隆过滤器</a>
          </li>
        
          <li>
            <a href="/blog/2019/03/10/auto-complete-markov-chain/">用马尔科夫链来做自动补全</a>
          </li>
        
          <li>
            <a href="/blog/2018/12/15/manjaro-rtl8821ce/">manjaro下安装配置无线网卡驱动</a>
          </li>
        
          <li>
            <a href="/blog/2018/11/11/cpp-closure/">C++的闭包</a>
          </li>
        
          <li>
            <a href="/blog/2018/10/15/finite-automaton/">最简单的计算机之有限自动机</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 MathxH Chen<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/blog/" class="mobile-nav-link">Home</a>
  
    <a href="/blog/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/blog/about" class="mobile-nav-link">About</a>
  
    <a href="/blog/resume" class="mobile-nav-link">Resume</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">
  <script src="/blog/fancybox/jquery.fancybox.pack.js"></script>


<script src="/blog/js/script.js"></script>



  </div>
</body>
</html>