<html>
<head><meta name="generator" content="Hexo 3.8.0">
	
	<title>CERT C++ 编码规范翻译（CON）</title>
	<meta name="keywords" content="MathxH Blog">

    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    
	   <link href="/blog/css/main.css?v=3" rel="stylesheet" type="text/css">
    
        <script src="/blog/js/util.js"></script>
        <script>
            if(isMobile()) {
                loadjscssfile('../css/mobile.css', 'css');
            } else {
                loadjscssfile('../css/desktop.css', 'css');
            }
        </script> 
    

    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">

    
	<link rel="shortcut icon" type="image/x-icon" href="/blog/favicon.ico?v=3">
    
    

</head>

<body>


<h2 class="title">CERT C++ 编码规范翻译（CON）</h2>
<!---
<div style="text-align:center;margin-top: -10px;">
<div class="article-category">
发表于2017年8月16日




 </div>
--->


<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#并发编程"><span class="toc-text">并发编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CON50-CPP-当mutex被上锁的时候不要销毁mutex"><span class="toc-text">CON50-CPP. 当mutex被上锁的时候不要销毁mutex</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#代码样例对比"><span class="toc-text">代码样例对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CON51-CPP-确保持有锁的线程在遇到异常的时候及时释放锁"><span class="toc-text">CON51-CPP. 确保持有锁的线程在遇到异常的时候及时释放锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#代码样例对比-1"><span class="toc-text">代码样例对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CON52-CPP-在多线程访问bit-fields的时候防止数据竞争"><span class="toc-text">CON52-CPP. 在多线程访问bit-fields的时候防止数据竞争</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#代码样例对比-2"><span class="toc-text">代码样例对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CON53-CPP-通过预先定义的顺序来加锁以避免出现死锁"><span class="toc-text">CON53-CPP. 通过预先定义的顺序来加锁以避免出现死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#代码样例对比-3"><span class="toc-text">代码样例对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CON54-CPP-包装在循环中能伪唤醒的函数"><span class="toc-text">CON54-CPP. 包装在循环中能伪唤醒的函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#代码样例对比-4"><span class="toc-text">代码样例对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CON55-CPP-在使用condition-variable的时候保持线程安全和线程活动-存活"><span class="toc-text">CON55-CPP. 在使用condition variable的时候保持线程安全和线程活动(存活)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#代码样例对比-5"><span class="toc-text">代码样例对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CON56-CPP-在一个已获得锁的调用线程中不要“推测性”地对一个不支持递归的mutex再次上锁"><span class="toc-text">CON56-CPP. 在一个已获得锁的调用线程中不要“推测性”地对一个不支持递归的mutex再次上锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#代码样例对比-6"><span class="toc-text">代码样例对比</span></a></li></ol></li></ol></li></ol>
<h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><h3 id="CON50-CPP-当mutex被上锁的时候不要销毁mutex"><a href="#CON50-CPP-当mutex被上锁的时候不要销毁mutex" class="headerlink" title="CON50-CPP. 当mutex被上锁的时候不要销毁mutex"></a>CON50-CPP. 当mutex被上锁的时候不要销毁mutex</h3><p>严重程度：中等。修复代价也非常高昂。导致不合法的控制流和数据冲撞。</p>
<p>Mutex对象一般是用来在并发访问的时候保护共享数据的。如果一个Mutex对象在线程阻塞等待上锁的时候销毁了，那么临界区和共享数据就再也不受保护了。</p>
<p>C++标准[thread.mutex.class]中有如下声明:</p>
<blockquote>
<p>The behavior of a program is undefined if it destroys a mutex object owned by any thread or a thread terminates while owning a mutex object</p>
</blockquote>
<p>同样，条款说的Mutex对象在C++中包括std::mutex std::recursive_mutex, std::timed_mutex,<br>std::recursive_timed_mutex, and std::shared_timed_mutex。</p>
<h4 id="代码样例对比"><a href="#代码样例对比" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> maxThreads = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_work</span><span class="params">(<span class="keyword">size_t</span> i, <span class="built_in">std</span>::mutex *pm)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lk(*pm);</span><br><span class="line">  <span class="comment">// Access data protected by the lock.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start_threads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::thread threads[maxThreads];</span><br><span class="line">  <span class="built_in">std</span>::mutex m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; maxThreads; ++i) &#123;</span><br><span class="line">    threads[i] = <span class="built_in">std</span>::thread(do_work, i, &amp;m);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码看上去貌似没有问题，但是仔细看，mutex对象m是在start_threads()函数作用域的，可能线程还没有开始，或进行到一半，对象m就随着退出作用域自动销毁了，这时候各个线程再来操作对象m，显然是非法的，直接造成未定义行为。所以可以把对象m存放在全局作用域:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> maxThreads = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">std</span>::mutex m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_work</span><span class="params">(<span class="keyword">size_t</span> i, <span class="built_in">std</span>::mutex *pm)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lk(*pm);</span><br><span class="line">  <span class="comment">// Access data protected by the lock.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start_threads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::thread threads[maxThreads];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; maxThreads; ++i) &#123;</span><br><span class="line">    threads[i] = <span class="built_in">std</span>::thread(do_work, i, &amp;m);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码在线程运行完毕也不会销毁对象m，所以可以放心运行，如果还是想把对象m存放到start_threads的作用域，那么可以让所有线程都join到主线程来等待线程运行完毕再销毁对象m：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> maxThreads = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_work</span><span class="params">(<span class="keyword">size_t</span> i, <span class="built_in">std</span>::mutex *pm)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lk(*pm);</span><br><span class="line">  <span class="comment">// Access data protected by the lock.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start_threads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::thread threads[maxThreads];</span><br><span class="line">  <span class="built_in">std</span>::mutex m;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; maxThreads; ++i) &#123;</span><br><span class="line">    threads[i] = <span class="built_in">std</span>::thread(do_work, i, &amp;m);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; maxThreads; ++i) &#123;</span><br><span class="line">    threads[i].join();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CON51-CPP-确保持有锁的线程在遇到异常的时候及时释放锁"><a href="#CON51-CPP-确保持有锁的线程在遇到异常的时候及时释放锁" class="headerlink" title="CON51-CPP. 确保持有锁的线程在遇到异常的时候及时释放锁"></a>CON51-CPP. 确保持有锁的线程在遇到异常的时候及时释放锁</h3><p>严重程度: 低。一般会导致死锁。</p>
<p>Mutex对象一般通过调用其成员函数lock()上锁和unlock()解锁来保护共享数据，但是，如果一个异常在lock和unlock之间的代码段发生了，因为异常会直接改变中断控制流，这样就导致unlock没有调用，mutex就一直保持locked的状态，当其他线程想进入临界区或保护区段的时候，会一直阻塞等待锁的释放，但是显然已经不可能了，导致死锁。</p>
<p>异常的throw永远不允许一个mutex永远保持上锁的状态。</p>
<p>C++提供了一些lock_guard, unique_lock和shared_lock的RAII类来保证锁跳出作用域的时候及时得到释放。</p>
<h4 id="代码样例对比-1"><a href="#代码样例对比-1" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manipulate_shared_data</span><span class="params">(<span class="built_in">std</span>::mutex &amp;pm)</span> </span>&#123;</span><br><span class="line">  pm.lock();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Perform work on shared data.</span></span><br><span class="line">  <span class="comment">// if exception happens throw and did not call unlock()</span></span><br><span class="line">  pm.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码显然有问题，如果异常发生可能直接造成死锁，应该保证捕获异常，并且释放锁:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manipulate_shared_data</span><span class="params">(<span class="built_in">std</span>::mutex &amp;pm)</span> </span>&#123;</span><br><span class="line">  pm.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// Perform work on shared data.</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">    pm.unlock();</span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  pm.unlock(); <span class="comment">// in case no exceptions occur</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++ 11推荐用RAII的机制来完成这样的方案，最简洁高效，降低了开发者的心智负担:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manipulate_shared_data</span><span class="params">(<span class="built_in">std</span>::mutex &amp;pm)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lk(pm);</span><br><span class="line">  <span class="comment">// Perform work on shared data.</span></span><br><span class="line">  <span class="comment">// if exception happens and throw it , resulting manipulate_shared_data() exit its scope and lk object desctroied and release pm  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CON52-CPP-在多线程访问bit-fields的时候防止数据竞争"><a href="#CON52-CPP-在多线程访问bit-fields的时候防止数据竞争" class="headerlink" title="CON52-CPP. 在多线程访问bit-fields的时候防止数据竞争"></a>CON52-CPP. 在多线程访问bit-fields的时候防止数据竞争</h3><p>严重程度: 中等。尽管竞争的区域窗口(粒度)比较小，但是赋值和表达式的计算可能会由于数据的错误解释导致程序运行在一个未知的状态。</p>
<p>当访问一个bit-field，线程会无心的分开访问邻近内存的bit-field。这是由于编译器总是要求临近的不同bit-field存储在一个存储单元中（字节）,结果就导致了相邻bit-field还是会出现数据竞争的问题，还是必须用锁来保护。这样的错误很难发现。</p>
<h4 id="代码样例对比-2"><a href="#代码样例对比-2" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MultiThreadedFlags</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> flag1 : <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> flag2 : <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MultiThreadedFlags flags;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  flags.flag1 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  flags.flag2 = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码显然有问题，flag1和flag2因为是bit-filed的表达，所以这两个存储区域可能是放在同一个内存地址的存储单元中，如果多线程访问不加锁保护，那么会导致未定义行为。所以需要加锁:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MultiThreadedFlags</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> flag1 : <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> flag2 : <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MtfMutex</span> &#123;</span></span><br><span class="line">  MultiThreadedFlags s;</span><br><span class="line">  <span class="built_in">std</span>::mutex mutex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MtfMutex flags;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lk(flags.mutex);</span><br><span class="line">  flags.s.flag1 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lk(flags.mutex);</span><br><span class="line">  flags.s.flag2 = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码用mutex对象来保护每一个MultiThreadFlags类型的对象。注意不能把mutex放到全局空间，这样就是保护范围就扩大了，没有意义，因为不同MultiThreadFlags类型的对象是没有任何关联的。当然如果不用bit-field来存储信息，以下代码就不用加锁了，因为不同的存储变量肯定是存储在不同的内存单元中（C++ 11）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MultiThreadedFlags</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> flag1;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> flag2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MultiThreadedFlags flags;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  flags.flag1 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  flags.flag2 = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码必须用支持C++ 11的编译器才有效果，因为C++标准[intro.memory]显式定义了内存地址：</p>
<blockquote>
<p>[Note: Thus a bit-field and an adjacent non-bit-field are in separate memory locations, and therefore can be concurrently updated by two threads of execution without interference. The same applies to two bit-fields, if one is declared inside a nested struct declaration and the other is not, or if the two are separated by a zero-length bit-field declaration, or if they are separated by a non-bit-field declaration. It is not safe to concurrently update two bit-fields in the same struct if all fields between them are also bit-fields of non-zero width. – end note ]</p>
</blockquote>
<h3 id="CON53-CPP-通过预先定义的顺序来加锁以避免出现死锁"><a href="#CON53-CPP-通过预先定义的顺序来加锁以避免出现死锁" class="headerlink" title="CON53-CPP. 通过预先定义的顺序来加锁以避免出现死锁"></a>CON53-CPP. 通过预先定义的顺序来加锁以避免出现死锁</h3><p>严重程度： 低。 死锁一般会造成程序僵死，然后被攻击者构造死锁条件导致服务拒绝攻击。</p>
<p>这段没什么可说的，死锁必须得避免是必须的。</p>
<h4 id="代码样例对比-3"><a href="#代码样例对比-3" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BankAccount</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> balance;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">std</span>::mutex balanceMutex;</span><br><span class="line">  BankAccount() = <span class="keyword">delete</span>;</span><br><span class="line">  explicit BankAccount(int initialAmount) : balance(initialAmount)&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">get_balance</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> balance; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set_balance</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>&#123; balance = amount; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deposit</span><span class="params">(BankAccount *from, BankAccount *to, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; from_lock(from-&gt;balanceMutex);</span><br><span class="line">  <span class="comment">// Not enough balance to transfer.</span></span><br><span class="line">  <span class="keyword">if</span> (from-&gt;get_balance() &lt; amount) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// Indicate error</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; to_lock(to-&gt;balanceMutex);</span><br><span class="line">  from-&gt;set_balance(from-&gt;get_balance() – amount);</span><br><span class="line">  to-&gt;set_balance(to-&gt;get_balance() + amount);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(BankAccount *ba1, BankAccount *ba2)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Perform the deposits.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">thr1</span><span class="params">(deposit, ba1, ba2, <span class="number">100</span>)</span></span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">thr2</span><span class="params">(deposit, ba2, ba1, <span class="number">100</span>)</span></span>;</span><br><span class="line">  thr1.join();</span><br><span class="line">  thr2.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码由于银行账户互相转账，但是加锁的顺序不一致，导致可能有死锁隐患。可以手动调整加锁顺序来消除:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BankAccount</span> &#123;</span></span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">std</span>::atomic&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; globalId;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> id;</span><br><span class="line">  <span class="keyword">int</span> balance;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">std</span>::mutex balanceMutex;</span><br><span class="line">  BankAccount() = <span class="keyword">delete</span>;</span><br><span class="line">  explicit BankAccount(int initialAmount) : id(globalId++), balance(initialAmount) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">get_id</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> id; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">get_balance</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> balance; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set_balance</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>&#123; balance = amount; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; BankAccount::globalId(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deposit</span><span class="params">(BankAccount *from, BankAccount *to, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::mutex *first;</span><br><span class="line">  <span class="built_in">std</span>::mutex *second;</span><br><span class="line">  <span class="keyword">if</span> (from-&gt;get_id() == to-&gt;get_id()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// Indicate error</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Ensure proper ordering for locking.</span></span><br><span class="line">  <span class="keyword">if</span> (from-&gt;get_id() &lt; to-&gt;get_id()) &#123;</span><br><span class="line">    first = &amp;from-&gt;balanceMutex;</span><br><span class="line">    second = &amp;to-&gt;balanceMutex;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    first = &amp;to-&gt;balanceMutex;</span><br><span class="line">    second = &amp;from-&gt;balanceMutex;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; firstLock(*first);</span><br><span class="line">  <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; secondLock(*second);</span><br><span class="line">  <span class="comment">// Check for enough balance to transfer.</span></span><br><span class="line">  <span class="keyword">if</span> (from-&gt;get_balance() &gt;= amount) &#123;</span><br><span class="line">    from-&gt;set_balance(from-&gt;get_balance() – amount);</span><br><span class="line">    to-&gt;set_balance(to-&gt;get_balance() + amount);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(BankAccount *ba1, BankAccount *ba2)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Perform the deposits.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">thr1</span><span class="params">(deposit, ba1, ba2, <span class="number">100</span>)</span></span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">thr2</span><span class="params">(deposit, ba2, ba1, <span class="number">100</span>)</span></span>;</span><br><span class="line">  thr1.join();</span><br><span class="line">  thr2.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者用STL提供了std::lock同时锁住多个锁对象来避免死锁:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BankAccount</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> balance;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">std</span>::mutex balanceMutex;</span><br><span class="line">  BankAccount() = <span class="keyword">delete</span>;</span><br><span class="line">  explicit BankAccount(int initialAmount) :</span><br><span class="line">  balance(initialAmount) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">get_balance</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> balance; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set_balance</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>&#123; balance = amount; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deposit</span><span class="params">(BankAccount *from, BankAccount *to, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Create lock objects but defer locking them until later.</span></span><br><span class="line">  <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lk1(from-&gt;balanceMutex, <span class="built_in">std</span>::defer_lock);</span><br><span class="line">  <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lk2(to-&gt;balanceMutex, <span class="built_in">std</span>::defer_lock);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Lock both of the lock objects simultaneously.</span></span><br><span class="line">  <span class="built_in">std</span>::lock(lk1, lk2);</span><br><span class="line">  <span class="keyword">if</span> (from-&gt;get_balance() &gt;= amount) &#123;</span><br><span class="line">    from-&gt;set_balance(from-&gt;get_balance() – amount);</span><br><span class="line">    to-&gt;set_balance(to-&gt;get_balance() + amount);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(BankAccount *ba1, BankAccount *ba2)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Perform the deposits.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">thr1</span><span class="params">(deposit, ba1, ba2, <span class="number">100</span>)</span></span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">thr2</span><span class="params">(deposit, ba2, ba1, <span class="number">100</span>)</span></span>;</span><br><span class="line">  thr1.join();</span><br><span class="line">  thr2.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CON54-CPP-包装在循环中能伪唤醒的函数"><a href="#CON54-CPP-包装在循环中能伪唤醒的函数" class="headerlink" title="CON54-CPP. 包装在循环中能伪唤醒的函数"></a>CON54-CPP. 包装在循环中能伪唤醒的函数</h3><p>严重程度： 低。如果在循环中对wait(), wait_for(), 或 wait_until()的调用包装不合理就会导致无限阻塞和服务拒绝攻击。</p>
<p>std::condition_variable类成员函数 wait(), wait_for()和wait_until()会临时放弃mutex对象的拥有权。然后其他线程就可以继续处理这个mutex对象了。这些函数必须总是被mutex保护区域的代码调用，只有等到被其他线程调用notify_one()或notify_all() 成员函数，线程才会继续执行。</p>
<p>比如像下面使用:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">bool</span> <span class="title">until_finish</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">std</span>::mutex m;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">std</span>::condition_variable condition;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lk(m);</span><br><span class="line">  <span class="keyword">while</span> (until_finish()) &#123; <span class="comment">// Predicate does not hold.</span></span><br><span class="line">    condition.wait(lk);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Resume when condition holds.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码样例对比-4"><a href="#代码样例对比-4" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *node;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Node <span class="built_in">list</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::mutex m;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::condition_variable condition;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consume_list_element</span><span class="params">(<span class="built_in">std</span>::condition_variable &amp;condition)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lk(m);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">list</span>.next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    condition.wait(lk);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Proceed when condition holds.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码是等到链表非空的时候再消费链表，用法用错了，必须把wait()的调用包装在循环中:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *node;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Node <span class="built_in">list</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::mutex m;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::condition_variable condition;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consume_list_element</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lk(m);</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">list</span>.next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    condition.wait(lk);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Proceed when condition holds.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然以下还有使用lambda表达式的隐含循环来使代码更简洁:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *node;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Node <span class="built_in">list</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::mutex m;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::condition_variable condition;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consume_list_element</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lk(m);</span><br><span class="line">  condition.wait(lk, []&#123; <span class="keyword">return</span> <span class="built_in">list</span>.next; &#125;);</span><br><span class="line">  <span class="comment">// Proceed when condition holds.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码wait()实现使用了 while (!wait_condition()) wait(lock);的方式来进行等到，本质上也要用到循环。</p>
<h3 id="CON55-CPP-在使用condition-variable的时候保持线程安全和线程活动-存活"><a href="#CON55-CPP-在使用condition-variable的时候保持线程安全和线程活动-存活" class="headerlink" title="CON55-CPP. 在使用condition variable的时候保持线程安全和线程活动(存活)"></a>CON55-CPP. 在使用condition variable的时候保持线程安全和线程活动(存活)</h3><p>严重程度： 低。不遵守条款一般是导致无限阻塞或者服务拒绝攻击。</p>
<p>线程存活一般来说就是保证不死锁。</p>
<p>condition variable一定要在while循环中使用(遵守CON54-CPP规范)。为了保证存活，程序需要在调用wait()成员函数之前用while循环的条件来测试等待条件。直到notify_all或者notify_one被其他线程调用，wait()被唤醒，再次检测条件谓词，决定是否继续等待。</p>
<p>notify_one()成员函数一般会解除阻塞与特定条件变量的其中一个线程。如果多个线程都等待同一个条件变量，那么调度器就选择其中任意一个线程将其唤醒（假设所有等待中的线程都处于相同的优先级）。</p>
<p>notify_all()成员函数一般会解除阻塞于特定条件变量的所有线程，当然，解除后，等待中的线程的开始执行顺序是未指定的。</p>
<p>对于以上所描述的原因，所以线程必须在wait()函数后就检查条件谓词。while循环就是在wait()函数调用前后检查条件谓词的最好选择。</p>
<p>在多线程中，如果每一个线程都使用属于自己的一个唯一的条件变量，那么notify_one()的使用是安全的。如果多线程共享一个条件变量，那么只有满足以下两个条款，notify_one()的使用才是安全的：</p>
<ul>
<li><p>所有的线程在唤醒之后必须执行相同的操作集合，因为对于一次notify_one()的调用只能唤醒其中一个等待在条件变量上的线程</p>
</li>
<li><p>只有一个线程才能接收到notify_one()的信号被唤醒</p>
</li>
</ul>
<p>notify_all()函数一般是对于notify_one()的使用不安全的时候用的，它可以唤醒所有阻塞在特定条件变量上的线程。</p>
<h4 id="代码样例对比-5"><a href="#代码样例对比-5" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::mutex mutex;</span><br><span class="line"><span class="built_in">std</span>::condition_variable cond;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run_step</span><span class="params">(<span class="keyword">size_t</span> myStep)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">size_t</span> currentStep = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lk(mutex);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread "</span> &lt;&lt; myStep &lt;&lt; <span class="string">" has the lock"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> (currentStep != myStep) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread "</span> &lt;&lt; myStep &lt;&lt; <span class="string">" is sleeping..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    cond.wait(lk);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread "</span> &lt;&lt; myStep &lt;&lt; <span class="string">" woke up"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Do processing...</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread "</span> &lt;&lt; myStep &lt;&lt; <span class="string">" is processing..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  currentStep++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Signal awaiting task.</span></span><br><span class="line">  cond.notify_one();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread "</span> &lt;&lt; myStep &lt;&lt; <span class="string">" is exiting..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">size_t</span> numThreads = <span class="number">5</span>;</span><br><span class="line">  <span class="built_in">std</span>::thread threads[numThreads];</span><br><span class="line">  <span class="comment">// Create threads.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; numThreads; ++i) &#123;</span><br><span class="line">    threads[i] = <span class="built_in">std</span>::thread(run_step, i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Wait for all threads to complete.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = numThreads; i != <span class="number">0</span>; --i) &#123;</span><br><span class="line">    threads[i - <span class="number">1</span>].join();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码显然是创建多个线程然后通过一个共享局部静态变量currentStep串行化处理，每一个线程处理完成自己的工作就对currentStep加1。而且代码中的wait()也用while循环包装了，遵循CON54-CPP规范。那么错在哪里了呢？错就错在代码是用notify_one()，试想以下，最开始的时候，所有线程依次开始执行，必然有其中一个线程，也就是myStep为0的线程不会阻塞，其他线程都阻塞在条件变量上了，因为没有到自己执行。然而，myStep为0的线程调用了notify_one()，仅仅只唤醒了其中一个线程，如果是恰好唤醒了myStep为1的线程那还好，线程可以如愿被唤醒，如果是唤醒了myStep &gt; 1 的线程那么那个线程还是因为条件不满足而继续等待，又会被阻塞，那么这时候完蛋了，所有线程都被阻塞住了，没有活动线程了，线程都不会被唤醒，那么整个程序就死锁了，无限阻塞。所以需要把notify_one替换成notify_all：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::mutex mutex;</span><br><span class="line"><span class="built_in">std</span>::condition_variable cond;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run_step</span><span class="params">(<span class="keyword">size_t</span> myStep)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">size_t</span> currentStep = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lk(mutex);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread "</span> &lt;&lt; myStep &lt;&lt; <span class="string">" has the lock"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> (currentStep != myStep) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread "</span> &lt;&lt; myStep &lt;&lt; <span class="string">" is sleeping..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    cond.wait(lk);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread "</span> &lt;&lt; myStep &lt;&lt; <span class="string">" woke up"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Do processing...</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread "</span> &lt;&lt; myStep &lt;&lt; <span class="string">" is processing..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  currentStep++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Signal awaiting task.</span></span><br><span class="line">  cond.notify_all();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread "</span> &lt;&lt; myStep &lt;&lt; <span class="string">" is exiting..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">size_t</span> numThreads = <span class="number">5</span>;</span><br><span class="line">  <span class="built_in">std</span>::thread threads[numThreads];</span><br><span class="line">  <span class="comment">// Create threads.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; numThreads; ++i) &#123;</span><br><span class="line">    threads[i] = <span class="built_in">std</span>::thread(run_step, i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Wait for all threads to complete.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = numThreads; i != <span class="number">0</span>; --i) &#123;</span><br><span class="line">    threads[i - <span class="number">1</span>].join();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码唤醒了所有等待在条件变量的线程，那么必然有其中一个线程满足条件，并唤醒剩下等待在条件变量下的线程，保证线程能依次执行。</p>
<p>如果开发者还是想使用notify_one()，那么有一个解决方案就是每个线程只用一个属于自己的唯一的条件变量:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">size_t</span> numThreads = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">std</span>::mutex mutex;</span><br><span class="line"><span class="built_in">std</span>::condition_variable cond[numThreads];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run_step</span><span class="params">(<span class="keyword">size_t</span> myStep)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">size_t</span> currentStep = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lk(mutex);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread "</span> &lt;&lt; myStep &lt;&lt; <span class="string">" has the lock"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> (currentStep != myStep) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread "</span> &lt;&lt; myStep &lt;&lt; <span class="string">" is sleeping..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    cond[myStep].wait(lk);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread "</span> &lt;&lt; myStep &lt;&lt; <span class="string">" woke up"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Do processing ...</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread "</span> &lt;&lt; myStep &lt;&lt; <span class="string">" is processing..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  currentStep++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Signal next step thread.</span></span><br><span class="line">  <span class="keyword">if</span> ((myStep + <span class="number">1</span>) &lt; numThreads) &#123;</span><br><span class="line">    cond[myStep + <span class="number">1</span>].notify_one();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread "</span> &lt;&lt; myStep &lt;&lt; <span class="string">" is exiting..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">size_t</span> numThreads = <span class="number">5</span>;</span><br><span class="line">  <span class="built_in">std</span>::thread threads[numThreads];</span><br><span class="line">  <span class="comment">// Create threads.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; numThreads; ++i) &#123;</span><br><span class="line">    threads[i] = <span class="built_in">std</span>::thread(run_step, i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Wait for all threads to complete.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = numThreads; i != <span class="number">0</span>; --i) &#123;</span><br><span class="line">    threads[i - <span class="number">1</span>].join();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码就用notify_one()按顺序依次唤醒下一个处理线程。这方案总体来说会比notify_all()的方案更加高效。因为唤醒的目标线程是准确的。</p>
<h3 id="CON56-CPP-在一个已获得锁的调用线程中不要“推测性”地对一个不支持递归的mutex再次上锁"><a href="#CON56-CPP-在一个已获得锁的调用线程中不要“推测性”地对一个不支持递归的mutex再次上锁" class="headerlink" title="CON56-CPP. 在一个已获得锁的调用线程中不要“推测性”地对一个不支持递归的mutex再次上锁"></a>CON56-CPP. 在一个已获得锁的调用线程中不要“推测性”地对一个不支持递归的mutex再次上锁</h3><p>严重程度： 低。 修复代价很高。用递归的方式上锁不支持递归的mutex是未定义行为，一般现象是直接造成死锁</p>
<p>C++ 标准库提供两种mutex来保护临界区（非递归和递归的mutex）。递归的mutex(std::recursive_mutex和std::recursive_timed_mutex)与非递归的mutex(std::mutex, std::timed_mutex, 和 std::shared_timed_mutex)的区别就在于递归的mutex可以被同一个线程递归的上锁多次。</p>
<p>所有的mutex类都提供以下“推测性”的lock函数：</p>
<p>try_lock()<br>try_lock_for()<br>try_lock_until()<br>try_lock_shared_for ()<br>try_lock_shared_until()</p>
<p>以上的函数一般是用来试图获取调用线程的mutex所有权，但是在试图获取的同时不会阻塞，调用之后会立即返回bool来判断是否lock成功。</p>
<p>C++标准[thread.mutex.requirements.mutex]中有如下所述:</p>
<blockquote>
<p>The expression m.try_lock() shall be well-formed and have the following semantics: Requires: If m is of type std::mutex, std::timed_mutex, or std::shared_timed_mutex, the calling thread does not own the mutex</p>
</blockquote>
<p>另外在[thread.timedmutex.class]有如下声明:</p>
<blockquote>
<p>The behavior of a program is undefined if:</p>
</blockquote>
<blockquote>
<p>• a thread that owns a timed_mutex object calls lock(), try_lock(), try_lock_for(), or try_lock_until() on that object</p>
</blockquote>
<p>最后，[thread.sharedtimedmutex.class]中有如下声明:</p>
<blockquote>
<p>The behavior of a program is undefined if:</p>
</blockquote>
<blockquote>
<p>• a thread attempts to recursively gain any ownership of a shared_timed_mutex.</p>
</blockquote>
<p>因此对于已经获取锁的调用线程再次试图对一个非递归的mutex上锁时，直接会造成未定义行为。</p>
<h4 id="代码样例对比-6"><a href="#代码样例对比-6" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::mutex m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_thread_safe_work</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!m.try_lock()) &#123;</span><br><span class="line">    <span class="comment">// The lock is not owned yet, do other work while waiting.</span></span><br><span class="line">    do_thread_safe_work();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// The mutex is now locked; perform work on shared resources.</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// Release the mutex.</span></span><br><span class="line">  <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">    m.unlock();</span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  m.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(m);</span><br><span class="line">  do_work();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">t</span><span class="params">(start_func)</span></span>;</span><br><span class="line">  do_work();</span><br><span class="line">  t.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码显然，线程t中，试图对非递归的mutex进行多次上锁，会造成未定义行为。当然，对于大多数编译器产商提供了一个同样的实现，程序会直接表现为死锁。所以可以改成以下代码,不要在线程入口函数中锁住mutex:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::mutex m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_thread_safe_work</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!m.try_lock()) &#123;</span><br><span class="line">    <span class="comment">// The lock is not owned yet, do other work while waiting.</span></span><br><span class="line">    do_thread_safe_work();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// The mutex is now locked; perform work on shared resources.</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// Release the mutex.</span></span><br><span class="line">  <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">    m.unlock();</span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  m.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  do_work();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">t</span><span class="params">(start_func)</span></span>;</span><br><span class="line">  do_work();</span><br><span class="line">  t.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<!--<a href="https://alexiachen.github.io/blog/2017/08/16/cert-cpp-nine/#disqus_thread" class="article-comment-link">Comments</a>
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = ''; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
-->
<div style="display:none">
<script src="http://s4.cnzz.com/stat.php?id=&web_id=" language="JavaScript"></script>script>
</div>






</body>
</html>