<html>
<head><meta name="generator" content="Hexo 3.8.0">
	
	<title>单例模式的线程安全</title>
	<meta name="keywords" content="MathxH Blog">

    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    
	   <link href="/blog/css/main.css?v=3" rel="stylesheet" type="text/css">
    
        <script src="/blog/js/util.js"></script>
        <script>
            if(isMobile()) {
                loadjscssfile('../css/mobile.css', 'css');
            } else {
                loadjscssfile('../css/desktop.css', 'css');
            }
        </script> 
    

    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">

    
	<link rel="shortcut icon" type="image/x-icon" href="/blog/favicon.ico?v=3">
    
    

</head>

<body>


<h2 class="title">单例模式的线程安全</h2>
<!---
<div style="text-align:center;margin-top: -10px;">
<div class="article-category">
发表于2017年2月27日




 </div>
--->



<p>在写单例模式的时候，一般我们都需要保证这个单例类的线程安全，当然，网络上有大部分“解决方案了”，加锁和双重检查锁配合来“保证”单例类的线程安全，可是，如果把指令重排序也考虑到其中的话，这样的写法，就是非线程安全了。</p>
<p>随便列出网络上几篇博文的单例模式都<font color="red">不是</font>线程安全的：</p>
<ul>
<li><a href="http://www.cnblogs.com/weixliu/p/3900764.html" target="_blank" rel="noopener">单例模式全面学习（C++版）</a></li>
<li><a href="http://www.cnblogs.com/qiaoconglovelife/p/5851163.html" target="_blank" rel="noopener">C++的单例模式与线程安全单例模式（懒汉/饿汉）</a></li>
<li><a href="http://www.cnblogs.com/xudong-bupt/p/3433643.html" target="_blank" rel="noopener">设计模式之单例模式(线程安全)</a></li>
</ul>
<p>以下是网络上大部分的“经典”的“线程安全”单例模式实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@ actually <span class="keyword">not</span> thread safe</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> singleton* p&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::mutex m_mutex;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> singleton* <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    singleton(<span class="keyword">const</span> singleton&amp; s) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">singleton* singleton:: getInstance()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// double-check locker</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) <span class="comment">// first check</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(m_mutex); <span class="comment">// lock</span></span><br><span class="line">            <span class="keyword">if</span> (p == <span class="literal">nullptr</span>)   <span class="comment">// second check</span></span><br><span class="line">                p = <span class="keyword">new</span> singleton(); <span class="comment">// but this may cause non-thread-safe</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先，先讲解一下，指令重排会发生在系统的好几个层面，我分别用C++和Java来讲解：</p>
<ul>
<li><p>C++ 被编译器编译成机器码的时候，机器码的顺序可能被重排过，在程序运行的时候，在CPU内部也可能会选择性的又进行一次重排，总共2次，重排是必定会发生的。</p>
</li>
<li><p>Java 被编译器编译成字节码的时候会重排一次，JVM执行字节码的时候又进行一次重排，JVM执行的字节码最终也是变成机器码在CPU内部又会进行重排，总共是3次。</p>
</li>
</ul>
<p>所以了，到头来，指令重排是不可能消除的，这是编译器和CPU优化的领域，就不进行过多的探讨。</p>
<p>下面来讲解一下以上的单例类的代码，以及为什么它在指令重排序的情况下会变成非线程安全：</p>
<p>我上面把代码的注释写了，问题就出现在new 那里，熟悉C++的开发者可能知道new语句的大概执行动作，我把它分解成如下几步：</p>
<ol>
<li>分配对象的内存空间，可以简单理解为malloc</li>
<li>调用对象的构造函数初始化对象（内存空间上的对象状态此刻是合法的了）</li>
<li>把内存空间的地址赋值给p指针</li>
</ol>
<p>注意了，如果编译器生成的代码，和CPU内部的执行顺序永远是按以上的顺序执行，那么永远都不用担心线程安全的问题，但是由于<a href="https://en.wikipedia.org/wiki/Happened-before" target="_blank" rel="noopener">happens-before语义</a>，2和3步骤没有严格的依赖顺序，编译器有些时候为了优化，完全可以把3放到2时候执行，2也会放到3时候执行。那么这样情况下，可以就会变成下面这样了：</p>
<ol>
<li>分配对象的内存空间，可以简单理解为malloc</li>
<li>把内存空间的地址赋值给p指针 （此刻内存空间上的对象状态不合法，没初始化）</li>
<li>调用对象的构造函数初始化对象（内存空间上的对象状态此刻是合法的了）</li>
</ol>
<p>还想深入了解happens-before的，可以看<a href="http://ifeve.com/happens-before/" target="_blank" rel="noopener">这里</a>。</p>
<p>那么，指令重排下，以上的单例代码可能变成以下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@ actually <span class="keyword">not</span> thread safe</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> singleton* p&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::mutex m_mutex;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> singleton* <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    singleton(<span class="keyword">const</span> singleton&amp; s) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">singleton* singleton:: getInstance()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// double-check locker</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) <span class="comment">// first check</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(m_mutex); <span class="comment">// lock</span></span><br><span class="line">            <span class="keyword">if</span> (p == <span class="literal">nullptr</span>)   <span class="comment">// second check</span></span><br><span class="line">             &#123;</span><br><span class="line">                    <span class="comment">//以下是抽象出来的伪代码</span></span><br><span class="line">                    memory_addr = <span class="built_in">malloc</span>();   <span class="comment">//1：分配对象的内存空间  </span></span><br><span class="line">                    p = memory_addr;     <span class="comment">//2：设置p指向刚分配的内存地址  </span></span><br><span class="line">                                 <span class="comment">//注意，此时对象还没有被初始化！  </span></span><br><span class="line">                    singleton_constructor(memory);  <span class="comment">//3：初始化对象  </span></span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>聪明的人，一下子就可以看出来以上的代码在多线程下可能会导致的问题了，<br>还不明白的话，我做了一个线程执行时间表：</p>
<table>
<thead>
<tr>
<th>时间序列</th>
<th style="text-align:center">线程A</th>
<th style="text-align:right">线程B</th>
</tr>
</thead>
<tbody>
<tr>
<td>t1</td>
<td style="text-align:center">分配对象的内存空间</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>t2</td>
<td style="text-align:center">设置p指向内存空间</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>t3</td>
<td style="text-align:center"></td>
<td style="text-align:right">判断p是否为nullptr</td>
</tr>
<tr>
<td>t4</td>
<td style="text-align:center"></td>
<td style="text-align:right">由于p不为nullptr，线程B将访问p指向的对象（而这个时候对象还没有初始化）</td>
</tr>
<tr>
<td>t5</td>
<td style="text-align:center">初始化对象（调用构造函数）</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>t6</td>
<td style="text-align:center">访问p指向的对象</td>
</tr>
</tbody>
</table>
<p>线程B拿到一个未初始化的对象（对象状态不合法）去操作，结果肯定就出错了。</p>
<p>那么如何写才能保证线程安全呢？ 我给出几种方案:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@ thread safe</span><br><span class="line"><span class="comment">// 以下代码虽然是C++ 11的，但是你可以把它理解非C++ 11，如果是C++ 11的话，从标准上就保证 静态初始化就是线程安全的，完全没必要像下面这样做了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> atomic &lt; singleton* &gt; p&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::mutex m_mutex;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> singleton* <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    singleton(<span class="keyword">const</span> singleton&amp; s) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">singleton* singleton:: getInstance()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// double-check locker</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) <span class="comment">// first check</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(m_mutex); <span class="comment">// lock</span></span><br><span class="line">            <span class="keyword">if</span> (p == <span class="literal">nullptr</span>)   <span class="comment">// second check</span></span><br><span class="line">             &#123;</span><br><span class="line">                    p = <span class="keyword">new</span> singleton(); </span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是C++ 11的代码，完全没必要这么繁琐了，可以直接像下面这么干：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ 11标准保证这是线程安全的，当然也得看编译器产商怎么实现了，比如悲剧的是</span></span><br><span class="line"><span class="comment">// VS2013下这么做是非线程安全的,但VS2015下绝对是线程安全</span></span><br><span class="line"><span class="comment">// 参考： https://msdn.microsoft.com/en-gb/library/hh567368.aspx</span></span><br><span class="line"><span class="function">singleton*&amp; <span class="title">getInst</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> singleton* p = <span class="keyword">new</span> singleton();</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>详情请戳<a href="http://stackoverflow.com/questions/2576022/efficient-thread-safe-singleton-in-c" target="_blank" rel="noopener">这里</a>。</p>
<p>如果是Java代码，建议按以下这么干，保证线程安全：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> singleton INSTANCE = <span class="keyword">new</span> singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// rest of class omitted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上Java代码完全不需要加锁，Java的类加载器已经保证必定会在访问类的时候，最先初始化singleton。</p>
<p>详情请戳<a href="http://stackoverflow.com/questions/16106260/thread-safe-singleton-class" target="_blank" rel="noopener">这里</a>和<a href="http://stackoverflow.com/questions/4482533/thread-safe-efficient-way-to-implement-singleton-pattern-in-java" target="_blank" rel="noopener">这里</a>。</p>
<p>EOF</p>


<!--<a href="https://alexiachen.github.io/blog/2017/02/27/singleton-thread-safe/#disqus_thread" class="article-comment-link">Comments</a>
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = ''; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
-->
<div style="display:none">
<script src="http://s4.cnzz.com/stat.php?id=&web_id=" language="JavaScript"></script>script>
</div>






</body>
</html>