<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>MathxH</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="System Software Engineer">
<meta property="og:type" content="website">
<meta property="og:title" content="MathxH">
<meta property="og:url" content="https://alexiachen.github.io/blog/page/4/index.html">
<meta property="og:site_name" content="MathxH">
<meta property="og:description" content="System Software Engineer">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MathxH">
<meta name="twitter:description" content="System Software Engineer">
  
    <link rel="alternate" href="/blog/atom.xml" title="MathxH" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/blog/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog/" id="logo">MathxH</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/blog/" id="subtitle">MathxH</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blog/">Home</a>
        
          <a class="main-nav-link" href="/blog/archives">Archives</a>
        
          <a class="main-nav-link" href="/blog/about">About</a>
        
          <a class="main-nav-link" href="/blog/resume">Resume</a>
        
      </nav>
      <nav id="sub-nav">
        <a></a>
        
          <a id="nav-rss-link" class="nav-icon" href="/blog/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://alexiachen.github.io/blog"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-cert-cpp-six" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2017/08/09/cert-cpp-six/" class="article-date">
  <time datetime="2017-08-09T01:25:46.000Z" itemprop="datePublished">2017-08-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2017/08/09/cert-cpp-six/">CERT C++编码规范翻译(FIO)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a>文件IO</h2><h3 id="FIO50-CPP-在使用文件流输入输出的时候不要不使用中介定位调用"><a href="#FIO50-CPP-在使用文件流输入输出的时候不要不使用中介定位调用" class="headerlink" title="FIO50-CPP. 在使用文件流输入输出的时候不要不使用中介定位调用"></a>FIO50-CPP. 在使用文件流输入输出的时候不要不使用中介定位调用</h3><p>严重程度:低。如果在使用文件流做输入输出的时候没有调用中介flush和中介定位那么就是未定义行为。</p>
<p>C++标准[filebuf]有如下声明:</p>
<blockquote>
<p>The restrictions on reading and writing a sequence controlled by an object of class<br>basic_filebuf&lt;charT, traits&gt; are the same as for reading and writing with the<br>Standard C library FILEs.</p>
</blockquote>
<p>当然C++是兼容C的，C标准也有类似以下声明:</p>
<blockquote>
<p>When a file is opened with update mode . . ., both input and output may be performed on<br>the associated stream. However, output shall not be directly followed by input without an<br>intervening call to the fflush function or to a file positioning function (fseek,<br>fsetpos, or rewind), and input shall not be directly followed by output without an<br>intervening call to a file positioning function, unless the input operation encounters endof-file.</p>
</blockquote>
<p>所以，结果以下场景就会导致未定义行为:</p>
<ul>
<li><p>Receiving input from a stream directly following an output to that stream without an intervening call to std::basic_filebuf<t>::seekoff() if the file is not at end-offile</t></p>
</li>
<li><p>Outputting to a stream after receiving input from that stream without a call to std::basic_filebuf<t>::seekoff() if the file is not at end-of-file</t></p>
</li>
</ul>
<h4 id="代码样例对比"><a href="#代码样例对比" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;fileName)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="function">fstream <span class="title">file</span><span class="params">(fileName)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (!file.is_open()) &#123;</span><br><span class="line">    <span class="comment">// Handle error</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  file &lt;&lt; <span class="string">"Output some data"</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> str;</span><br><span class="line">  file &gt;&gt; str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码通过文件流试图把”Output some data”写入文件尾，然后并把该字符串又重新读出到str对象中，然而，这输入输出的中间并没有调用中介定位函数，所以行为是未定义的。所以改成以下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;fileName)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="function">fstream <span class="title">file</span><span class="params">(fileName)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (!file.is_open()) &#123;</span><br><span class="line">    <span class="comment">// Handle error</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  file &lt;&lt; <span class="string">"Output some data"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> str;</span><br><span class="line">  file.seekg(<span class="number">0</span>, <span class="built_in">std</span>::ios::beg);</span><br><span class="line">  file &gt;&gt; str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码通过std::basic_istream<t>::seekg()把文件流指针调整到了文件的开头，这样才能读取到写入的字符串。</t></p>
<h3 id="FIO51-CPP-当不需要操作文件的时候一定要关闭文件"><a href="#FIO51-CPP-当不需要操作文件的时候一定要关闭文件" class="headerlink" title="FIO51-CPP. 当不需要操作文件的时候一定要关闭文件"></a>FIO51-CPP. 当不需要操作文件的时候一定要关闭文件</h3><p>严重程度: 中等。容易导致系统资源浪费，造成程序不正常终止。</p>
<p>对std::basic_filebuf<t>::open()的调用一定要有std::basic_filebuf<t>::close()来关闭文件，至少都要在程序结束之前关闭。 </t></t></p>
<p>注意，std::basic_ifstream<t>, std::basic_ofstream<t>和std::basic_fstream<t>这三个类底层都依赖std::basic_filebuf<t>对象提供的open和close来打开关闭文件。</t></t></t></t></p>
<h4 id="代码样例对比-1"><a href="#代码样例对比-1" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;fileName)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="function">fstream <span class="title">file</span><span class="params">(fileName)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (!file.is_open()) &#123;</span><br><span class="line">    <span class="comment">// Handle error</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">std</span>::terminate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码显然有问题，因为用文件流对象打开了一个文件，但是file对象没有正确关闭，因为代码用std::terminate()强制终止了程序，导致file对象的析构函数没有调用，自然就没有正确关闭文件。std::terminate()本质上是调用了std::abort()才导致的问题。</p>
<p>当然，如果非要在f()函数中强制终止程序，那么需要手工保证文件关闭，不能依赖RAII来关闭资源:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;fileName)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="function">fstream <span class="title">file</span><span class="params">(fileName)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (!file.is_open()) &#123;</span><br><span class="line">    <span class="comment">// Handle error</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  file.close(); <span class="comment">//在调用terminate之前手工调用close关闭文件</span></span><br><span class="line">  <span class="keyword">if</span> (file.fail()) &#123;</span><br><span class="line">    <span class="comment">// Handle error</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::terminate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，还可以通过RAII机制来关闭文件，这样的方式是C++主推的一种手段，方便安全:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;fileName)</span> </span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">fstream <span class="title">file</span><span class="params">(fileName)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!file.is_open()) &#123;</span><br><span class="line">      <span class="comment">// Handle error</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="comment">// 文件正确关闭，因为文件流对象file到这里退出作用域，自动调用了file对象的析构函数</span></span><br><span class="line">  <span class="built_in">std</span>::terminate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://alexiachen.github.io/blog/2017/08/09/cert-cpp-six/" data-id="cjtctmcei0008qfqf3mo2numx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/C-C/">C/C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/CERT/">CERT</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-cert-cpp-five" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2017/08/01/cert-cpp-five/" class="article-date">
  <time datetime="2017-08-01T03:30:46.000Z" itemprop="datePublished">2017-08-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2017/08/01/cert-cpp-five/">CERT C++编码规范翻译（MEM）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="MEM50-CPP-不要访问已经释放的内存"><a href="#MEM50-CPP-不要访问已经释放的内存" class="headerlink" title="MEM50-CPP. 不要访问已经释放的内存"></a>MEM50-CPP. 不要访问已经释放的内存</h3><p>严重程度：高。读取动态分配的内存（已经释放）会导致不正常的程序终止和拒绝服务攻击。写动态分配的内存（已释放）会导致执行任意代码和恶意的代码提权操作。</p>
<h4 id="代码样例对比"><a href="#代码样例对比" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">  S *s = <span class="keyword">new</span> S;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">delete</span> s;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  s-&gt;f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码有个明显的错误，就是s指向的对象被释放了之后，还对s指针解引用。这种问题出现在大型工程里面不好查。当然noexcept(false)是为了遵循MEM52-CPP这个规范。这个是正确的。</p>
<p>知道了原理可以用以下多种方法来解决:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">  S *s = <span class="keyword">new</span> S;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  s-&gt;f();</span><br><span class="line">  <span class="keyword">delete</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">////////////////////////////</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span> </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  S s;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  s.f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码样例对比-1"><a href="#代码样例对比-1" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">str_func</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_string</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *str = str_func().c_str();</span><br><span class="line">  display_string(str); <span class="comment">/* Undefined behavior */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，以上代码str_func()返回的是一个临时std::string对象，然后再通过c_str()获取对象底层的C字符串指针，这导致一旦该赋值语句执行完毕，临时对象立即释放，所以str指针在执行到display_string的时候访问了std::string对象的生命周期以外，所以立即导致未定义行为。所以可以推迟对象的生命周期:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">str_func</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_string</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> str = str_func();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *cstr = str.c_str();</span><br><span class="line">  display_string(cstr); <span class="comment">/* ok */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样来看的话，那么就把临时对象赋值给了新的str对象，而str对象的生命周期是f()函数的语句块范围内，就把其生命周期推迟到了display_string函数执行完毕之后，cstr指针的指向一直是有效值。</p>
<h4 id="代码样例对比-2"><a href="#代码样例对比-2" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> *ptr = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span> *&gt;(::<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="number">0</span>));</span><br><span class="line">  *ptr = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(ptr)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码是想通过new操作符分配一个0字节的内存空间，并用ptr指针指向这段内存空间。如果分配成功，那么operator new()会返回一个非null指针。然而，根据C++标准[basic.stc.dynamic.allocation]，这样通过指针解引用一个0字节的内存空间会导致未定义行为。</p>
<p>如果你想分配一个单个unsigned char大小的对象，可以用new操作符来直接代替operator new()。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="literal">false</span>)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> *ptr = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>;</span><br><span class="line">  *ptr = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你有分配一个0字节内存空间的需求，该需求可能是需要获取一个唯一的指针值，该值直到指针没被释放都不能被其他指针复用的指针值。防止解引用该指针造成的未定义行为可以改成以下代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> *ptr = ::<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="number">0</span>); <span class="comment">// ptr的值经过多次分配，值都是随机不重复的</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(ptr)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="MEM51-CPP-恰当的释放已经动态分配的资源"><a href="#MEM51-CPP-恰当的释放已经动态分配的资源" class="headerlink" title="MEM51-CPP. 恰当的释放已经动态分配的资源"></a>MEM51-CPP. 恰当的释放已经动态分配的资源</h3><p>严重程度：高。不采用对应的dealloc函数会导致未定义行为。</p>
<p>在C语言中，语言标准库提供了几种分配内存的方式:</p>
<ul>
<li>std::malloc</li>
<li>std::calloc</li>
<li>std::realloc</li>
</ul>
<p>这三种方式都可以在C++语言中使用，然而，只能使用std::free来释放已经分配的内存。</p>
<p>C++语言提供了另外的分配内存方式，比如new,new[]和placement new，还有分配器对象。不像C语言，C++提供了相应的几种释放动态分配内存空间的方式，比如delete,delete<a href=""></a>和分配器对象的dealloc函数。</p>
<p>不要调用对nullptr指针调用dealloc函数，一定要采用与分配时候相对应的dealloc函数来释放内存资源。以下是分配和释放对应的方法列表:</p>
<table>
<thead>
<tr>
<th>Allocator</th>
<th style="text-align:center">Deallocator</th>
</tr>
</thead>
<tbody>
<tr>
<td>global operator new()/new</td>
<td style="text-align:center">global operator delete()/delete</td>
</tr>
<tr>
<td>global operator new<a href=""></a>/new[]</td>
<td style="text-align:center">global operator delete<a href=""></a>/delete[]</td>
</tr>
<tr>
<td>class-specific operator new()/new</td>
<td style="text-align:center">class-specific operator delete()/delete</td>
</tr>
<tr>
<td>class-specific operator new<a href=""></a>/new[]</td>
<td style="text-align:center">class-specific operator delete<a href=""></a>/delete[]</td>
</tr>
<tr>
<td>placement operator new()</td>
<td style="text-align:center">N/A</td>
</tr>
<tr>
<td>allocator<t>::allocate()</t></td>
<td style="text-align:center">allocator<t>::deallocate()</t></td>
</tr>
<tr>
<td>std::malloc(), std::calloc(),std::realloc()</td>
<td style="text-align:center">std::free()</td>
</tr>
<tr>
<td>std::get_temporary_buffer()</td>
<td style="text-align:center">std::return_temporary_buffer()</td>
</tr>
</tbody>
</table>
<p>一旦相同的内存资源释放调用的函数与分配时候的函数不匹配对应，那么立即会造成未定义行为。</p>
<p>C++标准[expr.delete]有如下声明：</p>
<blockquote>
<p>In the first alternative (delete object), the value of the operand of delete may be a null<br>pointer value, a pointer to a non-array object created by a previous new-expression, or a<br>pointer to a subobject (1.8) representing a base class of such an object (Clause 10). If<br>not, the behavior is undefined. In the second alternative (delete array), the value of the<br>operand of delete may be a null pointer value or a pointer value that resulted from a<br>previous array new-expression. If not, the behavior is undefined.</p>
</blockquote>
<h4 id="代码样例对比-3"><a href="#代码样例对比-3" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  S() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"S::S()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">  ~S() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"S::~S()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  S s1;</span><br><span class="line">  S *s2 = <span class="keyword">new</span> (&amp;s1) S;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">delete</span> s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码f()函数的局部对象s1被传入到placement new中，然而placement new返回的指针s2最后又被传到::operator delete() 中调用。这就直接导致了未定义行为，因为::operator delete()试图释放通过::operator new()分配还没有返回的内存，简而言之，就是，还没有分配完成并返回，就开始释放了，那当然错了。</p>
<p>其实要知道以上代码为什么会有问题，需要知道C++ placement new是什么特性？  平时最常用的是new，它底层的流程机制是这样的：分配内存空间，在该内存空间上调用构造函数初始化对象，把对象的地址返回给指针。但是如果已知给定一段内存空间的情况下，向在这片内存空间上初始化分配一个对象，那么new是办不到的，只有用placement new，它的作用就是在特定的内存空间上(不主动开辟内存空间)调用构造函数创建并初始化一个对象。</p>
<p>所以以上代码出错了，因为代码意图想在s1对象所在的内存空间上又创造并初始化一个S类型的对象，但是却显式调用delete，s2所指向的对象立即被析构释放了，而s1对象确实是存在的，所以在f()函数结束时，s1对象又调用一次自身的析构函数释放，就出现问题了。</p>
<p>应该改成以下方式:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  S() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"S::S()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">  ~S() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"S::~S()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  S s1;</span><br><span class="line">  S *s2 = <span class="keyword">new</span> (&amp;s1) S;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码样例对比-4"><a href="#代码样例对比-4" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *i1, *i2;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    i1 = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    i2 = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (<span class="built_in">std</span>::bad_alloc &amp;) &#123;</span><br><span class="line">    <span class="keyword">delete</span> i1;</span><br><span class="line">    <span class="keyword">delete</span> i2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码不仔细分析看不出个所以然，try catch块包裹代码是为了防止new失败所抛出的异常，看似没有任何问题。然而，i1，i2指针没有初始化为nullptr，所以一旦代码抛出bad_alloc的异常，如果new一旦失败，::operator new()还没有返回值并赋值给i1或i2。那么::operator delete()所传入的指针值就是不合法的，因为指针没有被初始化，它可以是任何随机值，这就立即导致了未定义行为。所以应该初始化指针:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *i1 = <span class="literal">nullptr</span>, *i2 = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    i1 = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    i2 = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (<span class="built_in">std</span>::bad_alloc &amp;) &#123;</span><br><span class="line">    <span class="keyword">delete</span> i1;</span><br><span class="line">    <span class="keyword">delete</span> i2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++标准指出，delete 空指针不会有任何问题。所以即使分配失败抛出异常，这段代码也是没有问题的。</p>
<h4 id="代码样例对比-5"><a href="#代码样例对比-5" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">P</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line">  P *p;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  C(P *p) : p(p) &#123;&#125;</span><br><span class="line">  ~C() &#123; <span class="keyword">delete</span> p; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(C c)</span> </span>&#123;</span><br><span class="line">  c.f();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  P *p = <span class="keyword">new</span> P;</span><br><span class="line">  <span class="function">C <span class="title">c</span><span class="params">(p)</span></span>;</span><br><span class="line">  g(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码仔细看看出问题了吗？显然p所指向的对象导致了重复的二次释放，来主要来源于C++的浅拷贝所带来的问题。当在函数h()中p所指向的对象的生命周期与c对象的生命周期绑定了，然而，对象c被通过传值的方式传到了g()函数中，这里会隐式调用一个C类型的拷贝构造函数重新在g()函数的作用域范围内创建一个新的对象c，也就是有两个对象内部的p指针会指向同一个P类型的对象，当函数g()退出时，g()函数内的对象c会调用析构函数delete指针所指向的对象，h()函数退出时，h()函数内的对象c又会调用自己的析构函数delete指针所指向的对象，所以导致p指针所指向的对象被重复释放两次。</p>
<p>C++标准[class.copy]对于类的拷贝构造函数有如下声明:</p>
<blockquote>
<p>If the class definition does not explicitly declare a copy constructor, one is declared<br>implicitly. If the class definition declares a move constructor or move assignment<br>operator, the implicitly declared copy constructor is defined as deleted; otherwise, it is<br>defined as defaulted (8.4). The latter case is deprecated if the class has a user-declared<br>copy assignment operator or a user-declared destructor.</p>
</blockquote>
<p>所以知道了原因就好办了，直接强行禁止编译器默认生成的拷贝构造函数和赋值构造函数:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">P</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line">  P *p;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  C(P *p) : p(p) &#123;&#125;</span><br><span class="line">  C(<span class="keyword">const</span> C&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  ~C() &#123; <span class="keyword">delete</span> p; &#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> C&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(C &amp;c)</span> </span>&#123;</span><br><span class="line">c.f();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  P *p = <span class="keyword">new</span> P;</span><br><span class="line">  <span class="function">C <span class="title">c</span><span class="params">(p)</span></span>;</span><br><span class="line">  g(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码禁止了默认的构造函数并且g()函数的调用参数改成了引用传递，这样就不会二次释放了。</p>
<h4 id="代码样例对比-6"><a href="#代码样例对比-6" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *<span class="built_in">array</span> = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">delete</span> <span class="built_in">array</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码分配和释放方法不匹配对应，所以是错的，会导致未定义行为。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *<span class="built_in">array</span> = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">delete</span>[] <span class="built_in">array</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码样例对比-7"><a href="#代码样例对比-7" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *i = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span> *&gt;(<span class="built_in">std</span>::<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)));</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">delete</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上的代码也是分配和释放方法不匹配，尽管大多数的编译器产商new实现是malloc分配的内存，delete是free来进行释放内存，尽管在大多数编译器上，这段代码不会发生问题。但是这些是实现，应该尽量不依赖实现编写程序，C++的内存管理不应该依赖底层的C内存管理方法。应该针对同级抽象层级来写代码，不同层级的代码不要混用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *i = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span> *&gt;(<span class="built_in">std</span>::<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)));</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">free</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码样例对比-8"><a href="#代码样例对比-8" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  ~S();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  S *s = <span class="keyword">new</span> S();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">free</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上的代码也是分配和释放方法不匹配,要注意的是，以上代码new的时候除了分配内存空间，还调用了构造函数创建了对象，当释放的时候通过s指针free了内存空间，然而，对象的析构函数没有被调用，会导致未定义行为。这个代码违反了MEM53-CPP的规则。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  ~S();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  S *s = <span class="keyword">new</span> S();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">delete</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码样例对比-9"><a href="#代码样例对比-9" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> size)</span> <span class="title">noexcept</span><span class="params">(<span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">malloc</span>(size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *ptr)</span> <span class="title">noexcept</span><span class="params">(<span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">free</span>(ptr);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  S *s = <span class="keyword">new</span> S;</span><br><span class="line">  ::<span class="keyword">delete</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码的全局new操作符被与类特定关联的operator new()重载实现了。所以对于此类上调用new的话，实际上调用的是S::operator new()。然而，因为对象的销毁是用范围::delete操作符，所以实际上调用的全局operator delete(),而不是S::operator delete()，所以由于分配和释放的方式不匹配一致，导致出现未定义行为。所以应该改成以下代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> size)</span> <span class="title">noexcept</span><span class="params">(<span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">malloc</span>(size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *ptr)</span> <span class="title">noexcept</span><span class="params">(<span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">free</span>(ptr);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  S *s = <span class="keyword">new</span> S;</span><br><span class="line">  <span class="keyword">delete</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码就采用非范围delete代替了范围::delete。所以实质上调用的是匹配的S::operator delete()。是正确的。</p>
<h4 id="代码样例对比-10"><a href="#代码样例对比-10" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;S&gt; s&#123;<span class="keyword">new</span> S[<span class="number">10</span>]&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码显然有问题，经常使用智能指针的开发人员就可以看出来了，std::unique_ptr模版传入的类型有错误，s指针指向的是一个S类型的数组，所以当s对象销毁时，它的析构函数调用的是delete来销毁S类型的数组，而不是delete []，所以本质上是分配和释放方法不匹配导致未定义行为。应该改成以下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;S[]&gt; s = <span class="built_in">std</span>::make_unique&lt;S[]&gt;(<span class="number">10</span>); <span class="comment">//最好使用工厂函数来初始化指针指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;S[]&gt; s(<span class="keyword">new</span> S[<span class="number">10</span>]); <span class="comment">//当然，这样也无所谓，没有任何问题，只是最好当没有显式出现delete操作符的时候最好不要出现new了，这两个操作符之间的出现最好一de致匹配，要不就都没有，这是个审美问题。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码样例对比-11"><a href="#代码样例对比-11" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;S&gt; s&#123;<span class="keyword">new</span> S[<span class="number">10</span>]&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码的问题与之前的std::unique_ptr的问题一样，本质是分配和释放的方法不匹配一致，但是，std::shared_ptr模版中不能传递S[]类型，std::make_shared工厂函数也不能传递S[]类型，所以只能用点蹩脚的方式:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;S&gt; s&#123;</span><br><span class="line">    <span class="keyword">new</span> S[<span class="number">10</span>], [](<span class="keyword">const</span> S *ptr) &#123; <span class="keyword">delete</span> [] ptr; &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是通过std::shared_ptr所提供的方式自定义std::shared_ptr的释放方式(deleter)。这样就保证对象数组是通过delete[]正确释放了。</p>
<p>为什么std::shared_ptr会与std::unique_ptr不一样的？为什么std::shared_ptr这么不方便的？因为std::shared_ptr所指向的对象的设计初衷就不是指向数组，std::unique_ptr更适合指向数组。</p>
<h3 id="MEM52-CPP-检测和处理内存分配错误"><a href="#MEM52-CPP-检测和处理内存分配错误" class="headerlink" title="MEM52-CPP. 检测和处理内存分配错误"></a>MEM52-CPP. 检测和处理内存分配错误</h3><p>严重程度：高。如果没有检测内存分配失败的错误那么可能导致程序非正常终止和拒绝服务攻击。</p>
<p>在C++默认的内存分配操作符中，::operator new(std::size_t)调用分配失败就会抛出std::bad_alloc的异常。因此开发者不需要检测返回的指针是否为nullptr。其有nothrow的形式，::operator new(std::size_t, const std::nothrow_t &amp;)，也就是说该分配失败不会抛出异常，与之代替的是返回nullptr。 operator new[]也是一样的，有无异常和有异常这两种形式。</p>
<p>另外，默认的对象分配器(std::allocator)也直接使用了::operator new(std::size_t)来分配内存所以需要同样小心对待。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">T *p1 = <span class="keyword">new</span> T; <span class="comment">// Throws std::bad_alloc if allocation fails</span></span><br><span class="line">T *p2 = <span class="keyword">new</span> (<span class="built_in">std</span>::nothrow) T; <span class="comment">// Returns nullptr if allocation fails</span></span><br><span class="line">T *p3 = <span class="keyword">new</span> T[<span class="number">1</span>]; <span class="comment">// Throws std::bad_alloc if the allocation fails</span></span><br><span class="line">T *p4 = <span class="keyword">new</span> (<span class="built_in">std</span>::nothrow) T[<span class="number">1</span>]; <span class="comment">// Returns nullptr if the allocation fails</span></span><br></pre></td></tr></table></figure>
<h4 id="代码样例对比-12"><a href="#代码样例对比-12" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *<span class="built_in">array</span>, <span class="built_in">std</span>::<span class="keyword">size_t</span> size)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *copy = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">memcpy</span>(copy, <span class="built_in">array</span>, size * <span class="keyword">sizeof</span>(*copy));</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">delete</span> [] copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码使用::operator new<a href="std::size_t" target="_blank" rel="noopener"></a>分配一个int数组，但是没有对分配结果做检查。函数f()又被标记为noexcept,所以调用者会假定这个函数不会抛任何异常，但是 ::operator new<a href="std::size_t" target="_blank" rel="noopener"></a> 一旦分配失败，就会抛出异常，这就导致程序不正常的终止了。所以可以改成nothrow版本:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *<span class="built_in">array</span>, <span class="built_in">std</span>::<span class="keyword">size_t</span> size)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *copy = <span class="keyword">new</span> (<span class="built_in">std</span>::nothrow) <span class="keyword">int</span>[size];</span><br><span class="line">  <span class="keyword">if</span> (!copy) &#123;</span><br><span class="line">    <span class="comment">// Handle error</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">memcpy</span>(copy, <span class="built_in">array</span>, size * <span class="keyword">sizeof</span>(*copy));</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">delete</span> [] copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，也可以改成throw版本的，实现try catch来捕获异常:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *<span class="built_in">array</span>, <span class="built_in">std</span>::<span class="keyword">size_t</span> size)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *copy;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    copy = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">  &#125; <span class="keyword">catch</span>(<span class="built_in">std</span>::bad_alloc) &#123;</span><br><span class="line">    <span class="comment">// Handle error</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// At this point, copy has been initialized to allocated memory</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">memcpy</span>(copy, <span class="built_in">array</span>, size * <span class="keyword">sizeof</span>(*copy));</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">delete</span> [] copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，还有个throw版本的，函数签名需要声明noexcept(false):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *<span class="built_in">array</span>, <span class="built_in">std</span>::<span class="keyword">size_t</span> size)</span> <span class="title">noexcept</span><span class="params">(<span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *copy = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">  <span class="comment">// If the allocation fails, it will throw an exception which</span></span><br><span class="line">  <span class="comment">// the caller will have to handle.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">memcpy</span>(copy, <span class="built_in">array</span>, size * <span class="keyword">sizeof</span>(*copy));</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">delete</span> [] copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码样例对比-13"><a href="#代码样例对比-13" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span> <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span> <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(A *, B *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  g(<span class="keyword">new</span> A, <span class="keyword">new</span> B);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码在同一个表达式中执行了2个new操作这显然会发生问题。因为，一旦其中一个new操作发生了异常，另一个new就可能会发生内存泄漏。</p>
<p>考虑一个场景，比如A类被先分配构造，而B在分配的过程中抛出了异常。即使把g()函数的调用用try catch包裹处理，然而对于A的内存释放是不可能的，因为没有保留指向A的指针。另外这个代码与EXP50-CPP规则相违背。所以可以考虑用以下方案:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span> <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span> <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;A&gt; a, <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;B&gt; b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  g(<span class="built_in">std</span>::make_unique&lt;A&gt;(), <span class="built_in">std</span>::make_unique&lt;B&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码通过RAII的方式来管理对象A和B。如果再次发生之前描述的场景，B抛出异常了，那么A由于生命周期与对象绑定了，离开了其作用域，所以也能正确调用其对象的析构函数保证内存资源不泄露。</p>
<p>当然，还可以用最土的办法解决:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span> <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span> <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(A &amp;a, B &amp;b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  A a;</span><br><span class="line">  B b;</span><br><span class="line">  g(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="MEM53-CPP-当手动管理对象生命周期的时候一定要显式构造和析构对象"><a href="#MEM53-CPP-当手动管理对象生命周期的时候一定要显式构造和析构对象" class="headerlink" title="MEM53-CPP. 当手动管理对象生命周期的时候一定要显式构造和析构对象"></a>MEM53-CPP. 当手动管理对象生命周期的时候一定要显式构造和析构对象</h3><p>严重程度:高。可能间接导致未定义行为和信息泄漏。</p>
<p>C++动态分配对象的创建一般是分两步，第一步就是，分配一段足够的内存空间来存储对象，第二步就是根据要创建的对象类型来初始化这段已分配的内存。</p>
<p>C++动态销毁已分配的对象也是分两步，第一步就是，根据对象的类型调用对象自身的析构函数释放自身所持有的资源。第二步就是，释放对象本身所占用的那片内存空间。</p>
<p>C++标准[basic.life]有如下声明:</p>
<blockquote>
<p>The lifetime of an object is a runtime property of the object. An object is said to have<br>non-trivial initialization if it is of a class or aggregate type and it or one of its members is<br>initialized by a constructor other than a trivial default constructor. [Note: initialization by a<br>trivial copy/move constructor is non-trivial initialization. — end note] The lifetime of an<br>object of type T begins when:</p>
</blockquote>
<blockquote>
<p>• storage with the proper alignment and size for type T is obtained, and</p>
</blockquote>
<blockquote>
<p>• if the object has non-trivial initialization, its initialization is complete.<br>The lifetime of an object of type T ends when:</p>
</blockquote>
<blockquote>
<p>• if T is a class type with a non-trivial destructor, the destructor call starts, or</p>
</blockquote>
<blockquote>
<p>• the storage which the object occupies is reused or released.</p>
</blockquote>
<p>当手动管理对象生命周期的时候，在对象生命周期开始的阶段构造函数必须被调用，同样，在一个对象生命周期结束的时候，析构函数必须被调用。在对象的生命周期外访问对象就会直接导致未定义行为。</p>
<h4 id="代码样例对比-14"><a href="#代码样例对比-14" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  S();</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  S *s = <span class="keyword">static_cast</span>&lt;S *&gt;(<span class="built_in">std</span>::<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(S)));</span><br><span class="line">  s-&gt;f();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">free</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码一眼看上去貌似没问题，malloc和free都是匹配的，但是仔细看，这时候S是个类，提供了默认的构造函数，g()函数中，没有用new分配符来分配S类的内存并初始化该对象，仅仅只是分配了存放对象的内存空间，但是此刻对象没有被初始化，处于一个未知的状态，然而代码还试图调用对象的成员函数，这直接导致了未定义行为。如果非要使用malloc，可以改成以下方案:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  S();</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> *ptr = <span class="built_in">std</span>::<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(S));</span><br><span class="line">  S *s = <span class="keyword">new</span> (ptr) S; <span class="comment">//此刻使用的是placement new</span></span><br><span class="line">  s-&gt;f();</span><br><span class="line">  s-&gt;~S();       </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码手动实现new/delete功能的方案。代码是完全没有任何问题的。但是工程实践中，强烈建议不这么做。</p>
<h4 id="代码样例对比-15"><a href="#代码样例对比-15" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc = <span class="built_in">std</span>::allocator&lt;T&gt;&gt;</span><br><span class="line">class Container &#123;</span><br><span class="line">  T *underlyingStorage;</span><br><span class="line">  <span class="keyword">size_t</span> numElements;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">copy_elements</span><span class="params">(T *from, T *to, <span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">reserve</span><span class="params">(<span class="keyword">size_t</span> count)</span> </span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; numElements) </span><br><span class="line">    &#123;</span><br><span class="line">      Alloc alloc;</span><br><span class="line">      T *p = alloc.allocate(count); <span class="comment">// Throws on failure</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        copy_elements(underlyingStorage, p, numElements);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">       alloc.deallocate(p, count);</span><br><span class="line">       <span class="keyword">throw</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      underlyingStorage = p;</span><br><span class="line">    &#125;</span><br><span class="line">    numElements = count;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  T &amp;<span class="keyword">operator</span>[](<span class="keyword">size_t</span> idx) &#123; <span class="keyword">return</span> underlyingStorage[idx]; &#125;</span><br><span class="line">  <span class="keyword">const</span> T &amp;<span class="keyword">operator</span>[](<span class="keyword">size_t</span> idx) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> underlyingStorage[idx]; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上代码复杂点，首先，代码实现了一个自定义的容器类，然后使用了std::allocator对象获取其元素类型的内存，主要看reserve函数，当copy_elements执行的时候，假定拷贝每个元素到新的已分配的空间的时候会调用元素的拷贝构造函数，然而，问题就发生在这里，没有在新分配的内存位置显示调用每个元素的拷贝构造函数，元素对象状态未知，所以一旦对其访问，立即造成未定义行为。应该改成以下显示调用元素的构造函数:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc = <span class="built_in">std</span>::allocator&lt;T&gt;&gt;</span><br><span class="line">class Container &#123;</span><br><span class="line">  T *underlyingStorage;</span><br><span class="line">  <span class="keyword">size_t</span> numElements;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">copy_elements</span><span class="params">(T *from, T *to, <span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">reserve</span><span class="params">(<span class="keyword">size_t</span> count)</span> </span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; numElements) </span><br><span class="line">    &#123;</span><br><span class="line">      Alloc alloc;</span><br><span class="line">      T *p = alloc.allocate(count); <span class="comment">// Throws on failure</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        copy_elements(underlyingStorage, p, numElements);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = numElements; i &lt; count; ++i) &#123;</span><br><span class="line">          alloc.construct(&amp;p[i]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">       alloc.deallocate(p, count);</span><br><span class="line">       <span class="keyword">throw</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      underlyingStorage = p;</span><br><span class="line">    &#125;</span><br><span class="line">    numElements = count;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  T &amp;<span class="keyword">operator</span>[](<span class="keyword">size_t</span> idx) &#123; <span class="keyword">return</span> underlyingStorage[idx]; &#125;</span><br><span class="line">  <span class="keyword">const</span> T &amp;<span class="keyword">operator</span>[](<span class="keyword">size_t</span> idx) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> underlyingStorage[idx]; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="MEM54-CPP-使用placement-new的时候需要注意指针在内存空间上的对齐"><a href="#MEM54-CPP-使用placement-new的时候需要注意指针在内存空间上的对齐" class="headerlink" title="MEM54-CPP. 使用placement new的时候需要注意指针在内存空间上的对齐"></a>MEM54-CPP. 使用placement new的时候需要注意指针在内存空间上的对齐</h3><p>严重程度:高。容易直接导致未定义行为，包括缓冲区溢出和程序非正常终止。</p>
<p>当我们调用C++默认的全局new表达式时，默认使用的是非placement的形式，它会分配一个足够的内存空间来存储对象，如果分配成功，还会返回一个根据对象类型已对齐的对象指针。然而，如果是仅仅使用placement new的话，返回给调用者的指针就无法保证是已对齐的了，而且也无法保证有足够的内存空间来构造对象，因为内存是外部给定的，无法预知。</p>
<p>C++标准[expr.new]有如下非正式声明:</p>
<blockquote>
<p>[Note: when the allocation function returns a value other than null, it must be a pointer to<br>a block of storage in which space for the object has been reserved. The block of storage<br>is assumed to be appropriately aligned and of the requested size. The address of the<br>created object will not necessarily be the same as that of the block if the object is an<br>array. —end note]</p>
</blockquote>
<h4 id="代码样例对比-16"><a href="#代码样例对比-16" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">short</span> s;</span><br><span class="line">  <span class="keyword">long</span> *lp = ::<span class="keyword">new</span> (&amp;s) <span class="keyword">long</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码显然是错的，在short类型对象s开辟的内存空间上构造一个long类型的对象，在大多数平台架构上 sizeof(short) &lt; sizeof(long)，显然内存空间是不够的，直接导致未定义行为。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> c; <span class="comment">// c只是用来站位的，让代码更好看点</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> buffer[<span class="keyword">sizeof</span>(<span class="keyword">long</span>)];</span><br><span class="line">  <span class="keyword">long</span> *lp = ::<span class="keyword">new</span> (buffer) <span class="keyword">long</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码换了个方式，直接开辟内存大小为long类型大小的连续char内存空间，然后在这段空间上构造long类型对象，看似合理没问题了。当然，内存空间是保证能存放long类型对象了，但是之前还提到过，placement new返回的对象指针并没保证是以long对齐的，所以首先需要强制bufffer的内存空间是以long对齐，placement new所返回的指针才能以long对齐:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> c; <span class="comment">// c只是用来站位的，让代码更好看点</span></span><br><span class="line">  alignas(<span class="keyword">long</span>) <span class="keyword">unsigned</span> <span class="keyword">char</span> buffer[<span class="keyword">sizeof</span>(<span class="keyword">long</span>)];</span><br><span class="line">  <span class="keyword">long</span> *lp = ::<span class="keyword">new</span> (buffer) <span class="keyword">long</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码就没有任何问题了，当然，还有以下另一种方式来保证以long类型对齐:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> c; <span class="comment">// c只是用来站位的，让代码更好看点</span></span><br><span class="line">  <span class="built_in">std</span>::aligned_storage&lt;<span class="keyword">sizeof</span>(<span class="keyword">long</span>), <span class="keyword">alignof</span>(<span class="keyword">long</span>)&gt;::type buffer;</span><br><span class="line">  <span class="keyword">long</span> *lp = ::<span class="keyword">new</span> (&amp;buffer) <span class="keyword">long</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码样例对比-17"><a href="#代码样例对比-17" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  S ();</span><br><span class="line">  ~S ();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">unsigned</span> N = <span class="number">32</span>;</span><br><span class="line">  alignas(S) <span class="keyword">unsigned</span> <span class="keyword">char</span> buffer[<span class="keyword">sizeof</span>(S) * N];</span><br><span class="line">  S *sp = ::<span class="keyword">new</span> (buffer) S[N];</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// Destroy elements of the array.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != n; ++i) &#123;</span><br><span class="line">    sp[i].~S();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过了之前的代码样例对比，以上的代码就难以看出任何问题了，无论是内存空间大小和指针对齐都考虑了，但是还是有问题。这需要对C++的实现有一定理解，因为在有些编译器实现上可能会少计算了对象数组的overhead(可以简单理解为数组的cookie，一段不属于本身的额外内存)，这个cookie是存放对象数组元素个数的，这个有什么用呢？ 因为在用delete表达式删除对象数组的时候，需要用到对象数组的元素个数，还有就是在exception unwinding这样的机制中需要调用数组中每个成功构造了的元素的析构函数，这些都需要提前做记录，所以会有数组cookie。当然，可以强制避免编译器生成这样的cookie，所以以上代码没有任何手段来避免cookie的产生，为了避免意外情况发生，应该改成以下代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__clang__) || defined(__GNUG__)</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> overhead = <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">static_assert</span>(<span class="literal">false</span>, <span class="string">"you need to determine the size of your</span></span><br><span class="line"><span class="string">implementation's array overhead"</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> overhead = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// Declaration prevents additional diagnostics</span></span><br><span class="line">  <span class="comment">// about overhead being undefined; the value used</span></span><br><span class="line">  <span class="comment">// does not matter.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  S();</span><br><span class="line">  ~S();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span> n, <span class="keyword">void</span> *p, <span class="keyword">size_t</span> bufsize) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= bufsize) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">std</span>::bad_array_new_length();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> n = <span class="number">32</span>;</span><br><span class="line">  alignas(S) <span class="keyword">unsigned</span> <span class="keyword">char</span> buffer[<span class="keyword">sizeof</span>(S) * n + overhead];</span><br><span class="line">  S *sp = <span class="keyword">new</span> (buffer, <span class="keyword">sizeof</span>(buffer)) S[n];</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// Destroy elements of the array.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != n; ++i) &#123;</span><br><span class="line">    sp[i].~S();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码只针对了clang和gcc的实现作出了overhead的判断。如果是其他编译器得稍微作出修改了，需要断定其他编译器的数组overhead。所以还是少用placement new吧。</p>
<h3 id="MEM55-CPP-自定义动态内存管理函数时需要遵守其替换规范"><a href="#MEM55-CPP-自定义动态内存管理函数时需要遵守其替换规范" class="headerlink" title="MEM55-CPP. 自定义动态内存管理函数时需要遵守其替换规范"></a>MEM55-CPP. 自定义动态内存管理函数时需要遵守其替换规范</h3><p>严重程度:高。如果不满足替换动态内存管理函数的规范，那么自定义的内存管理函数会导致未定义行为。</p>
<p>C++标准是允许开发人员替换全局的动态内存分配和释放函数的。</p>
<p>比如有这样一个需求，开发人员想探测一个应用的动态内存使用率来判断默认的内存分配器是否对这个应用的场景是否合适，能否考虑更好的内存分配策略，C++标准[res.on.function]有如下声明:</p>
<blockquote>
<p>In certain cases (replacement functions, handler functions, operations on types used to<br>instantiate standard library template components), the C++ standard library depends on<br>components supplied by a C++ program. If these components do not meet their<br>requirements, the Standard places no requirements on the implementation.</p>
</blockquote>
<p>还有更具体点的:</p>
<blockquote>
<p>In particular, the effects are undefined in the following cases:</p>
</blockquote>
<blockquote>
<p>• for replacement functions, if the installed replacement function does not implement<br>the semantics of the applicable Required behavior: paragraph.</p>
</blockquote>
<h4 id="代码样例对比-18"><a href="#代码样例对比-18" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> *<span class="title">alloc_mem</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span></span>; <span class="comment">// Implemented elsewhere;</span></span><br><span class="line">  <span class="comment">// may return nullptr</span></span><br><span class="line">  <span class="keyword">return</span> alloc_mem(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *ptr)</span> <span class="keyword">noexcept</span></span>; <span class="comment">// Defined elsewhere</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">noexcept</span></span>; <span class="comment">// Defined elsewhere</span></span><br></pre></td></tr></table></figure>
<p>以上代码把全局的operator new(std::size_t)函数替换成自定义的实现了，然而，该实现却违反了替换的规范，如果自定义的分配器分配内存的时候失败了，那么该函数是返回了nullptr指针，而不是抛出std::bad_alloc的异常。所以，应该改成下面的版本:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> *<span class="title">alloc_mem</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span></span>; <span class="comment">// Implemented elsewhere;</span></span><br><span class="line">  <span class="comment">// may return nullptr</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">void</span> *ret = alloc_mem(size)) &#123;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="built_in">std</span>::bad_alloc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *ptr)</span> <span class="keyword">noexcept</span></span>; <span class="comment">// Defined elsewhere</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">noexcept</span></span>; <span class="comment">// Defined elsewhere</span></span><br></pre></td></tr></table></figure>
<h3 id="MEM56-CPP-不要把一个已拥有所属权的指针的值保存进一个无关的智能指针中"><a href="#MEM56-CPP-不要把一个已拥有所属权的指针的值保存进一个无关的智能指针中" class="headerlink" title="MEM56-CPP. 不要把一个已拥有所属权的指针的值保存进一个无关的智能指针中"></a>MEM56-CPP. 不要把一个已拥有所属权的指针的值保存进一个无关的智能指针中</h3><p>严重程度：高。可能资源早已被智能指针释放，但是还有用原裸指针访问原来的资源，间接造成未定义行为。</p>
<p>C++中的智能指针比如std::unique_ptr和std::shared_ptr实现了指针所属权的语义，所属权是C++类型系统的一部分。它们包装了指针的值，通过operator *() 和 operator -&gt;()成员函数提供了类似指针的语义。然后，指针所指向的对象的生命周期就与智能指针的对象的生命周期自动关联上了。</p>
<p>调用std::unique_ptr::release()会放弃被管理的指针值的所属权，析构，移动赋值，还有调用std::unique_ptr::reset()都会放弃之前指针的所属权。如果调用std::shared_ptr::unique()返回true，并且std::shared_ptr对象析构或者调用std::shared_ptr::reset()也会释放之前指针的所属权。</p>
<h4 id="代码样例对比-19"><a href="#代码样例对比-19" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *i = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p1(i);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p2(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上两个不同的std::shared_ptr指针都包装了指针i，所以当f()函数退出的时候，p1和p2就会析构，然后就造成了两次delete i 。 所以应该改成下面:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p1 = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p2(p1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码std::shared_ptr就能维护正确的引用计数了，直到引用计数为0才会释放所指向的资源。</p>
<h4 id="代码样例对比-20"><a href="#代码样例对比-20" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span><br><span class="line">  <span class="keyword">virtual</span> ~B() = <span class="keyword">default</span>; <span class="comment">// Polymorphic object</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span> :</span> B &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;D&gt; derived)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;B&gt; poly(<span class="keyword">new</span> D);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  g(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;D&gt;(<span class="keyword">dynamic_cast</span>&lt;D *&gt;(poly.get())));</span><br><span class="line">  <span class="comment">// Any use of poly will now result in accessing freed memory.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码poly智能指针所包装的裸指针被转换成了继承类D的指针然后又被多态类型的std::shared_ptr<d>所包装，然而，这样最终会导致未定义行为。因为一个同样的指针被保存到两个不同的std::shared_ptr对象中了，当g()函数退出时，std::shared_ptr<d>对象通过默认的deleter释放了所指向的资源，然而，等到f()也退出的时候，poly也同样释放了所指资源，同样的资源被释放两次，直接造成未定义行为。因为不同类型的std::shared_ptr不维护同样的引用计数。</d></d></p>
<p>所以要转换必须改成以下版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span><br><span class="line">  <span class="keyword">virtual</span> ~B() = <span class="keyword">default</span>; <span class="comment">// Polymorphic object</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span> :</span> B &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;D&gt; derived)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;B&gt; poly(<span class="keyword">new</span> D);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  g(<span class="built_in">std</span>::dynamic_pointer_cast&lt;D, B&gt;(poly));</span><br><span class="line">  <span class="comment">// poly is still referring to a valid pointer value.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码把dynamic_cast替换成了std::dynamic_pointer_cast()，这个函数就直接返回合法的shared pointer的多态类型，两个指针所持有的引用计数是一样的，直到引用计数为0才会释放，所以不会重复释放。</p>
<h4 id="代码样例对比-21"><a href="#代码样例对比-21" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;S&gt; g() &#123; <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;S&gt;(<span class="keyword">this</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;S&gt; s1 = <span class="built_in">std</span>::make_shared&lt;S&gt;();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;S&gt; s2 = s1-&gt;g();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码创建了一个S类型的对象，并把对象指针保存在了对象s1中，然后，又调用了S::g()，把s1指向的裸指针的值又包装到了另一个shared pointer中。然而，s2对象没有与s1关联上，所以没有维持共同的引用计数，导致所指向的资源释放了两次。应该改成下面:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> :</span> <span class="built_in">std</span>::enable_shared_from_this&lt;S&gt; &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;S&gt; g() &#123; <span class="keyword">return</span> shared_from_this(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;S&gt; s1 = <span class="built_in">std</span>::make_shared&lt;S&gt;();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;S&gt; s2 = s1-&gt;g();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码用了std::enable_shared_from_this::shared_from_this()来获取shared pointer，这个获得返回的shared pointer是与之前的s1对象关联上的，所以s1和s2维持了共同的引用计数，所以不会导致重复释放了。</p>
<h3 id="MEM57-CPP-避免使用默认的operator-new来生成超出对齐大小的类型"><a href="#MEM57-CPP-避免使用默认的operator-new来生成超出对齐大小的类型" class="headerlink" title="MEM57-CPP. 避免使用默认的operator new来生成超出对齐大小的类型"></a>MEM57-CPP. 避免使用默认的operator new来生成超出对齐大小的类型</h3><p>严重程度: 中等。使用对齐有问题的指针会导致未定义行为，一般现象是直接导致程序不正常终止。</p>
<p>CERT有以下描述，这部分没有翻译，为了准确性:</p>
<blockquote>
<p>The non-placement new expression is specified to invoke an allocation function to allocate<br>storage for an object of the specified type. When successful, the allocation function, in turn, is<br>required to return a pointer to storage with alignment suitable for any object with a fundamental<br>alignment requirement. Although the global operator new, the default allocation function<br>invoked by the new expression, is specified by the C++ standard [ISO/IEC 14882-2014] to<br>allocate sufficient storage suitably aligned to represent any object of the specified size, since the<br>expected alignment isn’t part of the function’s interface, the most a program can safely assume is<br>that the storage allocated by the default operator new defined by the implementation is<br>aligned for an object with a fundamental alignment. In particular, it is unsafe to use the storage for<br>an object of a type with a stricter alignment requirement—an over-aligned type.</p>
</blockquote>
<blockquote>
<p>Furthermore, the array form of the non-placement new expression may increase the amount of<br>storage it attempts to obtain by invoking the corresponding allocation function by an unspecified<br>amount. This amount, referred to as overhead in the C++ standard, is commonly known as a<br>cookie. The cookie is used to store the number of elements in the array so that the array delete<br>expression or the exception unwinding mechanism can invoke the type’s destructor on each<br>successfully constructed element of the array. While the specific conditions under which the<br>cookie is required by the array new expression aren’t described in the C++ standard, they may be<br>outlined in other specifications such as the application binary interface (ABI) document for the<br>target environment. For example, the Itanium C++ ABI describes the rules for computing the size<br>of a cookie, its location, and achieving the correct alignment of the array elements. When these<br>rules require that a cookie be created, it is possible to obtain a suitably aligned array of elements<br>of an overaligned type [CodeSourcery 2016a]. However, the rules are complex and the Itanium<br>C++ ABI isn’t universally applicable.</p>
</blockquote>
<h4 id="代码样例对比-22"><a href="#代码样例对比-22" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct <span class="title">alignas</span><span class="params">(<span class="number">32</span>)</span> Vector </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> elems[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Vector *<span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Vector *pv = <span class="keyword">new</span> Vector;</span><br><span class="line">  <span class="keyword">return</span> pv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码使用了默认的new表达式来分配并构造自定义的类型Vector，但是这个对齐超出了基本对齐的最大实现(一般是16字节)。一般来说当传入对齐不正常的参数就会进入陷阱(trap)的SIMD向量化指令是需要这样的超出对齐大小的类型的。应该改成以下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">struct <span class="title">alignas</span><span class="params">(<span class="number">32</span>)</span> Vector </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> elems[<span class="number">32</span>];</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> nbytes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">void</span> *p = <span class="built_in">std</span>::aligned_alloc(<span class="keyword">alignof</span>(Vector), nbytes)) &#123;</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">std</span>::bad_alloc();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Vector *<span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Vector *pv = <span class="keyword">new</span> Vector;</span><br><span class="line">  <span class="keyword">return</span> pv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码采用了重载的operator new并通过C11的函数aligned_alloc()获取合法的对齐内存。aligned_alloc()函数不属于C++ 98, C++ 11或 C++ 14 标准的任何一部分，但是这些标准都会把它作为一个扩展通过标准库提供出来。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://alexiachen.github.io/blog/2017/08/01/cert-cpp-five/" data-id="cjtctmcih009nqfqfww7l47n5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/C-C/">C/C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/CERT/">CERT</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-cert-cpp-four" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2017/08/01/cert-cpp-four/" class="article-date">
  <time datetime="2017-08-01T01:30:46.000Z" itemprop="datePublished">2017-08-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2017/08/01/cert-cpp-four/">CERT C++编码规范翻译（STR）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="字符串类"><a href="#字符串类" class="headerlink" title="字符串类"></a>字符串类</h2><h3 id="STR50-CPP-保证字符串类有足够的存储空间预留给字符数据和null结束符"><a href="#STR50-CPP-保证字符串类有足够的存储空间预留给字符数据和null结束符" class="headerlink" title="STR50-CPP. 保证字符串类有足够的存储空间预留给字符数据和null结束符"></a>STR50-CPP. 保证字符串类有足够的存储空间预留给字符数据和null结束符</h3><p>严重程度： 高。造成缓冲区溢出，攻击者运行任意代码。</p>
<p>C风格的字符串数组要求字符串结尾隐式包含一个null结束符(‘\0’)。但是C++的std::basic_string模版类就不需要null结束符。</p>
<h4 id="代码样例对比"><a href="#代码样例对比" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bad, 输入无边界，容器溢出</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">12</span>];</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////</span></span><br><span class="line"><span class="comment">// 还是不正确，bufOne不会溢出，但实际BufTwo会溢出</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> bufOne[<span class="number">12</span>];</span><br><span class="line">  <span class="keyword">char</span> bufTwo[<span class="number">12</span>];</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span>.width(<span class="number">12</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; bufOne;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; bufTwo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 以下就正确了</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> input;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> stringOne, stringTwo;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; stringOne &gt;&gt; stringTwo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码样例对比-1"><a href="#代码样例对比-1" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="built_in">std</span>::istream &amp;in)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buffer[<span class="number">32</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    in.read(buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (<span class="built_in">std</span>::ios_base::failure &amp;e) &#123;</span><br><span class="line">    <span class="comment">// Handle error</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(buffer)</span></span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码看似没有问题，read函数也传入sizeof了，std::basic_istream<t>::read()用来把文件的数据读入32个字节的buffer中，但是read()函数并不保证字符串会以null结束符结尾，所以接下来的调用std::string的构造函数，如果buffer不以null结尾那么会直接导致未定义行为。那么按照以下就好改正了:</t></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="built_in">std</span>::istream &amp;in)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buffer[<span class="number">32</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    in.read(buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (<span class="built_in">std</span>::ios_base::failure &amp;e) &#123;</span><br><span class="line">    <span class="comment">// Handle error</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(buffer, in.gcount())</span></span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相反插入null结束符，以上代码保证了明确的写入32个字符在str中，不用让std::string的构造函数自己遍历字符串判断，因为std::string之前的单参构造函数在没有遇到null结束符之前不会结束，会一直复制数据运行下去。</p>
<h3 id="STR51-CPP-构造std-string对象时，不要传入null指针"><a href="#STR51-CPP-构造std-string对象时，不要传入null指针" class="headerlink" title="STR51-CPP. 构造std::string对象时，不要传入null指针"></a>STR51-CPP. 构造std::string对象时，不要传入null指针</h3><p>严重程度: 高。  解引用空指针是未定义行为，典型的一个现象就是程序非正常终止。</p>
<p>std::basic_string使用了traits的设计模式来处理不同的字符串类型。尤其std::basic_string是配合std::char_traits来创建的std::string, std::wstring, std::u16string和<br>std::u32string等字符串类，其中std::char_traits::length()函数一般是用来决定在null结尾的字符串中的字符个数的。以下std::basic_string成员函数的调用都会间接导致std::char_traits::length()函数的调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">basic_string::basic_string(<span class="keyword">const</span> charT *, <span class="keyword">const</span> Allocator &amp;)</span><br><span class="line">basic_string &amp;basic_string::append(<span class="keyword">const</span> charT *)</span><br><span class="line">basic_string &amp;basic_string::assign(<span class="keyword">const</span> charT *)</span><br><span class="line">basic_string &amp;basic_string::insert(size_type, <span class="keyword">const</span> charT *)</span><br><span class="line">basic_string &amp;basic_string::replace(size_type, size_type,</span><br><span class="line"><span class="keyword">const</span> charT *)</span><br><span class="line">basic_string &amp;basic_string::replace(const_iterator,</span><br><span class="line">const_iterator, <span class="keyword">const</span> charT *)</span><br><span class="line">size_type basic_string::find(<span class="keyword">const</span> charT *, size_type)</span><br><span class="line">size_type basic_string::rfind(<span class="keyword">const</span> charT *, size_type)</span><br><span class="line">size_type basic_string::find_first_of(<span class="keyword">const</span> charT *,</span><br><span class="line">size_type)</span><br><span class="line">size_type basic_string::find_last_of(<span class="keyword">const</span> charT *, size_type)</span><br><span class="line">size_type basic_string::find_first_not_of(<span class="keyword">const</span> charT *,</span><br><span class="line">size_type)</span><br><span class="line">size_type basic_string::find_last_not_of(<span class="keyword">const</span> charT *,</span><br><span class="line">size_type)</span><br><span class="line"><span class="keyword">int</span> basic_string::compare(<span class="keyword">const</span> charT *)</span><br><span class="line"><span class="keyword">int</span> basic_string::compare(size_type, size_type, <span class="keyword">const</span> charT *)</span><br><span class="line">basic_string &amp;basic_string::<span class="keyword">operator</span>=(<span class="keyword">const</span> charT *)</span><br><span class="line">basic_string &amp;basic_string::<span class="keyword">operator</span>+=(<span class="keyword">const</span> charT *)</span><br></pre></td></tr></table></figure>
<p>以下std::basic_string的非成员函数都会间接导致std::char_traits::length()函数的调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">basic_string <span class="keyword">operator</span>+(<span class="keyword">const</span> charT *, <span class="keyword">const</span> basic_string&amp;)</span><br><span class="line">basic_string <span class="keyword">operator</span>+(<span class="keyword">const</span> charT *, basic_string &amp;&amp;)</span><br><span class="line">basic_string <span class="keyword">operator</span>+(<span class="keyword">const</span> basic_string &amp;, <span class="keyword">const</span> charT *)</span><br><span class="line">basic_string <span class="keyword">operator</span>+(basic_string &amp;&amp;, <span class="keyword">const</span> charT *)</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> charT *, <span class="keyword">const</span> basic_string &amp;)</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> basic_string &amp;, <span class="keyword">const</span> charT *)</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> charT *, <span class="keyword">const</span> basic_string &amp;)</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> basic_string &amp;, <span class="keyword">const</span> charT *)</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> charT *, <span class="keyword">const</span> basic_string &amp;)</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> basic_string &amp;, <span class="keyword">const</span> charT *)</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> charT *, <span class="keyword">const</span> basic_string &amp;)</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> basic_string &amp;, <span class="keyword">const</span> charT *)</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;=(<span class="keyword">const</span> charT *, <span class="keyword">const</span> basic_string &amp;)</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;=(<span class="keyword">const</span> basic_string &amp;, <span class="keyword">const</span> charT *)</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&gt;=(<span class="keyword">const</span> charT *, <span class="keyword">const</span> basic_string &amp;)</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&gt;=(<span class="keyword">const</span> basic_string &amp;, <span class="keyword">const</span> charT *)</span><br></pre></td></tr></table></figure>
<p>所以在调用以上提及的函数时不能在const charT* 传入null指针，统统会导致对null指针的解引用。</p>
<p>下面提一下各种标准库的实现细节：</p>
<blockquote>
<p>如果是stdlibc++ 调用以上函数传入了null指针，会主动抛std::logic_error的异常，但是直接调用std::char_traits::length()函数时就不会。然而，对于这样的情况抛std::loginc_error C++标准并没有作出要求。另一些标准库厂商，libc++和Visual Studio STL的实现上来看，就没有实现上述跑异常的行为，所以你不能对此严重的错误作出任何指望。</p>
</blockquote>
<h4 id="代码样例对比-2"><a href="#代码样例对比-2" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">tmp</span><span class="params">(<span class="built_in">std</span>::getenv(<span class="string">"TMP"</span>))</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (!tmp.empty()) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码试图通过std::getenv得到环境变量的值，但是如果没有此环境变量该函数会返回null指针以表示失败，所以这就导致了std::string的构造函数发生了未定义行为。应该改成以下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span> *tmpPtrVal = <span class="built_in">std</span>::getenv(<span class="string">"TMP"</span>);</span><br><span class="line">   <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">tmp</span><span class="params">(tmpPtrVal ? tmpPtrVal : <span class="string">""</span>)</span></span>;</span><br><span class="line">   <span class="keyword">if</span> (!tmp.empty()) &#123;</span><br><span class="line">     <span class="comment">// ...</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="STR52-CPP-使用合法的引用，指针和迭代器来指向std-basic-string的元素"><a href="#STR52-CPP-使用合法的引用，指针和迭代器来指向std-basic-string的元素" class="headerlink" title="STR52-CPP. 使用合法的引用，指针和迭代器来指向std::basic_string的元素"></a>STR52-CPP. 使用合法的引用，指针和迭代器来指向std::basic_string的元素</h3><p>严重程度：高。</p>
<p>因为std::basic_string本质上就是是字符容器，你可以简单看成用std::vector<char>实现了std::basic_string。所以该条规则是CTR51-CPP规则的一条特例。因此不作过多讨论。</char></p>
<h3 id="STR53-CPP-访问字符串元素时检查下标范围"><a href="#STR53-CPP-访问字符串元素时检查下标范围" class="headerlink" title="STR53-CPP. 访问字符串元素时检查下标范围"></a>STR53-CPP. 访问字符串元素时检查下标范围</h3><p>严重程度：高</p>
<p>此条款是CTR50-CPP规则的一条特例，所以不作过多讨论。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://alexiachen.github.io/blog/2017/08/01/cert-cpp-four/" data-id="cjtctmceh0006qfqfoklh3rsf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/C-C/">C/C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/CERT/">CERT</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-sync-async-block-nonblock" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2017/07/27/sync-async-block-nonblock/" class="article-date">
  <time datetime="2017-07-27T01:30:35.000Z" itemprop="datePublished">2017-07-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2017/07/27/sync-async-block-nonblock/">再次理解同步异步和阻塞非阻塞</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p><em>唉，涉及到网络IO和文件IO的时候又把这些概念混淆了。</em></p>
</blockquote>
<hr>
<h3 id="从编程角度阐释"><a href="#从编程角度阐释" class="headerlink" title="从编程角度阐释"></a>从编程角度阐释</h3><p>异步与同步与单线程或多线程都无关，是以任务的执行顺序有关，是更加高层次的抽象概念，下面以线程举例子：</p>
<p>同步（一个任务的开始必须依赖另一个任务的完成）</p>
<ul>
<li><p>单线程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 thread: / &lt;- Task 1 -&gt; / |</span><br><span class="line">                           | / &lt;- Task 2 -&gt; / |</span><br><span class="line">                                              | / &lt;---- Task 3 ----&gt; / |</span><br></pre></td></tr></table></figure>
<ul>
<li>多线程：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread A: -&gt; / &lt;- Task 1 -&gt; / |</span><br><span class="line">thread B: ----------------&gt;   | -&gt; / &lt;--- Task 2 ---&gt; / |</span><br><span class="line">thread C: --------------------------------------&gt;       | -&gt; / &lt;- Task 3 -&gt; /</span><br></pre></td></tr></table></figure>
<p>异步（一个任务的开始不必依赖另一个任务的完成）</p>
<ul>
<li>单线程：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 thread : / &lt;---------- Task 1 ----------&gt; /</span><br><span class="line">                            / &lt;---- Task 2 ---&gt; /</span><br><span class="line">                    / &lt;---- Task 3 ----&gt; /</span><br></pre></td></tr></table></figure>
<ul>
<li>多线程：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread A: -&gt; / &lt;- Task 1 -&gt; /</span><br><span class="line">thread B: -----&gt; / &lt;-------- Task 2 --------&gt; /</span><br><span class="line">thread C: -----------&gt; / &lt;- Task 3 -&gt; /</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>所以说，单线程也可以异步，多线程也可以同步。在多线程同步中，一个线程需要等待另一个线程的完成，所以会阻塞当前线程（操作系统会挂起当前线程），也就是多线程同步过程中，一般会有阻塞。单线程同步一般就不会有阻塞，所以在Socket编程中，在创建socket的时候，一般有block和non-block选项，系统会为了等待数据阻塞当前等待数据的线程，并由其他读取数据完毕的线程唤醒等待的recv线程，而继续运行。如果是选择non-block，那么等待数据的线程不会被挂起，无论网络数据是否到达会继续recv返回执行，需要调用者不停地轮询数据是否到达，到达再读取。</p>
<p>block和non-block也只是概念，它的底层大部分是由锁来实现的，是锁概念的延伸和高层次的概念映射，比如读写锁，如果写锁被上锁了，那么读操作会被阻塞（读线程被挂起），等到写锁释放，才能继续读。所以，在谈到block和non-block的时候就会涉及到多线程的概念，肯定底层会有多线程的操作。单线程是不可能有阻塞和非阻塞的概念的。</p>
<p>当然，有人说node.js中的readFile和readFileSync就分别是是异步非阻塞和同步阻塞。而node是单线程的为什么会有block和non-block的概念？因为涉及到阻塞和非阻塞一般是底层可能会有多线程处理IO的操作，nodejs的应用层面是看不到的，因为阻塞的线程是不会自动醒来的，必须要另一个线程来唤醒（Resume）以提示IO的完成。也就是nodejs的应用代码确实是单线程执行的，但是在发起文件IO的时候，肯定会有个IO线程来对文件进行读写，最后通知应用层的js代码。其实以上的说法是不准确的，因为对于文件读写是没有非阻塞这以说法的，因为底层肯定会有阻塞操作等待数据读进缓冲区，还是有锁来阻塞。所以在谈及文件IO的时候我们一般只谈及同步和异步，在谈及网络IO的时候只谈及阻塞和非阻塞。</p>
<p>当然我也觉得<a href="https://www.zhihu.com/question/19732473" target="_blank" rel="noopener">同步异步和阻塞非阻塞不能单从字面意义上理解</a>。同步和异步关注的是消息通信机制，所谓同步就是caller主动等待callee的结果，也就是说在没有得到调用结果之前，callee就不返回，一旦callee返回了，一定得到返回结果了。异步正好相反，callee被调用之后，caller对于callee的调用就直接返回了，callee通过状态，或者消息，回调函数等机制来把调用的处理结果通知给caller。</p>
<p>阻塞和非阻塞关注的是caller在等待调用结果（返回值，消息等）时的状态，也就是caller当时的状态。阻塞调用是指callee的被调用结果返回之前，当前的caller线程会被挂起，只有得到结果了，callee才会返回，caller线程被唤醒并继续执行。非阻塞调用是指callee不能得到结果之前，对callee的调用不会阻塞caller的当前线程。</p>
<p>据知乎上的<a href="https://www.zhihu.com/people/giantchen" target="_blank" rel="noopener">陈硕</a>所说，在处理 IO 的时候，阻塞和非阻塞都是同步 IO。只有使用了特殊的 API 才是异步 IO。</p>
<p><img src="http://wx4.sinaimg.cn/large/a1ac93f3gy1fi3136mbg4j20bj046t8m.jpg" alt=""></p>
<p>怎样理解他这句话呢？《Unix网络编程》这大部经典著作其中有段原文：</p>
<blockquote>
<p>POSIX defines these two terms as follows:</p>
</blockquote>
<blockquote>
<ul>
<li>A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>An asynchronous I/O operation does not cause the requesting process to be blocked.</li>
</ul>
</blockquote>
<blockquote>
<p>Using these definitions, the first four I/O models—blocking, nonblocking, I/O multiplexing, and signal-driven I/O—are all synchronous because the actual I/O operation (recvfrom) blocks the process. Only the asynchronous I/O model matches the asynchronous I/O definition.</p>
</blockquote>
<p>简单来说就是，对Unix-Like的系统来讲：阻塞式I/O(默认)，非阻塞式I/O(nonblock)，I/O复用(select/poll/epoll)都属于同步I/O，因为它们在数据由内核空间复制回进程缓冲区时都是阻塞的(不能干别的事)。只有异步I/O模型(AIO)是符合异步I/O操作的含义的，即在1数据准备完成、2由内核空间拷贝回缓冲区后 通知进程，在等待通知的这段时间里可以干别的事。</p>
<h3 id="Reactor模式和Proactor模式"><a href="#Reactor模式和Proactor模式" class="headerlink" title="Reactor模式和Proactor模式"></a>Reactor模式和Proactor模式</h3><p>通常我们谈论事件驱动思想的时候会提到这两个模式，那么这两个模式到底有什么区别呢？</p>
<p>在Unix标准中的同步IO中的非阻塞IO，也就是NIO（non-block IO），就是基于事件驱动思想的，实现上采用<a href="https://en.wikipedia.org/wiki/Reactor_pattern" target="_blank" rel="noopener">Reactor模式</a>，从程序角度而言，当发起IO的读或写操作时，是非阻塞的；当Socket有流可读或可写入Socket时，操作系统会相应地通知应用程序进行处理，应用再将流读取到缓冲区或写入操作系统。对于网络IO而言，主要有连接建立、流读取及流写入三种事件，Linux 2.6以后的版本采用epoll 方式来实现NIO。</p>
<p>对于另一种异步IO，也就是AIO（asyn IO），同样是基于事件驱动的思想，实现上通常采用<a href="https://en.wikipedia.org/wiki/Proactor_pattern" target="_blank" rel="noopener">Proactor模式</a>。从程序角度而言，和NIO不同，当进行读写操作时，只需要直接调用API的read或write方法即可。这两种方法均为异步，对于读操作而言，当有流可读取时，操作系统会将可读的流传入read方法的缓冲区，并通知应用程序。对于写操作而言，当操作系统将write方法的流写入完毕时，操作系统主动通知应用程序。与NIO比较而言，AIO一方面简化了程序的编写，流的读取和写入都由操作系统来代替完成，另一方面省去了NIO中程序遍历事件通知队列的代价。windows基于<a href="https://en.wikipedia.org/wiki/Input/output_completion_port" target="_blank" rel="noopener">IOCP</a>实现了AIO，对，IOCP就是异步的，但是Linux目前只有基于Epoll模拟实现的AIO。显然，Linux从Epoll到AIO有一层转换，就是用同步的Epoll来模拟异步，Epoll是Reactor模式，AIO是Proactor模式。  所以这两个模式的关系，你可以简单理解为，Proactor模式是同步Reactor模式的异步体现，Proactor模式的层次更高，简化了程序编写。从复杂度来将，Reactor更反人类，因为Reactor是通知程序员有数据可以读写了，程序员再主动读写数据。Proactor模式是数据读写完毕了，再主动通知程序员。</p>
<p>需要注意的一点就是Reactor模式一般是单线程实现，几乎所有的Reactor实现的系统都是单线程的，尽管Reactor模式也可以工作在多线程环境下，因为Proactor模式是Reactor的异步形式的变种，所以Proactor模式一般也是单线程实现的，而非多线程。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://alexiachen.github.io/blog/2017/07/27/sync-async-block-nonblock/" data-id="cjtctmcfn0029qfqfk7fwv53g" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/IO/">IO</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/同步异步/">同步异步</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/阻塞非阻塞/">阻塞非阻塞</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-cert-cpp-three" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2017/07/19/cert-cpp-three/" class="article-date">
  <time datetime="2017-07-19T06:30:46.000Z" itemprop="datePublished">2017-07-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2017/07/19/cert-cpp-three/">CERT C++编码规范翻译（CTR）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="容器类"><a href="#容器类" class="headerlink" title="容器类"></a>容器类</h2><h3 id="CTR50-CPP-保证容器的索引和迭代器在合法的范围内"><a href="#CTR50-CPP-保证容器的索引和迭代器在合法的范围内" class="headerlink" title="CTR50-CPP. 保证容器的索引和迭代器在合法的范围内"></a>CTR50-CPP. 保证容器的索引和迭代器在合法的范围内</h3><p>严重程度： 高。 会导致任意内存地址的数据被覆盖，从而导致程序不正常终止。</p>
<p>这个主要内容没什么可以说明的。越界一定是开发人员的错。</p>
<h4 id="代码样例对比"><a href="#代码样例对比" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_in_table</span><span class="params">(<span class="keyword">int</span> *table, <span class="built_in">std</span>::<span class="keyword">size_t</span> tableSize, <span class="keyword">int</span> pos, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (pos &gt;= tableSize) &#123;</span><br><span class="line">    <span class="comment">// Handle error</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  table[pos] = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上的代码实现是需要在一个table的特定下标插入一个值。函数还有个下标检测的越界判断，看似合理。但是pos参数被声明了为int，int类型是默认有符号数，而tableSize的类型是无符号的std::size_t，这两个类型比较在某些极端情况下会失效。一旦pos被不小心赋值为负数，那么if判断失效，导致table访问越界。所以改成以下为好:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_in_table</span><span class="params">(<span class="keyword">int</span> *table, <span class="built_in">std</span>::<span class="keyword">size_t</span> tableSize, <span class="built_in">std</span>::<span class="keyword">size_t</span></span></span></span><br><span class="line"><span class="function"><span class="params">pos, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (pos &gt;= tableSize) &#123;</span><br><span class="line"><span class="comment">// Handle error</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">table[pos] = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>pos最好也声明为std:size_t，这样就可以防止负数被传入进函数了。</p>
<p>还可以用以下办法:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_in_table</span><span class="params">(<span class="keyword">int</span> *table, <span class="built_in">std</span>::<span class="keyword">size_t</span> tableSize, <span class="built_in">std</span>::<span class="keyword">size_t</span> pos, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// #1</span></span><br><span class="line">  <span class="keyword">if</span> (pos &gt;= tableSize) &#123;</span><br><span class="line">    <span class="comment">// Handle error</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  table[pos] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="built_in">std</span>::<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_in_table</span><span class="params">(<span class="keyword">int</span> (&amp;table)[N], <span class="built_in">std</span>::<span class="keyword">size_t</span> pos, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// #2</span></span><br><span class="line">  insert_in_table(table, N, pos, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Exposition only</span></span><br><span class="line">  <span class="keyword">int</span> table1[<span class="number">100</span>];</span><br><span class="line">  <span class="keyword">int</span> *table2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">  insert_in_table(table1, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// Calls #2</span></span><br><span class="line">  insert_in_table(table2, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// Error, no matching func. call</span></span><br><span class="line">  insert_in_table(table1, <span class="number">100</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// Calls #1</span></span><br><span class="line">  insert_in_table(table2, <span class="number">100</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// Calls #1</span></span><br><span class="line">  <span class="keyword">delete</span> [] table2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码是使用无类型模版的手段把数组越界检测提前到编译时。</p>
<h4 id="代码样列对比-std-vector"><a href="#代码样列对比-std-vector" class="headerlink" title="代码样列对比(std::vector)"></a>代码样列对比(std::vector)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_in_table</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;table, <span class="keyword">long</span> <span class="keyword">long</span> pos, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (pos &gt;= table.size()) &#123;</span><br><span class="line">    <span class="comment">// Handle error</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  table[pos] = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上的代码与之前一个的代码样例中所反映的问题是一样的。long long类型的pos是有符号类型，比较可能失效，导致越界。应该改成:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_in_table</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;table, <span class="built_in">std</span>::<span class="keyword">size_t</span> pos, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (pos &gt;= table.size()) &#123;</span><br><span class="line">    <span class="comment">// Handle error</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  table[pos] = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实还可以巧妙利用vector的at成员函数来访问特定下标，这个成员函数提供越界检测，越界会抛出std::out_of_range的异常：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_in_table</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;table, <span class="built_in">std</span>::<span class="keyword">size_t</span> pos, <span class="keyword">int</span> value)</span> <span class="title">noexcept</span><span class="params">(<span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">  table.at(pos) = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于insert_in_table 之后声明有noexcept(false)，就是表明该函数可能抛出异常，遵循C++的Honor Exception Spec。 当然不写也可以，但是最好是写上。</p>
<h4 id="代码样例对比-iterators"><a href="#代码样例对比-iterators" class="headerlink" title="代码样例对比(iterators)"></a>代码样例对比(iterators)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f_imp</span><span class="params">(ForwardIterator b, ForwardIterator e, <span class="keyword">int</span> val,<span class="built_in">std</span>::forward_iterator_tag)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    *b++ = val;</span><br><span class="line">  &#125; <span class="keyword">while</span> (b != e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(ForwardIterator b, ForwardIterator e, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;ForwardIterator&gt;::iterator_category cat;</span><br><span class="line">  f_imp(b, e, val, cat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上对于f_imp函数通过迭代器访问一个容器，参数e是end迭代器，假设e永远是传入正确的，但是也会造成迭代器解引用错误，因为一旦容器是空的，参数b就等于e。但是do while循环是先计算，后比较。这就引入问题了，所以得改成以下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f_imp</span><span class="params">(ForwardIterator b, ForwardIterator e, <span class="keyword">int</span> val,<span class="built_in">std</span>::forward_iterator_tag)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (b != e) &#123;</span><br><span class="line">    *b++ = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(ForwardIterator b, ForwardIterator e, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;ForwardIterator&gt;::iterator_category cat;</span><br><span class="line">  f_imp(b, e, val, cat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先比较迭代器的合法性，再进行解引用b。</p>
<h3 id="CTR51-CPP-使用合法的引用，指针，迭代器来引用容器的元素"><a href="#CTR51-CPP-使用合法的引用，指针，迭代器来引用容器的元素" class="headerlink" title="CTR51-CPP. 使用合法的引用，指针，迭代器来引用容器的元素"></a>CTR51-CPP. 使用合法的引用，指针，迭代器来引用容器的元素</h3><p>严重等级：高。一旦持有一个不合法的引用并进行访问容器，那么就直接导致未定义行为。</p>
<p>迭代器就是指针的泛化。它允许通过统一的方式来访问不同的数据结构容器。</p>
<p>C++标准[container.requirements.general]有如下声明：</p>
<blockquote>
<p>Unless otherwise specified (either explicitly or by defining a function in terms of other functions), invoking a container member function or passing a container as an argument to a library function shall not invalidate iterators to, or change the values of, objects within that container.</p>
</blockquote>
<p>也就是说，C++标准是允许引用和指针无效化的，当你通过容器类提供的操作函数。举个例子，当你从容器中得到一个指向某元素的指针，然后erase了那个元素，然后又在删除元素的位置insert一个新的元素，就会导致现存的指针虽然合法，但是指向了不同的对象。所以任何操作都可能会使指针或引用无效化，要慎重对待。</p>
<p>以下列出容器的哪些操作会使引用，指针，迭代器无效化。</p>
<ul>
<li><p>std::queue  insert() emplace_front() emplace_back() emplace() push_front() push_back() erase() pop_back() resize() clear()</p>
</li>
<li><p>std::forward_list erase_after() pop_front() resize() remove() unique() clear()</p>
</li>
<li><p>std::list earse() pop_front() pop_back() clear() remove() remove_if() unique() </p>
</li>
<li><p>std::vector reserve() insert() emplace_back() emplace() push_back() erase() pop_back() resize() clear()</p>
</li>
<li><p>std::set,std::multiset std::map std::multimap earse() clear()</p>
</li>
<li><p>std::unordered_set std::unordered_multiset std::unordered_map std::unordered_multimap erase() clear() insert() emplace() rehash() reserve() </p>
</li>
<li><p>std::valarray resize()</p>
</li>
</ul>
<h4 id="代码样例对比-1"><a href="#代码样例对比-1" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> *items, <span class="built_in">std</span>::<span class="keyword">size_t</span> count)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">double</span>&gt; d;</span><br><span class="line">  <span class="keyword">auto</span> pos = d.begin();</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i, ++pos) &#123;</span><br><span class="line">    d.insert(pos, items[i] + <span class="number">41.0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码在第一次调用insert的时候pos迭代器失效了，所以就导致后续的循环导致未定义行为。可以通过插入后更新失效迭代器杜绝未定义行为:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> *items, <span class="built_in">std</span>::<span class="keyword">size_t</span> count)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">double</span>&gt; d;</span><br><span class="line">  <span class="keyword">auto</span> pos = d.begin();</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i, ++pos) &#123;</span><br><span class="line">    pos = d.insert(pos, items[i] + <span class="number">41.0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一种通过泛型算法的方案来解决迭代器失效的问题:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> *items, <span class="built_in">std</span>::<span class="keyword">size_t</span> count)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">double</span>&gt; d;</span><br><span class="line">  <span class="built_in">std</span>::transform(items, items + count, <span class="built_in">std</span>::inserter(d, d.begin()),</span><br><span class="line">    [](<span class="keyword">double</span> d) &#123; <span class="keyword">return</span> d + <span class="number">41.0</span>; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CTR52-CPP-保证库函数不溢出"><a href="#CTR52-CPP-保证库函数不溢出" class="headerlink" title="CTR52-CPP. 保证库函数不溢出"></a>CTR52-CPP. 保证库函数不溢出</h3><p>严重程度: 高。buffer overflow会导致攻击者经过一定的构造条件执行任意的恶意代码</p>
<p>把数据拷贝到不足够放下数据的容器会导致buffer overflow，覆写不合法的内存区块。避免这样的问题，需要限制目标容器的size，最好与数据的size一样大。或者更大一点也可以。</p>
<p>在C语言时代，std::memcpy std::memmove std::memset都可能导致内存区块被覆盖，而且它们不检测内存区块的合法性。所以建议使用C++ STL中提供的std::copy std::fill std::transform等函数来操作,尽管使用C++ 的STL也可以同样导致buffer overflow。</p>
<h4 id="代码样例对比-2"><a href="#代码样例对比-2" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;src)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dest;</span><br><span class="line">  <span class="built_in">std</span>::copy(src.begin(), src.end(), dest.begin());</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然dest是动态数组会随着push append增加存储空间，但是上面代码使用了std::copy，该函数不会扩展dest的空间，所以在拷贝src中第一个元素的时候，dest就buffer overflow了。</p>
<p>所以就有了以下方案解决，初始化dest的时候就把它的存储空间扩大到与src一样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;src)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Initialize dest with src.size() default-inserted elements</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dest(src.size());</span><br><span class="line">  <span class="built_in">std</span>::copy(src.begin(), src.end(), dest.begin());</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，还有一个方案，就是用std::back_insetr_iterator作为目标参数。这个迭代器它会根据std::copy这个算法一个一个拷贝元素的时候，自动扩展复制目标容器，这就保证目标容器与源容器一样大。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;src)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dest;</span><br><span class="line">  <span class="built_in">std</span>::copy(src.begin(), src.end(), <span class="built_in">std</span>::back_inserter(dest));</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最简单的是用vector提供的拷贝构造函数:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;src)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dest(src);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码样例对比-3"><a href="#代码样例对比-3" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">  <span class="built_in">std</span>::fill_n(v.begin(), <span class="number">10</span>, <span class="number">0x42</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上这个代码意图让填充10个0x42在vector中，但是vector默认没分配空间，这样直接填充就造成buffer overflow。改成以下方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(<span class="number">10</span>);</span><br><span class="line">  <span class="built_in">std</span>::fill_n(v.begin(), <span class="number">10</span>, <span class="number">0x42</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(<span class="number">10</span>, <span class="number">0x42</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CTR53-CPP-使用合法的迭代器范围"><a href="#CTR53-CPP-使用合法的迭代器范围" class="headerlink" title="CTR53-CPP. 使用合法的迭代器范围"></a>CTR53-CPP. 使用合法的迭代器范围</h3><p>严重程度： 高。造成buffer overflow，导致运行任意代码</p>
<p>当迭代器遍历一个容器的时候，迭代器必须处于一个合法范围，一个迭代器的范围是一对迭代器，其中一个指向第一个元素，另一个指向最后一个元素的后一位。这两个迭代器形成的范围，就是合法的迭代器范围。</p>
<p>一个合法的迭代器范围需要包含以下所有特征：</p>
<ul>
<li>所有的迭代器必须指向同一个容器</li>
<li>迭代器指向容器的开始和结尾</li>
</ul>
<p>一个空的迭代器范围也是合法的（开始迭代器和尾部迭代器相等）</p>
<p>使用两个迭代器分别指向不同的容器，会导致未定义行为。</p>
<h4 id="代码样例对比-4"><a href="#代码样例对比-4" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;c)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::for_each(c.end(), c.begin(), [](<span class="keyword">int</span> i) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码看似正确了，但是for_each的第一参数需要是容器的begin迭代器，而它设成了end。整个迭代器反了。而且end迭代器指向的是最后一个元素的后一位，一旦解引用，立即造成未定义行为。应该改成以下正确的迭代顺序:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;c)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::for_each(c.begin(), c.end(), [](<span class="keyword">int</span> i) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你非得需要反向迭代，那么可以这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;c)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::for_each(c.rbegin(), c.rend(), [](<span class="keyword">int</span> i) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码样例对比-5"><a href="#代码样例对比-5" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;c)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator e;</span><br><span class="line">  <span class="built_in">std</span>::for_each(c.begin(), e, [](<span class="keyword">int</span> i) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码明显这两个迭代器指向了不同的容器，但是由于STL的实现原因，编译器检测不出来这样的语义错误，没有任何的标准表明迭代器e会初始化为容器c的end()迭代器。这个知道原因后，就知道怎么改了，改成以上的代码样例对比就可以了，不作示范。</p>
<h3 id="CTR54-CPP-没有指向相同容器的迭代器之间不要做减法"><a href="#CTR54-CPP-没有指向相同容器的迭代器之间不要做减法" class="headerlink" title="CTR54-CPP. 没有指向相同容器的迭代器之间不要做减法"></a>CTR54-CPP. 没有指向相同容器的迭代器之间不要做减法</h3><p>严重程度：中等。</p>
<p>这个与指针本质一样。如果指针指向不同的对象数组，它们之间也不能做减法。类似std:distance就是两个迭代器做减法，需要迭代器指向同一个容器。如果不这么做，那么会直接导致未定义行为。</p>
<h4 id="代码样例对比-6"><a href="#代码样例对比-6" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Ty&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">in_range</span><span class="params">(<span class="keyword">const</span> Ty *test, <span class="keyword">const</span> Ty *r, <span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span> &lt; (test - r) &amp;&amp; (test - r) &lt; (<span class="built_in">std</span>::<span class="keyword">ptrdiff_t</span>)n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> foo[<span class="number">10</span>];</span><br><span class="line">  <span class="keyword">double</span> *x = &amp;foo[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">double</span> bar;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::boolalpha &lt;&lt; in_range(&amp;bar, x, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码意图测试指针test，是否在[r,r+n]这个迭代器范围内，然而test并没有指向这个合法的范围容器中，所以test与r相减导致未定义行为。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Ty&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">in_range</span><span class="params">(<span class="keyword">const</span> Ty *test, <span class="keyword">const</span> Ty *r, <span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> test &gt;= r &amp;&amp; test &lt; (r + n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> foo[<span class="number">10</span>];</span><br><span class="line">  <span class="keyword">double</span> *x = &amp;foo[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">double</span> bar;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::boolalpha &lt;&lt; in_range(&amp;bar, x, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码试图整改，用比较运算符让test和r不必做减法，但是还是有问题的。因为C++标准有以下描述:</p>
<blockquote>
<p>If two operands p and q compare equal, p&lt;=q and p&gt;=q both yield true and p<q and="" p="">q both yield false. Otherwise, if a pointer p compares greater than a pointer q, p&gt;=q, p&gt;q, q&lt;=p, and q&lt;p all yield true and p&lt;=q, p&lt;q, q&gt;=p, and q&gt;p all yield false. Otherwise, the result of each of the operators is unspecified.</q></p>
</blockquote>
<p>所以比较两个不指向同一个容器的指针会导致未指定行为(unspecified hebavior)。尽管与之前的代码有所改善,但是还是不会产生可移植性的代码，可能在其他的硬件平台上就会失败(x86以外的平台)。然后我们再来改进以上代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandIter&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">in_range_impl</span><span class="params">(RandIter test, RandIter r_begin, RandIter r_end,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="built_in">std</span>::random_access_iterator_tag)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> test &gt;= r_begin &amp;&amp; test &lt; r_end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">in_range</span><span class="params">(Iter test, Iter r_begin, Iter r_end)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;Iter&gt;::iterator_category cat;</span><br><span class="line">  <span class="keyword">return</span> in_range_impl(test, r_begin, r_end, cat);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; foo(<span class="number">10</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; bar(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::boolalpha &lt;&lt; in_range(bar.begin(), foo.begin(), foo.end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码几乎等价于之前的代码片段，仅仅只是用迭代器代替了裸指针，当两个迭代器没有引用相同的容器并且互相进行比较运算的时候，还是会出现未指定行为。下面我们还是再来改进以上代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Ty&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">in_range</span><span class="params">(<span class="keyword">const</span> Ty *test, <span class="keyword">const</span> Ty *r, <span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::less&lt;<span class="keyword">const</span> Ty *&gt; less;</span><br><span class="line">  <span class="keyword">return</span> !less(test, r) &amp;&amp; less(test, r + n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> foo[<span class="number">10</span>];</span><br><span class="line">  <span class="keyword">double</span> *x = &amp;foo[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">double</span> bar;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::boolalpha &lt;&lt; in_range(&amp;bar, x, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码用STL中的std::less&lt;&gt;来代替比较操作运算符。但是C++标准[comparisons]有如下声明:</p>
<blockquote>
<p> For templates greater, less, greater_equal, and less_equal, the specializations for any pointer type yield a total order, even if the built-in operators &lt;, &gt;, &lt;=, &gt;= do not.</p>
</blockquote>
<p>也就是这种方法是依赖实现的，实现不确定。结果是，以上代码还是没有移植性，std::less&lt;&gt;中如果还是有比较运算，那么同样会导致未定义行为。下面我们用另一种不会出现任何问题的方法来达到我们的目的，无非就是损失点性能。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Ty&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">in_range</span><span class="params">(<span class="keyword">const</span> Ty *test, <span class="keyword">const</span> Ty *r, <span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> *cur = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *&gt;(r);</span><br><span class="line">  <span class="keyword">auto</span> *end = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *&gt;(r + n);</span><br><span class="line">  <span class="keyword">auto</span> *testPtr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *&gt;(test);</span><br><span class="line">  <span class="keyword">for</span> (; cur != end; ++cur) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == testPtr) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> foo[<span class="number">10</span>];</span><br><span class="line">  <span class="keyword">double</span> *x = &amp;foo[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">double</span> bar;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::boolalpha &lt;&lt; in_range(&amp;bar, x, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意以上代码就完美可移植了，绝对不会出现任何问题。它用了遍历容器指针的值与要测试的指针的值一一做对比，并且转换成了unsigned char指针类型，用的是==比较操作符，没有用大于小于比较。这样就不会出问题了。</p>
<h3 id="CTR55-CPP-如果会导致溢出就不要在一个迭代器上做加法操作"><a href="#CTR55-CPP-如果会导致溢出就不要在一个迭代器上做加法操作" class="headerlink" title="CTR55-CPP. 如果会导致溢出就不要在一个迭代器上做加法操作"></a>CTR55-CPP. 如果会导致溢出就不要在一个迭代器上做加法操作</h3><p>严重程度：高。后果导致攻击者可以通过溢出制造运行任何代码的攻击。</p>
<p>C++标准[expr.add]有如下描述：</p>
<blockquote>
<p>If both the pointer operand and the result point to elements of the same array object, or one past the last element of the array object, the evaluation shall not produce an overflow; otherwise, the behavior is undefined.</p>
</blockquote>
<p>因为迭代器是指针的泛化。所以通过在迭代器上做加法也有与指针一样的限制，C++标准[iterator.requirement.general]有如下声明：</p>
<blockquote>
<p>Just as a regular pointer to an array guarantees that there is a pointer value pointing past the last element of the array, so for any iterator type there is an iterator value that points past the last element of a corresponding sequence. These values are called pastthe-end values. Values of an iterator i for which the expression *i is defined are called dereferenceable. The library never assumes that past-the-end values are dereferenceable.</p>
</blockquote>
<h4 id="代码样例对比-7"><a href="#代码样例对比-7" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;c)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i = c.begin(), e = i + <span class="number">20</span>; i != e; ++i) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码因为不知道vector的size，就在begin位置偏移了20个单位，天晓得vector运行到f函数的时候是多大，所以应该改成以下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;c)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type maxSize = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i = c.begin(), e = i + <span class="built_in">std</span>::min(maxSize, c.size()); i != e; ++i) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码就比较了vector和意图遍历的大小20，以防止溢出。</p>
<h3 id="CTR56-CPP-不要用指针在多态对象上进行算数运算"><a href="#CTR56-CPP-不要用指针在多态对象上进行算数运算" class="headerlink" title="CTR56-CPP. 不要用指针在多态对象上进行算数运算"></a>CTR56-CPP. 不要用指针在多态对象上进行算数运算</h3><p>严重程度：高。导致内存冲突，并且这个也会造成攻击者制造运行任何代码的漏洞。</p>
<p>C++标准中[expt.add]有关于指针算数运算的定义：</p>
<blockquote>
<p>For addition or subtraction, if the expressions P or Q have type “pointer to cv T”, where T<br>is different from the cv-unqualified array element type, the behavior is undefined. [Note:<br>In particular, a pointer to a base class cannot be used for pointer arithmetic when the<br>array contains objects of a derived class type. —end note]</p>
</blockquote>
<p>指针算数没有办法知道多态对象的size，试图在多态对象上执行指针算数运算的会导致未定义行为。</p>
<p>C++标准[sxpr.sub]中还说了，数据加小标其实本质就是指针算数运算：</p>
<blockquote>
<p>The expression E1[E2] is identical (by definition) to *((E1)+(E2)).</p>
</blockquote>
<p>所以在多态对象上不要用指针算数也不要以数组下标的形式访问。</p>
<h4 id="代码样例对比-8"><a href="#代码样例对比-8" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// / ... definitions for S, T, globI, globD ...</span></span><br><span class="line"><span class="keyword">int</span> globI;</span><br><span class="line"><span class="keyword">double</span> globD;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  S() : i(globI++) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T</span> :</span> S &#123;</span><br><span class="line">  <span class="keyword">double</span> d;</span><br><span class="line">  T() : S(), d(globD++) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> S *someSes, <span class="built_in">std</span>::<span class="keyword">size_t</span> count)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> S *end = someSes + count; someSes != end; ++someSes) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; someSes-&gt;i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  T test[<span class="number">5</span>];</span><br><span class="line">  f(test, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上的代码someSes + count 明显违反了在多态对象上使用指针算数运算了，所以会造成未定义行为。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// ... definitions for S, T, globI, globD ...</span></span><br><span class="line"><span class="keyword">int</span> globI;</span><br><span class="line"><span class="keyword">double</span> globD;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  S() : i(globI++) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T</span> :</span> S &#123;</span><br><span class="line">  <span class="keyword">double</span> d;</span><br><span class="line">  T() : S(), d(globD++) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> S *someSes, <span class="built_in">std</span>::<span class="keyword">size_t</span> count)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; someSes[i].i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  T test[<span class="number">5</span>];</span><br><span class="line">  f(test, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上的代码用数组下标的方式运用了在多态对象上，因为指针做加法，不知道多态对象的大小，没有正确取得偏移量，所以也会导致未定义行为。需要改成以下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// ... definitions for S, T, globI, globD ...</span></span><br><span class="line"><span class="keyword">int</span> globI;</span><br><span class="line"><span class="keyword">double</span> globD;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  S() : i(globI++) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T</span> :</span> S &#123;</span><br><span class="line">  <span class="keyword">double</span> d;</span><br><span class="line">  T() : S(), d(globD++) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> S * <span class="keyword">const</span> *someSes, <span class="built_in">std</span>::<span class="keyword">size_t</span> count)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> S * <span class="keyword">const</span> *end = someSes + count; someSes != end; ++someSes) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (*someSes)-&gt;i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  S *test[] = &#123;<span class="keyword">new</span> T, <span class="keyword">new</span> T, <span class="keyword">new</span> T, <span class="keyword">new</span> T, <span class="keyword">new</span> T&#125;;</span><br><span class="line">  f(test, <span class="number">5</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> v : test) &#123;</span><br><span class="line">    <span class="keyword">delete</span> v;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码无懈可击了，使用多态对象的指针数组来代替多态对象数组，因为指针的size都是一样的，可以在指针上做指针算数运算了，不会出现未定义行为。或者可以用迭代器的方式来解决本质是一样的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="comment">// ... definitions for S, T, globI, globD ...</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(Iter i, Iter e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (; i != e; ++i) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (*i)-&gt;i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;S *&gt; test&#123;<span class="keyword">new</span> T, <span class="keyword">new</span> T, <span class="keyword">new</span> T, <span class="keyword">new</span> T, <span class="keyword">new</span> T&#125;;</span><br><span class="line">  f(test.cbegin(), test.cend());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> v : test) &#123;</span><br><span class="line">    <span class="keyword">delete</span> v;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本质上还是指向多态对象的指针的vector，一样的。</p>
<h3 id="CTR57-CPP-提供合法的顺序谓词-predicate"><a href="#CTR57-CPP-提供合法的顺序谓词-predicate" class="headerlink" title="CTR57-CPP. 提供合法的顺序谓词(predicate)"></a>CTR57-CPP. 提供合法的顺序谓词(predicate)</h3><p>严重程度：低。可能导致错误行为或者无限循环.</p>
<h4 id="代码样例对比-9"><a href="#代码样例对比-9" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::less_equal&lt;<span class="keyword">int</span>&gt;&gt; s&#123;<span class="number">5</span>, <span class="number">10</span>, <span class="number">20</span>&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> r = s.equal_range(<span class="number">10</span>); r.first != r.second; ++r.first)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *r.first &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码试图通过一个比较谓词来创建一个set，但是呢，这个比较谓词并没有采用严格弱顺序的要求，所以，在对于值相等的时候返回false会失败。结果就时当遍历开始的时候，std::set::equal_range就会导致未指定行为。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s&#123;<span class="number">5</span>, <span class="number">10</span>, <span class="number">20</span>&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> r = s.equal_range(<span class="number">10</span>); r.first != r.second; ++r.first)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *r.first &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码就完全没问题了，采用了set默认提供的比较谓词。</p>
<h4 id="代码样例对比-10"><a href="#代码样例对比-10" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span> &#123;</span></span><br><span class="line"> <span class="keyword">int</span> i, j;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  S(<span class="keyword">int</span> i, <span class="keyword">int</span> j) : i(i), j(j) &#123;&#125;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> S &amp;lhs, <span class="keyword">const</span> S &amp;rhs) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.i &lt; rhs.i &amp;&amp; lhs.j &lt; rhs.j;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">friend</span> <span class="built_in">std</span>::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp;os, <span class="keyword">const</span> S&amp; o) </span><br><span class="line">  &#123;</span><br><span class="line">     os &lt;&lt; <span class="string">"i: "</span> &lt;&lt; o.i &lt;&lt; <span class="string">", j: "</span> &lt;&lt; o.j;</span><br><span class="line">     <span class="keyword">return</span> os;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">set</span>&lt;S&gt; t&#123;S(<span class="number">1</span>, <span class="number">1</span>), S(<span class="number">1</span>, <span class="number">2</span>), S(<span class="number">2</span>, <span class="number">1</span>)&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> v : t) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码试图把S类型的对象存储进set中，并且提供了一个重载的operator &lt; 实现，运行对象间的std::less比较。然而，比较操作没有提供一个严格的弱顺序。需要改成以下形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  S(<span class="keyword">int</span> i, <span class="keyword">int</span> j) : i(i), j(j) &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> S &amp;lhs, <span class="keyword">const</span> S &amp;rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::tie(lhs.i, lhs.j) &lt; <span class="built_in">std</span>::tie(rhs.i, rhs.j);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">friend</span> <span class="built_in">std</span>::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp;os, <span class="keyword">const</span> S&amp; o) &#123;</span><br><span class="line">    os &lt;&lt; <span class="string">"i: "</span> &lt;&lt; o.i &lt;&lt; <span class="string">", j: "</span> &lt;&lt; o.j;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">set</span>&lt;S&gt; t&#123;S(<span class="number">1</span>, <span class="number">1</span>), S(<span class="number">1</span>, <span class="number">2</span>), S(<span class="number">2</span>, <span class="number">1</span>)&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> v : t) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码用std::tie来恰当的实现了严格弱顺序的operator &lt; 谓词。</p>
<h3 id="CTR58-CPP-谓词函数对象应该不能被修改"><a href="#CTR58-CPP-谓词函数对象应该不能被修改" class="headerlink" title="CTR58-CPP. 谓词函数对象应该不能被修改"></a>CTR58-CPP. 谓词函数对象应该不能被修改</h3><p>严重程度：低。谓词函数对象的状态可能会产生无法预料的值。</p>
<p>C++标准库中大量的STL算法可能都允许接收一个谓词函数对象，在C++标准[algorithms.general]有如下描述：</p>
<blockquote>
<p>[Note: Unless otherwise specified, algorithms that take function objects as arguments are permitted to copy those function objects freely. Programmers for whom object identity is important should consider using a wrapper class that points to a noncopied implementation object such as reference_wrapper<t>, or some equivalent solution. — end note]</t></p>
</blockquote>
<p>因为这些STL算法是实现定义的，没办法保证算法是否拷贝了谓词函数对象。</p>
<h4 id="代码样例对比-11"><a href="#代码样例对比-11" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MutablePredicate</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::unary_function&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">size_t</span> timesCalled;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  MutablePredicate() : timesCalled(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++timesCalled == <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_container</span><span class="params">(Iter b, Iter e)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Contains: "</span>;</span><br><span class="line">  <span class="built_in">std</span>::copy(b, e, <span class="built_in">std</span>::ostream_iterator&lt;<span class="keyword">decltype</span>(*b)&gt;</span><br><span class="line">                                    (<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">" "</span>));</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">  print_container(v.begin(), v.end());</span><br><span class="line">  v.erase(</span><br><span class="line">   <span class="built_in">std</span>::remove_if(v.begin(), v.end(), MutablePredicate()),</span><br><span class="line">   v.end());</span><br><span class="line">   print_container(v.begin(), v.end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码在std::remove_if的时候传入了自定义的谓词函数对象，企图删除当谓词对象被调用第三次的时候的vector的元素。但是，意料之外，std::remove_if允许在谓词对象构造的时候是使用谓词对象的拷贝，也就是，可能是多个对象拷贝，这样就会导致结果可能不是你所预想。</p>
<p>在GCC 4.8.1 标准库是libstdc++的时候，以上代码会有以下输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Contains: 0 1 2 3 4 5 6 7 8 9</span><br><span class="line">Contains: 0 1 3 4 6 7 8 9</span><br></pre></td></tr></table></figure>
<p>看以上输出，把元素2和5删除了，不如我们所想。原因是std::remove_if生成了2个谓词函数的副本在调用谓词函数对象之前。这就导致了副本1号删除了对于它的第三次调用的元素，这个元素是2，意料之中。副本2号删除了对于它的第三次调用的元素，这个元素是5，也是意料之中。 所以居然删除了2个元素。</p>
<p>当然，如果你不想用自定义的谓词函数对象，那么也可以用lambda表达式实现，其实lambda表达式也是对象，与自定义谓词对象是一样的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_container</span><span class="params">(Iter b, Iter e)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Contains: "</span>;</span><br><span class="line">  <span class="built_in">std</span>::copy(b, e,</span><br><span class="line">  <span class="built_in">std</span>::ostream_iterator&lt;<span class="keyword">decltype</span>(*b)&gt;(<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">" "</span>));</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">  print_container(v.begin(), v.end());</span><br><span class="line">  <span class="keyword">int</span> timesCalled = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  v.erase(<span class="built_in">std</span>::remove_if(</span><br><span class="line">          v.begin(),</span><br><span class="line">          v.end(),</span><br><span class="line">          [timesCalled](<span class="keyword">const</span> <span class="keyword">int</span> &amp;) <span class="keyword">mutable</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> ++timesCalled == <span class="number">3</span>;</span><br><span class="line">          &#125;),</span><br><span class="line">          v.end());</span><br><span class="line">  </span><br><span class="line">  print_container(v.begin(), v.end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实本质和之前的代码也是一样的，只不过用lambda表达式简化了而已，还是会出现之前的问题，因为std::remove_if函数实现你没办法保证它构造了几个lambda函数对象的副本。如果是2个，那么与之前的代码输出是一样的。所以要构造一个谓词函数对象，并且强制让remove_if采用这一个对象，需要改成以下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MutablePredicate</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::unary_function&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">size_t</span> timesCalled;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  MutablePredicate() : timesCalled(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++timesCalled == <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_container</span><span class="params">(Iter b, Iter e)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Contains: "</span>;</span><br><span class="line">  <span class="built_in">std</span>::copy(b, e,</span><br><span class="line">  <span class="built_in">std</span>::ostream_iterator&lt;<span class="keyword">decltype</span>(*b)&gt;(<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">" "</span>));</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">  print_container(v.begin(), v.end());</span><br><span class="line">  MutablePredicate mp;</span><br><span class="line">  </span><br><span class="line">  v.erase(</span><br><span class="line">         <span class="built_in">std</span>::remove_if(v.begin(), v.end(), <span class="built_in">std</span>::ref(mp)),</span><br><span class="line">         v.end());</span><br><span class="line"></span><br><span class="line">  print_container(v.begin(), v.end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是手动构造一个谓词对象，然后用std::ref处理后传递进去，这个就保证调用前只有一个对象副本，程序输出就是正确结果了,恰好是第三次调用时候的元素2被删除：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Contains: 0 1 2 3 4 5 6 7 8 9</span><br><span class="line">Contains: 0 1 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://alexiachen.github.io/blog/2017/07/19/cert-cpp-three/" data-id="cjtctmcia0099qfqf061kfum2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/C-C/">C/C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/CERT/">CERT</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-modesty-may-not-virtue" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2017/07/18/modesty-may-not-virtue/" class="article-date">
  <time datetime="2017-07-18T07:55:53.000Z" itemprop="datePublished">2017-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2017/07/18/modesty-may-not-virtue/">谦虚也许并不是一种美德</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>谦虚也许不是一种美德，对，你们没看错。大部分人可能会更喜欢谦虚的人，不喜欢狂妄自大的，从内心上接受不了这样的人，并喜欢极力的打击骄傲的人，以显示自己服从主流观念的正常人。</p>
<p>但是从我的观念上看，如果一个人的一生中没有足以让他在某个方面自傲，那么我觉得这个人的人生是个失败的。我不觉得需要对某个领域作出巨大的贡献才能有自傲的本钱，这是不对的。比如你在某个领域取得了相对于你之前的巨大进步，那么也可以自称自己为天才，就像我一直觉得我烧菜其实很有天赋的，一学就会，就很好。</p>
<p>所以从这个角度来看待，我不认为谦虚是一种美德。我的职业是程序员，程序员心目中的什么地位最重要？那么肯定是代码。但很多程序员估计不喜欢自大骄傲的同行，喜欢讽刺挖苦别的自称“精通”某程序设计语言的程序员或者其他，以显示自己谦虚的高尚美德。比如下图<a href="https://www.douban.com/group/topic/1582202/" target="_blank" rel="noopener">这个人</a>（很早出名了）</p>
<p><img src="http://wx4.sinaimg.cn/large/a1ac93f3gy1fhnzjvq9oxj20rx0ee76m.jpg" alt=""></p>
<p>如果你点开链接看，你会发现lichray被各种自称工作10几年经验的程序员讽刺挖苦。其实我自己很喜欢欣赏这样的人，我丝毫不怀疑他，我并不像其他人物一样认为，精通C语言就得用C语言写出个操作系统或内核。精通C++就一定要像Google那样写出MapReduce。我的认为跟他一样，精通某种语言应该用某种语言（逻辑角度，数学角度）来写出满足它设计之初自圆其说的能力，这就叫精通。可笑的是，那些讽刺lichray的人说lichray没有做出什么惊人成就，就狂妄自大，老气横秋，好为人师。后来lichray确实作出了贡献，虽然不是什么惊人的贡献，就向ISO C++ Committee提交了个<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3627.html" target="_blank" rel="noopener">proposal</a>，而且被采纳了。</p>
<p><img src="http://wx1.sinaimg.cn/large/a1ac93f3gy1fhnzyszcpqj20jh0cpq4q.jpg" alt=""></p>
<p>而今这些讽刺lichray的人又在干什么呢？又做出了什么服务程序员界的贡献呢？，lichray在2007年发表的帖子，距今已经10年了，人家小小年纪10年前就说仅仅只是想对计算机科学做出点微小的贡献，而今他达到了，他当年错了吗？ 你们这些讽刺别人的看客，你们回忆你们当年有没有这样的情怀？</p>
<p>所以同样我也很欣赏王垠，他不会像你们大多数人一样。我丝毫不怀疑他那引以为豪的<a href="https://www.zhihu.com/question/20822815" target="_blank" rel="noopener">40行代码</a>的杰作。就像知乎上一个人评价这段代码一样：</p>
<blockquote>
<p><em>一个人可以读懂CPS的论文，也可以照着里面实现出代码。但是经历这种过程的人，永远无法掌握将里面的技巧用到其它地方，因为只有自己思考出来，才懂得触类旁通，才有可能如此灵活！我于是完全相信了这40行代码的价值。自己思考出来，和从它处学到，完全不同。这40行代码的价值既然不在于实现了CPS的算法，也不在于这段代码写得有多么精简和巧妙。而是：独立思考。</em></p>
</blockquote>
<p>难道这还不能骄傲吗？ 难道王垠在微软工作的时候，写出了比principal engineer还简洁优美的B+树，也不能让他骄傲一下吗？ principal有principal的格局，王垠也有自己的格局。</p>
<p>你们讽刺别人仅仅只是因为你没他强，作为围观群众的你，我觉得你应该<a href="https://www.zhihu.com/question/42115074" target="_blank" rel="noopener">别急着否定别人的狂妄自大和自称天下第一，而是先看看自己，有没有别人的能力和水平</a>。不要用没做出成就贡献之类的话来挖苦别人来掩饰自己的无能。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://alexiachen.github.io/blog/2017/07/18/modesty-may-not-virtue/" data-id="cjtctmcfc001iqfqfdc669a53" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/人生/">人生</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-cert-cpp-two" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2017/07/17/cert-cpp-two/" class="article-date">
  <time datetime="2017-07-17T07:55:53.000Z" itemprop="datePublished">2017-07-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2017/07/17/cert-cpp-two/">CERT C++编码规范翻译（INT）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="整型数"><a href="#整型数" class="headerlink" title="整型数"></a>整型数</h2><h3 id="INT50-CPP-不要转换超出枚举值的范围"><a href="#INT50-CPP-不要转换超出枚举值的范围" class="headerlink" title="INT50-CPP. 不要转换超出枚举值的范围"></a>INT50-CPP. 不要转换超出枚举值的范围</h3><p>严重程度：中等。由于转换带来的未指定值导致的buffer溢出，从而给攻击者制造运行任意恶意代码的场景。数据完整性违例等等。</p>
<p>在C++中枚举有两种形式： 区域枚举，底层的类型是固定的。非区域枚举底层的类型可能是也可能不是固定的。枚举类型的合法值的范围在C++标准[dcl.enum]中有描述：</p>
<blockquote>
<p>For an enumeration whose underlying type is fixed, the values of the enumeration are the values of the underlying type. Otherwise, for an enumeration where emin is the smallest enumerator and emax is the largest, the values of the enumeration are the values in the range bmin to bmax, defined as follows: Let K be 1 for a two’s complement representation and 0 for a one’s complement or sign-magnitude representation. bmax is the smallest value greater than or equal to max(|emin| − K, |emax|) and equal to 2M − 1, where M is a non-negative integer. bmin is zero if emin is non-negative and −(bmax + K) otherwise. The size of the smallest bit-field large enough to hold all the values of the enumeration type is max(M, 1) if bmin is zero and M + 1 otherwise. It is possible to define an enumeration that has values not defined by any of its enumerators. If the enumeratorlist is empty, the values of the enumeration are as if the enumeration had a single enumerator with value 0.</p>
</blockquote>
<p>然后对于枚举类型的转换，C++标准[expr.static.cast]也有描述：</p>
<blockquote>
<p>A value of integral or enumeration type can be explicitly converted to an enumeration type. The value is unchanged if the original value is within the range of the enumeration values (7.2). Otherwise, the resulting value is unspecified (and might not be in that range). A value of floating-point type can also be explicitly converted to an enumeration type. The resulting value is the same as converting the original value to the underlying type of the enumeration (4.9), and subsequently to the enumeration type.</p>
</blockquote>
<h4 id="代码样例对比"><a href="#代码样例对比" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> EnumType &#123;</span><br><span class="line">  First,</span><br><span class="line">  Second,</span><br><span class="line">  Third</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> intVar)</span> </span>&#123;</span><br><span class="line">  EnumType enumVar = <span class="keyword">static_cast</span>&lt;EnumType&gt;(intVar);</span><br><span class="line">  <span class="keyword">if</span> (enumVar &lt; First || enumVar &gt; Third) &#123;</span><br><span class="line">    <span class="comment">// Handle error</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中，函数f()试图检查intVar是否在枚举值的范围以内，但是对一个未知的int值转换成枚举类型，会导致未指定的值，也就是说enumVar是一个未指定的值，一旦对其进行if判断，就会导致未指定行为。需要用以下方式解决：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> EnumType &#123;</span><br><span class="line">  First,</span><br><span class="line">  Second,</span><br><span class="line">  Third</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> intVar)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (intVar &lt; First || intVar &gt; Third) &#123;</span><br><span class="line">  <span class="comment">// Handle error</span></span><br><span class="line">  &#125;</span><br><span class="line">  EnumType enumVar = <span class="keyword">static_cast</span>&lt;EnumType&gt;(intVar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把if判断前置，不会导致未指定行为了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumType</span> &#123;</span></span><br><span class="line">  First,</span><br><span class="line">  Second,</span><br><span class="line">  Third</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> intVar)</span> </span>&#123;</span><br><span class="line">  EnumType enumVar = <span class="keyword">static_cast</span>&lt;EnumType&gt;(intVar);</span><br><span class="line">  <span class="keyword">if</span> (intVar &lt; First || intVar &gt; Third) &#123;</span><br><span class="line">    <span class="comment">// Handle error</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用枚举类类型。也就是之前所说的区域枚举。默认底层的类型是int类型表述的值。允许任何int类型的参数合法转换为枚举值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> EnumType : <span class="keyword">int</span> &#123;</span><br><span class="line">  First,</span><br><span class="line">  Second,</span><br><span class="line">  Third</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> intVar)</span> </span>&#123;</span><br><span class="line">  EnumType enumVar = <span class="keyword">static_cast</span>&lt;EnumType&gt;(intVar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用固定非区域枚举。如果没有以上的int声明，那么这个枚举类型就是非固定非区域枚举。 现在该枚举类型的底层类型为固定的int类型，允许任何int值转换为合法枚举值。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://alexiachen.github.io/blog/2017/07/17/cert-cpp-two/" data-id="cjtctmcej0009qfqfn5sco322" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/C-C/">C/C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/CERT/">CERT</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-cert-cpp-one" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2017/06/29/cert-cpp-one/" class="article-date">
  <time datetime="2017-06-29T06:50:53.000Z" itemprop="datePublished">2017-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2017/06/29/cert-cpp-one/">CERT C++编码规范翻译（EXP）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="表达式（EXP）"><a href="#表达式（EXP）" class="headerlink" title="表达式（EXP）"></a>表达式（EXP）</h2><h3 id="EXP50-CPP-不要依赖求值顺序所造成的副作用"><a href="#EXP50-CPP-不要依赖求值顺序所造成的副作用" class="headerlink" title="EXP50-CPP 不要依赖求值顺序所造成的副作用"></a>EXP50-CPP 不要依赖求值顺序所造成的副作用</h3><p>严重等级：中等</p>
<p>关于求值顺序可能造成的副作用，C++标准[intro.execution]有说明：</p>
<blockquote>
<p>Sequenced before is an asymmetric, transitive, pair-wise relation between evaluations executed by a single thread, which induces a partial order among those evaluations. Given any two evaluations A and B, if A is sequenced before B, then the execution of A shall precede the execution of B. If A is not sequenced before B and B is not sequenced before A, then A and B are unsequenced. [Note: The execution of unsequenced evaluations can overlap. — end note] Evaluations A and B are indeterminately sequenced when either A is sequenced before B or B is sequenced before A, but it is unspecified which. [Note: Indeterminately sequenced evaluations cannot overlap, but<br>either could be executed first. — end note]</p>
</blockquote>
<p>当然，接下来还有描述：</p>
<blockquote>
<p>Except where noted, evaluations of operands of individual operators and of subexpressions of individual expressions are unsequenced. … The value computations of the operands of an operator are sequenced before the value computation of the result of the operator. If a side effect on a scalar object is unsequenced relative to either another side effect on the same scalar object or a value computation using the value of the same scalar object, and they are not potentially concurrent, the behavior is undefined. … When calling a function (whether or not the function is inline), every value computation and side effect associated with any argument expression, or with the postfix expression designating the called function, is sequenced before execution of every expression or statement in the body of the called function. … Every evaluation in the calling function (including other function calls) that is not otherwise specifically sequenced before or after the execution of the body of the called function is indeterminately sequenced with respect to the execution of the called function. Several contexts in C++ cause evaluation of a function call, even though no corresponding function call syntax appears in the translation unit. … The sequencing constraints on the execution of the called function (as described above) are features of the function calls as evaluated, whatever the syntax of the expression that calls the function might be.</p>
</blockquote>
<h4 id="代码样例对比"><a href="#代码样例对比" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">const</span> <span class="keyword">int</span> *b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = i + b[++i];</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码是不符合规范的，i的求值会以不定的顺序求值多次，所以表达式的行为是未定义的。比如对于函数f(5,&amp;b)的调用。表达式i + b[++i]可能有以下二种求值顺序：</p>
<ul>
<li>5 + b[++i] -&gt; 5 + b[6] </li>
<li>i + b[6] -&gt; 6 + b[6]</li>
</ul>
<p>这就导致了我们没想到的行为结果。应该避免，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">const</span> <span class="keyword">int</span> *b)</span> </span>&#123;</span><br><span class="line">  ++i;</span><br><span class="line">  <span class="keyword">int</span> a = i + b[i];</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">const</span> <span class="keyword">int</span> *b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = i + b[i + <span class="number">1</span>];</span><br><span class="line">  ++i;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码样例对比-1"><a href="#代码样例对比-1" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  func(i++, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上的代码，对于函数func的调用可能行为不一致，因为函数func的输入的参数表达式的求值顺序是不定的。对于f(5)的调用，func的参数求值有以下顺序：</p>
<ul>
<li>func(5,i) -&gt; func(5,6)</li>
<li>func(i++,5) -&gt; func(5,5)</li>
</ul>
<p>必须用以下方式来避免：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  i++;</span><br><span class="line">  func(i, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> j = i++;</span><br><span class="line">  func(j, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样以来，函数f传入任何参数，都会有一一对应的输出。不会出现副作用。</p>
<h4 id="代码样例对比-2"><a href="#代码样例对比-2" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">c</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;</span><br><span class="line"><span class="keyword">int</span> glob = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> glob + <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  glob = <span class="number">42</span>;</span><br><span class="line">  <span class="keyword">return</span> glob;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  c(a(), b());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码，对函数c的调用，依赖于参数的求值顺序，也就是说，a(),b()的调用顺序是不定的。会导致未指定行为(unspecified bhavior)，不是未定义行为(undefinded behavior)。</p>
<ul>
<li>c(15, b()) -&gt; c(15,42)</li>
<li>c(a(),42) -&gt; c(52,42)</li>
</ul>
<p>需要固定函数的调用顺序，就可以了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">c</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;</span><br><span class="line"><span class="keyword">int</span> glob = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> glob + <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  glob = <span class="number">42</span>;</span><br><span class="line">  <span class="keyword">return</span> glob;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a_val = a();</span><br><span class="line">  <span class="keyword">int</span> b_val = b();</span><br><span class="line">  c(a_val, b_val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="EXP51-CPP-不要通过不正确的类型的指针来删除一个数组"><a href="#EXP51-CPP-不要通过不正确的类型的指针来删除一个数组" class="headerlink" title="EXP51-CPP 不要通过不正确的类型的指针来删除一个数组"></a>EXP51-CPP 不要通过不正确的类型的指针来删除一个数组</h3><p>严重等级：低</p>
<p>在C++标准中[expr.delete] 有如下声明：</p>
<blockquote>
<p>In the first alternative (delete object), if the static type of the object to be deleted is different from its dynamic type, the static type shall be a base class of the dynamic type of the object to be deleted and the static type shall have a virtual destructor or the behavior is undefined. In the second alternative (delete array) if the dynamic type of the object to be deleted differs from its static type, the behavior is undefined.</p>
</blockquote>
<p>不要通过静态指针类型删除一个动态指针类型的对象数组，这样会导致未定义行为。至于后果，可能就是不正常的程序和内存泄漏。</p>
<h4 id="代码样例对比-3"><a href="#代码样例对比-3" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">  <span class="keyword">virtual</span> ~Base() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> <span class="title">final</span> :</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Base *b = <span class="keyword">new</span> Derived[<span class="number">10</span>];</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">delete</span> [] b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码创建了一个Derived类型的对象数组，这个数组指针被保存在Base类型的指针中。尽管Base的析构函数被声明为virtual，但是该段代码还是会导致未定义行为。另外，企图在静态类型的Base指针上执行指针算数操作，违反了CTR56-CPP的条款。</p>
<p>应该改成以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">  <span class="keyword">virtual</span> ~Base() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> <span class="title">final</span> :</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Derived *b = <span class="keyword">new</span> Derived[<span class="number">10</span>];</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">delete</span> [] b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上的代码就移除了未定义行为的发生的可能。Derived对象数组的删除，就应该交由Drived类型的指针来删除。</p>
<h3 id="EXP53-CPP-不要读取未初始化的内存"><a href="#EXP53-CPP-不要读取未初始化的内存" class="headerlink" title="EXP53-CPP 不要读取未初始化的内存"></a>EXP53-CPP 不要读取未初始化的内存</h3><p>严重等级： 高</p>
<p>局部变量，自动变量在初始化之前读取的话，它们的值都是无法预测的（随机值）。C++标准[dcl.init]有如下声明：</p>
<blockquote>
<p>If no initializer is specified for an object, the object is default-initialized. When storage for an object with automatic or dynamic storage duration is obtained, the object has an indeterminate value, and if no initialization is performed for the object, that object retains an indeterminate value until that value is replaced. If an indeterminate value is produced by an evaluation, the behavior is undefined except in the following cases:</p>
</blockquote>
<blockquote>
<p>• If an indeterminate value of unsigned narrow character type is produced by the evaluation of:</p>
</blockquote>
<blockquote>
<p>— the second or third operand of a conditional expression,</p>
</blockquote>
<blockquote>
<p>— the right operand of a comma expression,</p>
</blockquote>
<blockquote>
<p>— the operand of a cast or conversion to an unsigned narrow character type, or</p>
</blockquote>
<blockquote>
<p>— a discarded-value expression, then the result of the operation is an indeterminate value.</p>
</blockquote>
<blockquote>
<p>• If an indeterminate value of unsigned narrow character type is produced by the evaluation of the right operand of a simple assignment operator whose first operand is an lvalue of unsigned narrow character type, an indeterminate value replaces the value of the object referred to by the left operand.</p>
</blockquote>
<blockquote>
<p>• If an indeterminate value of unsigned narrow character type is produced by the evaluation of the initialization expression when initializing an object of unsigned narrow character type, that object is initialized to an indeterminate value.</p>
</blockquote>
<p>一个对象的默认初始化在C++标准中也有子条款描述：</p>
<blockquote>
<p>To default-initialize an object of type T means:</p>
</blockquote>
<blockquote>
<p>• if T is a (possibly cv-qualified) class type, the default constructor for T is called (and the initialization is ill-formed if T has no default constructor or overload resolution results in an ambiguity or in a function that is deleted or inaccessible from the context of the initialization);</p>
</blockquote>
<blockquote>
<p>• if T is an array type, each element is default-initialized;</p>
</blockquote>
<blockquote>
<p>• otherwise, no initialization is performed.If a program calls for the default initialization of an object of a const-qualified type T, Tshall be a class type with a user-provided default constructor.</p>
</blockquote>
<h4 id="代码样例对比-4"><a href="#代码样例对比-4" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i; <span class="comment">//导致未定义行为</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// 打印前，先初始化</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *i = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">", "</span> &lt;&lt; *i; <span class="comment">//打印指针指向的值会导致未定义行为，打印指针本身的值是合法的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *i = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">12</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">", "</span> &lt;&lt; *i;<span class="comment">//完全没问题了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于new表达式初始化的方法，有以下正确姿势：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *i = <span class="keyword">new</span> <span class="keyword">int</span>(); <span class="comment">// zero-initializes *i</span></span><br><span class="line"><span class="keyword">int</span> *j = <span class="keyword">new</span> <span class="keyword">int</span>&#123;&#125;; <span class="comment">// zero-initializes *j</span></span><br><span class="line"><span class="keyword">int</span> *k = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">12</span>); <span class="comment">// initializes *k to 12</span></span><br><span class="line"><span class="keyword">int</span> *l = <span class="keyword">new</span> <span class="keyword">int</span>&#123;<span class="number">12</span>&#125;; <span class="comment">// initializes *l to 12</span></span><br></pre></td></tr></table></figure>
<h4 id="代码样例对比-5"><a href="#代码样例对比-5" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> i + c; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  S s;</span><br><span class="line">  <span class="keyword">int</span> i = s.f(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码中，虽然对象s被默认构造函数初始化了，成员变量c的空间也被分配了，但是变量c没有被初始化为一个值，所以，对成员函数f的调用会导致未定义行为。需要这么写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  S() : c(<span class="number">0</span>) &#123;&#125; <span class="comment">//给个默认构造函数，把c初始化为0</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> i + c; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  S s;</span><br><span class="line">  <span class="keyword">int</span> i = s.f(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="EXP54-CPP-不要访问处于其生命周期之外的对象"><a href="#EXP54-CPP-不要访问处于其生命周期之外的对象" class="headerlink" title="EXP54-CPP 不要访问处于其生命周期之外的对象"></a>EXP54-CPP 不要访问处于其生命周期之外的对象</h3><p>严重程度：高</p>
<p>C++中每个对象都有自己的生命周期，C++程序员掌握对象的生命周期是必须要做的事。它是保证一个程序是well-defined的必要途径。如果用指针访问了超出了其声明周期的对象，那么就会导致未定义行为。</p>
<p>在C++标准[basic.life]中，描述指针的生命周期是这样的：</p>
<blockquote>
<p>Before the lifetime of an object has started but after the storage which the object will occupy has been allocated or, after the lifetime of an object has ended and before the storage which the object occupied is reused or released, any pointer that refers to the storage location where the object will be or was located may be used but only in limited ways. For an object under construction or destruction, see 12.7. Otherwise, such a pointer refers to allocated storage, and using the pointer as if the pointer were of type void*, is well-defined. Indirection through such a pointer is permitted but the resulting lvalue may only be used in limited ways, as described below. The program has undefined behavior if:</p>
</blockquote>
<blockquote>
<p>• the object will be or was of a class type with a non-trivial destructor and the pointer is used as the operand of a delete-expression,</p>
</blockquote>
<blockquote>
<p>• the pointer is used to access a non-static data member or call a non-static member<br>function of the object, or</p>
</blockquote>
<blockquote>
<p>• the pointer is implicitly converted to a pointer to a virtual base class, or</p>
</blockquote>
<blockquote>
<p>• the pointer is used as the operand of a static_cast, except when the conversion is to pointer to cv void, or to pointer to cv void and subsequently to pointer to either cv char or cv unsigned char, or</p>
</blockquote>
<blockquote>
<p>• the pointer is used as the operand of a dynamic_cast.</p>
</blockquote>
<p>以下是对非指针对象生命周期的描述：</p>
<blockquote>
<p>Similarly, before the lifetime of an object has started but after the storage which the object will occupy has been allocated or, after the lifetime of an object has ended and before the storage which the object occupied is reused or released, any glvalue that refers to the original object may be used but only in limited ways. For an object under construction or destruction, see 12.7. Otherwise, such a glvalue refers to allocated storage, and using the properties of the glvalue that do not depend on its value is welldefined.</p>
</blockquote>
<blockquote>
<p>The program has undefined behavior if:</p>
</blockquote>
<blockquote>
<p>• an lvalue-to-rvalue conversion is applied to such a glvalue,</p>
</blockquote>
<blockquote>
<p>• the glvalue is used to access a non-static data member or call a non-static member function of the object, or</p>
</blockquote>
<blockquote>
<p>• the glvalue is bound to a reference to a virtual base class, or</p>
</blockquote>
<blockquote>
<p>• the glvalue is used as the operand of a dynamic_cast or as the operand of typeid.</p>
</blockquote>
<p>值得注意的一点就是，一个对象的生命周期是从一个对象内存空间的分配完成并且初始化也完成的时候，才算正式开始。</p>
<h4 id="代码样例对比-6"><a href="#代码样例对比-6" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">mem_fn</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  S *s;</span><br><span class="line">  s-&gt;mem_fn();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码S类型的对象并没有初始化，S类型指针s倒是生命周期已经开始，但是并不是对象本身，所以调用对象的mem_fn函数，就会导致未定义行为。要改成以下片段：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">mem_fn</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  S *s = <span class="keyword">new</span> S;</span><br><span class="line">  s-&gt;mem_fn();</span><br><span class="line">  <span class="keyword">delete</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，如果以上的代码片段，如果你的编译器允许智能指针会更好。这个情景下建议使用std::unique_ptr。</p>
<h4 id="代码样例对比-7"><a href="#代码样例对比-7" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D1</span> :</span> <span class="keyword">virtual</span> B &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D2</span> :</span> <span class="keyword">virtual</span> B &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> :</span> D1, D2 &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> B *b)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  S *s = <span class="keyword">new</span> S;</span><br><span class="line">  <span class="comment">// Use s</span></span><br><span class="line">  <span class="keyword">delete</span> s;</span><br><span class="line">  f(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码，注意到了没？ 在调用函数f的时候，类型S的指针被隐式转换成了虚基类B的指针，并且s所指对象的生命周期结束了，被delete了。尽管在函数f的实现中没有使用该参数，但是这还是会导致未定义行为。上面的代码应该改为以下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D1</span> :</span> <span class="keyword">virtual</span> B &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D2</span> :</span> <span class="keyword">virtual</span> B &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> :</span> D1, D2 &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> B *b)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  S *s = <span class="keyword">new</span> S;</span><br><span class="line">  <span class="comment">// Use s</span></span><br><span class="line">  f(s);</span><br><span class="line">  <span class="keyword">delete</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把使用s变量提前，要保证s的使用在生命周期内。</p>
<h4 id="代码样例对比-8"><a href="#代码样例对比-8" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; l;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  C() : l&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">first</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> *l.begin(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  C c;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c.first();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码咋看好像还没什么问题，这比较复杂，需要仔细推敲。首先需要解释下原理，由一个初始化列表构造一个std::initializer_list的对象从实现上看是需要分配一个临时数组，然后再把这个临时数组传递给std::initializer_list类对象的构造函数，让你意外的是，std::initializer_list成员对象l所持有的是这个临时数组的引用，并没有拷贝给它。而临时数组的生命周期在构造函数结束后就同样结束了，所以，以上代码，无论如何，一旦对成员l的任何元素访问，就会造成未定义行为。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; l;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  C() : l&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">first</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> *l.begin(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  C c;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c.first();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码就规避了未定义行为。仅仅把std::initialzier_list换成了std::vector。std::vector就是把初始化列表的成员拷贝到自己的容器中了，而不是std::initialzier_list那样仅仅是依赖一个临时数组的引用委托。</p>
<h4 id="代码样例对比-9"><a href="#代码样例对比-9" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> l = [](<span class="keyword">const</span> <span class="keyword">int</span> &amp;j) &#123; <span class="keyword">return</span> j; &#125;;</span><br><span class="line">  <span class="built_in">std</span>::function&lt;<span class="keyword">const</span> <span class="keyword">int</span>&amp;(<span class="keyword">const</span> <span class="keyword">int</span> &amp;)&gt; fn(l);</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line">  <span class="keyword">int</span> j = fn(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上这段代码引入了C++11的lambda表达式，一下子看上去也没什么问题，所以分析起来复杂点。<br>首先，代码中的一个lambda对象被存储到了一个函数对象中，待之后调用，获取一个值的常引用。lambda对象返回了一个int类型的值，这个值一般是会存储在一个临时int对象中的，然而这个临时对象的类型却被std::function函数对象的返回值const int&amp;类型所绑定了，然后这个存储返回值的临时int对象的生命周期随着fn的调用在意料之外没有延长，反而随着fn的调用完成结束了生命周期，而std::function函数类型所指定的返回值却被常引用所绑定，一旦对其进行访问，那么就会导致未定义行为。</p>
<p>所以知道原理后，很简单就可以把代码改正确：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> l = [](<span class="keyword">const</span> <span class="keyword">int</span> &amp;j) &#123; <span class="keyword">return</span> j; &#125;;</span><br><span class="line">  <span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">const</span> <span class="keyword">int</span> &amp;)&gt; fn(l);</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line">  <span class="keyword">int</span> j = fn(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>std::function函数类型所指定的返回值类型不能用引用了，改成普通的int类型即可。</p>
<h4 id="代码样例对比-10"><a href="#代码样例对比-10" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><p>下面一个例子就是滥用goto语句导致的问题，所以还是慎用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  S() : v(<span class="number">12</span>) &#123;&#125; <span class="comment">// Non-trivial constructor</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">goto</span> bad_idea;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  S s; <span class="comment">// Control passes over the declaration, so initialization does not take place.</span></span><br><span class="line">bad_idea:</span><br><span class="line">  s.f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没什么难的，上面的代码不小心用goto语句jump到了bad_idea的标签位置，但是标签后恰恰紧接着调用了s对象的成员函数，而对象s的默认初始化构造被跳过去了，所以对s的引用属于生命周期以外，导致未定义行为。</p>
<p>很简单就可以改成下面:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  S() : v(<span class="number">12</span>) &#123;&#125; <span class="comment">// Non-trivial constructor</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  S s;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">goto</span> bad_idea;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">bad_idea:</span><br><span class="line">  s.f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把s的初始化构造提前到goto执行之前。</p>
<h4 id="代码样例对比-11"><a href="#代码样例对比-11" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  S() : i(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">  S(<span class="keyword">int</span> i) : i(i) &#123;&#125;</span><br><span class="line">  S(<span class="keyword">const</span> S&amp;) = <span class="keyword">default</span>;</span><br><span class="line">  S&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> S&amp;) = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iter&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(Iter i, Iter e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static_assert</span>(<span class="built_in">std</span>::is_same&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;Iter&gt;::value_type, S&gt;::value,</span><br><span class="line">          <span class="string">"Expecting iterators over type S"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">ptrdiff_t</span> count = <span class="built_in">std</span>::distance(i, e);</span><br><span class="line">  <span class="keyword">if</span> (!count) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get some temporary memory.</span></span><br><span class="line">  <span class="keyword">auto</span> p = <span class="built_in">std</span>::get_temporary_buffer&lt;S&gt;(count);</span><br><span class="line">  <span class="keyword">if</span> (p.second &lt; count) &#123;</span><br><span class="line">    <span class="comment">// Handle error; memory wasn't allocated, or</span></span><br><span class="line">    <span class="comment">// insufficient memory was allocated.</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  S *vals = p.first;</span><br><span class="line">  <span class="comment">// Copy the values into the memory.</span></span><br><span class="line">  <span class="built_in">std</span>::copy(i, e, vals);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// Return the temporary memory.</span></span><br><span class="line">  <span class="built_in">std</span>::return_temporary_buffer(vals);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码实现有点复杂，不管，先从函数f()的实现来看，f函数的参数是一个类型为S的迭代范围对象。然后这可迭代的一组对象被std::copy到一个temporary_buffer中。然而，std::get_temporary_buffer返回的S对象数组中的对象并没有初始化,所以std::copy函数解引用了目标迭代器，所以导致了未定义行为。归而结网的原因就是，对象空间被分配了，但是对象的构造函数和初始化并未调用。</p>
<p>std::get_temporary_buffer和std::copy的大致实现类似于下面的代码片段：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *buffer = <span class="keyword">new</span> (<span class="built_in">std</span>::nothrow) <span class="keyword">unsigned</span> <span class="keyword">char</span>[<span class="keyword">sizeof</span>(S) * object_count];</span><br><span class="line">S *result = <span class="keyword">reinterpret_cast</span>&lt;S *&gt;(buffer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i != e) &#123;</span><br><span class="line">  *result = *i; <span class="comment">// Undefined behavior</span></span><br><span class="line">  ++result;</span><br><span class="line">  ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以result所指向的类型为S的对象的生命周期还没有开始。需要做以下改动，仅仅改动std::copy那里就可以了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">// Copy the values into the memory.</span></span><br><span class="line"><span class="built_in">std</span>::uninitialized_copy(i, e, vals);</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>这个std::uninitialized_copy保证了对象初始化的时候用placement new来代替解引用为初始化的内存。或者还可以改成以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">// Copy the values into the memory.</span></span><br><span class="line"><span class="built_in">std</span>::copy(i, e, <span class="built_in">std</span>::raw_storage_iterator&lt;S*, S&gt;(vals));</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>用std::raw_storage_iterator作为目标地址迭代器与使用std::uninitialized_copy的效果是一样的，都是well-defined的。</p>
<h3 id="EXP55-CPP-不要通过cv-unqualified的类型来访问一个cv-qualified类型的对象"><a href="#EXP55-CPP-不要通过cv-unqualified的类型来访问一个cv-qualified类型的对象" class="headerlink" title="EXP55-CPP 不要通过cv-unqualified的类型来访问一个cv-qualified类型的对象"></a>EXP55-CPP 不要通过cv-unqualified的类型来访问一个cv-qualified类型的对象</h3><p>严重程度：中</p>
<p>C++标准对其 [dcl.type.cv]进行了如下描述：</p>
<blockquote>
<p>Except that any class member declared mutable can be modified, any attempt to modify a const object during its lifetime results in undefined behavior.</p>
</blockquote>
<p>类似的还有：</p>
<blockquote>
<p>What constitutes an access to an object that has volatile-qualified type is implementation-defined. If an attempt is made to refer to an object defined with a volatile-qualified type through the use of a glvalue with a non-volatile-qualified type,the program behavior is undefined.</p>
</blockquote>
<p>不要试图通过去除const限制符来修改对象，const限制符意味着API的设计者不想让被修饰的对象被修改尽管对象可以通过其他非常规手段修改。不要试图去除volatile限制符，该限制符意味着API的设计者想让编译器以未知的方式来访问该对象，其他任何访问volatile对象会导致未定义行为。</p>
<p>导致的结果是非正常程序终止或拒绝服务攻击(Denial of service attack)。</p>
<h4 id="代码样例对比-12"><a href="#代码样例对比-12" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;ci)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> &amp;ir = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span> &amp;&gt;(ci);</span><br><span class="line">  ir = <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">4</span>;</span><br><span class="line">  g(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上的代码很明显会导致未定义行为，把const属性去除了，再来修改。想要修改，就必须手动把const去除，如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> &amp;i)</span> </span>&#123;</span><br><span class="line">  i = <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">4</span>;</span><br><span class="line">  g(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码样例对比-13"><a href="#代码样例对比-13" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> cachedValue;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">compute_value</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// expensive</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  S() : cachedValue(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">get_value</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cachedValue) &#123;</span><br><span class="line">      <span class="keyword">const_cast</span>&lt;S *&gt;(<span class="keyword">this</span>)-&gt;cachedValue = compute_value();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cachedValue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> S s;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s.get_value() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上这段代码，首先看函数f(),类似S的对象s是用const修饰的，不可修改其状态，但是其成员函数get_value却通过const_cast this指针把const属性给去掉来修改cachedValue，这样就会导致未定义行为。</p>
<p>如果还是希望修改const修饰的s对象，以下有办法对这种情况做出妥协，不会导致未定义行为，但是这样的做法少有人做：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  <span class="keyword">mutable</span> <span class="keyword">int</span> cachedValue;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">compute_value</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// expensive</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  S() : cachedValue(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">get_value</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cachedValue) &#123;</span><br><span class="line">      cachedValue = compute_value();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cachedValue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> S s;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s.get_value() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是仅仅用mutable修饰cachedValue。</p>
<h4 id="代码样例对比-14"><a href="#代码样例对比-14" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  S(<span class="keyword">int</span> i) : i(i) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(S &amp;s)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s.i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">volatile</span> S <span class="title">s</span><span class="params">(<span class="number">12</span>)</span></span>;</span><br><span class="line">  g(<span class="keyword">const_cast</span>&lt;S &amp;&gt;(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码也是通过去除volatile属性来访问对象s，然后通过函数g()来试图读取s，这直接会导致未定义行为。要做以下修改：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  S(<span class="keyword">int</span> i) : i(i) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">volatile</span> S &amp;s)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s.i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">volatile</span> S <span class="title">s</span><span class="params">(<span class="number">12</span>)</span></span>;</span><br><span class="line">  g(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="EXP56-CPP-不要调用从语言链接上不匹配的函数"><a href="#EXP56-CPP-不要调用从语言链接上不匹配的函数" class="headerlink" title="EXP56-CPP. 不要调用从语言链接上不匹配的函数"></a>EXP56-CPP. 不要调用从语言链接上不匹配的函数</h3><p>严重程度：低，在C和C++之间不匹配的语言链接一般不会造成安全漏洞，但是C++和其他除C语言之外的不匹配语言链接会大概率导致非正常程序终止，包括安全漏洞。</p>
<p>C++允许使用语言链接规范来与其他语言互交通信。（也就是C++不通过网络方式可以调用其他语言的接口，或者其他语言可以调用C++的接口）。然而，这个语言规范定义了一套不同语言函数之间的调用方式和数据访问方式。</p>
<p>默认，所有的函数类型就是函数名和参数名，其外部链接都具有C++语言链接。C++标准对语言链接做出了以下描述:</p>
<blockquote>
<p> Two function types with different language linkages are distinct types even if they are otherwise identical.</p>
</blockquote>
<p>当跨语言调用一个不匹配的函数类型的时候，就会导致未定义行为。当语言链接不匹配时，就会破坏调用栈，就是因为调用约定或其他ABI不匹配造成了。</p>
<p>当然，许多编译器厂商没有实现不同语言链接的规范，尽管C++标准要求这么做。比如，在GCC 6.1.0 Clang 3.9和VS2015中都一致认为以下的代码是ill-formed的，因为f()的重定义优先级要比well-formed的f()的重载要高。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*cpp_func)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*c_func)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(cpp_func fp)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(c_func fp)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>虽然C++的编译器一般都遵守C++标准，但是在严格的遵守条件下，各样的C++编译器在实现C++标准上都会有分歧，也是因为实践取舍的考量。一些编译器仅仅支持了C和C++的语言链接。</p>
<p>请看下面的代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> *int_list, <span class="keyword">size_t</span> count)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::qsort(int_list, count, <span class="keyword">sizeof</span>(<span class="keyword">int</span>),[](<span class="keyword">const</span> <span class="keyword">void</span> *lhs, <span class="keyword">const</span> <span class="keyword">void</span> *rhs) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">int</span> *&gt;(lhs) &lt; <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">int</span> *&gt;(rhs);</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上的这段代码在调用qsort的函数的时候没匹配语言链接，但是实际上在VS2015 for x86上是允许的，尽管lambda函数调用操作符被隐式转换成了一个带有C++语言链接的一个函数指针，但是qsort函数其实是期望的是一个C语言链接的函数指针。</p>
<h4 id="代码样例对比-15"><a href="#代码样例对比-15" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"java"</span> <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*java_callback)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">call_java_fn_ptr</span><span class="params">(java_callback callback)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback_func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  call_java_fn_ptr(callback_func);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析以上代码，函数call_java_fn_ptr期望接收一个java语言链接的一个函数指针，因为该函数指针可能会被Java解释器使用，回调进C++的函数中。然而，在实际的调用中，却给出了一个带有C++链接的回调函数callback_func。这就导致了jAVA解释器在调用这个函数指针的时候，出现了未定义行为。可以改成以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"java"</span> <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*java_callback)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">call_java_fn_ptr</span><span class="params">(java_callback callback)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">"java"</span> <span class="function"><span class="keyword">void</span> <span class="title">callback_func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  call_java_fn_ptr(callback_func);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="EXP57-CPP-不要删除或转换指向不完整类的指针"><a href="#EXP57-CPP-不要删除或转换指向不完整类的指针" class="headerlink" title="EXP57-CPP. 不要删除或转换指向不完整类的指针"></a>EXP57-CPP. 不要删除或转换指向不完整类的指针</h3><p>严重等级：中等。转换或引用不完整类会导致错误的内存地址，通过指针删除不完整类（如果该类拥有不正确的析构函数）会导致未定义行为，程序终止，资源泄漏都可能发生。</p>
<p>C++标准[expr.delete]有如下描述：</p>
<blockquote>
<p>If the object being deleted has incomplete class type at the point of deletion and the complete class has a non-trivial destructor or a deallocation function, the behavior is undefined.</p>
</blockquote>
<h4 id="代码样例对比-16"><a href="#代码样例对比-16" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handle</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Body</span> *<span class="title">impl</span>;</span> <span class="comment">// Declaration of a pointer to an incomplete class</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ~Handle() &#123; <span class="keyword">delete</span> impl; &#125; <span class="comment">// Deletion of pointer to an incomplete class</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上的代码用了pimpl的模式实现了Handle类，但是却在其析构函数里面企图删除一个指向不完整类的指针，如果Body类没有正确的析构函数，那么就会导致未定义行为。应该改成下面:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handle</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Body</span> *<span class="title">impl</span>;</span></span><br><span class="line">  <span class="comment">// Declaration of a pointer to an incomplete class</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ~Handle();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Elsewhere</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Body</span> &#123;</span> <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"></span><br><span class="line">Handle::~Handle() &#123;</span><br><span class="line">  <span class="keyword">delete</span> impl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Body一定要有实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handle</span> &#123;</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Body</span>&gt; <span class="title">impl</span>;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Handle();</span><br><span class="line">  ~Handle() &#123;&#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>或者可以用以上的shared_ptr智能指针解决。它有能力指向不完整的类（Body类没有实现），而且不会出问题。但是std::unique_ptr就不能。</p>
<h4 id="代码样例对比-17"><a href="#代码样例对比-17" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File1.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">double</span> d;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  B() : d(<span class="number">1.0</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// File2.h</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(class D *)</span></span>;</span><br><span class="line"><span class="function">class B *<span class="title">get_d</span><span class="params">()</span></span>; <span class="comment">// Returns a pointer to a D object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// File1.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"File1.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"File2.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  B *v = get_d();</span><br><span class="line">  g(<span class="keyword">reinterpret_cast</span>&lt;class D *&gt;(v));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// File2.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"File2.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"File1.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hah</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">short</span> s;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Hah() : s(<span class="number">12</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> Hah, <span class="keyword">public</span> B &#123;</span><br><span class="line">  <span class="keyword">float</span> f;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  D() : Hah(), B(), f(<span class="number">1.2f</span>) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">do_something</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"f: "</span> &lt;&lt; f &lt;&lt; <span class="string">", d: "</span> &lt;&lt; d &lt;&lt; <span class="string">", s: "</span> &lt;&lt; s &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(D *d)</span> </span>&#123;</span><br><span class="line">  d-&gt;do_something();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">B *<span class="title">get_d</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> D;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>指针向下转换（把一个指向基类的指针转换为继承类的指针）可能需要调整一定量的指针指向的地址并且只有当类继承的结构的布局是已知的时候才能被决定。在以上代码中，函数f()通过get_d()得到了完整类型B的多态指针，然后这个指针在传入g()之前被转换成了不完整类型D的指针。这个转换有可能失败，然后对d-&gt;do_something()的调用就会导致未定义行为。</p>
<p>所以C++提供了dynamic_cast，就是运行时转换，这个转换只是尝试，一旦转换失败，那么返回的指针为nullptr。所以可以改成以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File1.h -- contents identical.</span></span><br><span class="line"><span class="comment">// File2.h</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(class B *)</span></span>; <span class="comment">// Accepts a B object, expects a D object</span></span><br><span class="line"><span class="function">class B *<span class="title">get_d</span><span class="params">()</span></span>; <span class="comment">// Returns a pointer to a D object</span></span><br><span class="line"><span class="comment">// File1.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"File1.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"File2.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  B *v = get_d();</span><br><span class="line">  g(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// File2.cpp</span></span><br><span class="line"><span class="comment">// ... all contents are identical until ...</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(B *d)</span> </span>&#123;</span><br><span class="line">  D *t = <span class="keyword">dynamic_cast</span>&lt;D *&gt;(d);</span><br><span class="line">  <span class="keyword">if</span> (t) &#123;</span><br><span class="line">    t-&gt;do_something();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Handle error</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B *get_d() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> D;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="EXP59-CPP-offsetof函数使用在合法的类型和成员上"><a href="#EXP59-CPP-offsetof函数使用在合法的类型和成员上" class="headerlink" title="EXP59-CPP. offsetof函数使用在合法的类型和成员上"></a>EXP59-CPP. offsetof函数使用在合法的类型和成员上</h3><p>严重等级：中等。不合法的类型或成员传入offsetof中会导致未定义行为，可能会因为数据完整性的破坏而执行非法代码。</p>
<p>offsetof宏是由C标准定义的可移植的方法，来判断给定的成员相对于对象起始位置的偏移（字节）。C语言标准有如下描述：</p>
<blockquote>
<p>offsetof(type, member-designator) which expands to an integer constant expression that has type size_t, the value of which is the offset in bytes, to the structure member (designated by member-designator), from the beginning of its structure (designated by type). The type and member designator shall be such that given static type t; then the expression &amp;(t.member-designator) evaluates to an address constant. (If the specified member is a bit-field, the behavior is undefined.)</p>
</blockquote>
<p>C++标准[support.types]也有如下增添的描述：</p>
<blockquote>
<p>The macro offsetof(type, member-designator) accepts a restricted set of type arguments in this International Standard. If type is not a standard-layout class, the results are undefined. The expression offsetof(type, member-designator) is never type-dependent and it is value-dependent if and only if type is dependent. The result of applying the offsetof macro to a field that is a static data member or a function member is undefined. No operation invoked by the offsetof macro shall throw an exception and noexcept(offsetof(type, member-designator)) shall be true.</p>
</blockquote>
<h4 id="代码样例对比-18"><a href="#代码样例对比-18" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> off = offsetof(D, i);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在以上代码中，类型D不是标准布局的类，所以传入offsetof宏中，会导致未定义行为。以上代码在VS2015 for x86上用/Wall警告全开的方式编译，不会产生任何警告。off的运行结果在VS2015上是4，是因为类型D有虚函数表指针的存在。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">InnerStandardLayout</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">  &#125; inner;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> off = offsetof(D::InnerStandardLayout, i);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就改了下代码，因为D类型不是标准布局的类，所以类型D中成员的i是不可能正确求出它的偏移的。然而，却可以在D中重新制造一个标准布局的类。</p>
<h4 id="代码样例对比-19"><a href="#代码样例对比-19" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> S::i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">store_in_some_buffer</span><span class="params">(<span class="keyword">void</span> *buffer, <span class="keyword">size_t</span> offset, <span class="keyword">int</span> val)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">void</span> *buffer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> off = offsetof(S, i);</span><br><span class="line">  store_in_some_buffer(buffer, off, <span class="number">42</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码也会导致未定义行为，因为i是类S的静态成员，因为C++标准中提到，静态数据成员不是类实例化对象的一部分。同样上面的代码在VS2015 x86下/Wall编译不会产生任何警告。所以是非常危险的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> S::i = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">store_in_some_buffer</span><span class="params">(<span class="keyword">void</span> *buffer, <span class="keyword">size_t</span> offset, <span class="keyword">int</span> val)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  store_in_some_buffer(&amp;S::i, <span class="number">0</span>, <span class="number">42</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以直接对i进行取地址，然后在上面存取数据。</p>
<h3 id="EXP60-CPP-不要跨执行边界传递非标准布局类型的对象"><a href="#EXP60-CPP-不要跨执行边界传递非标准布局类型的对象" class="headerlink" title="EXP60-CPP. 不要跨执行边界传递非标准布局类型的对象"></a>EXP60-CPP. 不要跨执行边界传递非标准布局类型的对象</h3><p>严重等级：高。影响非常广，要么正确，要么良好运行，要不导致未定义行为。</p>
<p>标准布局的类型一般被用来和其他编程语言通信，该类型的布局被严格定义，C++标准中[class]定义了一个标准布局的类需要满足以下条件。</p>
<ul>
<li>没有虚函数</li>
<li>对于所有的非静态数据成员要有相同的访问权限</li>
<li>与第一个非静态数据成员相同类型的类不能有基类</li>
<li>类中不能有非标准布局类型的非静态数据成员</li>
<li>在类的继承层级中只要有一个有非静态数据成员的类，那么它所有的子类包括它就是非标准布局类</li>
</ul>
<p>执行边界的定义就是不同的的编译器（包括不同版本的编译器）编译出来的代码二进制模块的边界。比如，一个函数声明在一个头文件中，但是函数定义是在库中，运行时才被载入。执行边界就是调用方的可执行文件调用库的二进制文件的边界。这样的边界有时候也被成为ABI边界，因为这跟二进制模块的互交有关。</p>
<p>不要对非标准布局的类型的对象布局作出任何特定假设。比如相同类型对象被不同编译器所编译的布局不同但是它们之间互相引用，这就导致了程序的移植和正确性问题。</p>
<p>如果真需要跨二进制边界传递非标准布局的类型对象，需要严格依赖两个通信模块相同的ABI。如果是不同编译器编译的两个模块，也需要严格依赖二者的ABI是兼容的。</p>
<h4 id="代码样例对比-20"><a href="#代码样例对比-20" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// library.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(S &amp;s)</span></span>; <span class="comment">// Implemented by the library, calls S::f()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//library.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(S &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//... any implementations</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// finally the library.cpp complied to the library.lib or library.so or library.dll </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// application.cpp finally complied to the application.exe or application.elf</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"library.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  S s;</span><br><span class="line">  func(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//application.exe calls library.dll</span></span><br></pre></td></tr></table></figure>
<p>以上代码根据之前的定义描述，就知道是有问题的代码。如果是不同编译器编译的这两个模块很容易导致预测不到的行为，软件的正常运行严格依赖不同编译器之间的二进制兼容。为了避免不必要的麻烦，应该提早检测，所以改成如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// library.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="comment">/* ... */</span> &#125; <span class="comment">// No longer virtual</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static_assert</span>(<span class="built_in">std</span>::is_standard_layout&lt;S&gt;::value, <span class="string">"S is required to be a standard layout type"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(S &amp;s)</span></span>; <span class="comment">// Implemented by the library, calls S::f()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// application.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"library.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  S s;</span><br><span class="line">  func(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上的代码就删除虚函数的标记，把类型S改为标准布局的C++类，并用静态断言再次保证类型S为标准布局的类。这样可以提早提醒开发人员，避免遗漏这个隐患。</p>
<h4 id="代码样例对比-21"><a href="#代码样例对比-21" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//app.cpp</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> i, j;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span> :</span> B &#123;</span><br><span class="line">  <span class="keyword">float</span> f;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//library.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"Fortran"</span> <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//library.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>* )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//app.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(D *d)</span> </span>&#123;</span><br><span class="line">  func(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上的代码显示，一个指向非标准布局类的指针在foo函数中被传入了一个具有Fortran语言链接的func函数中，这样显然是不正确的，可能会导致非确定行为，有安全隐患。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> i, j;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span> :</span> B &#123;</span><br><span class="line">  <span class="keyword">float</span> f;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"Fortran"</span> <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(D *d)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">  &#125; temp;</span><br><span class="line"></span><br><span class="line">  temp.i = d-&gt;i;</span><br><span class="line">  temp.j = d-&gt;j;</span><br><span class="line">  temp.f = d-&gt;f;</span><br><span class="line">  func(&amp;temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码只改了一个地方，就是把非标准布局类型D序列化成局部标准布局类型，然后再传入func中。这样就完美了。</p>
<h3 id="EXP61-CPP-一个lambda对象在生命周期必须在它所引用捕获的对象生命周期内"><a href="#EXP61-CPP-一个lambda对象在生命周期必须在它所引用捕获的对象生命周期内" class="headerlink" title="EXP61-CPP. 一个lambda对象在生命周期必须在它所引用捕获的对象生命周期内"></a>EXP61-CPP. 一个lambda对象在生命周期必须在它所引用捕获的对象生命周期内</h3><p>严重程度：高。实际上本质来说，就是捕获引用到了一个处于它自身声明周期外的对象。</p>
<p>这里不介绍lambda捕获列表的知识点，直接看代码样例分析。</p>
<h4 id="代码样例对比-22"><a href="#代码样例对比-22" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">12</span>;</span><br><span class="line">  <span class="keyword">return</span> [&amp;] &#123;</span><br><span class="line">    i = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> j = g()();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码很简单了，g()函数返回了一个lambda函数，但是这个lambda函数以引用捕获了局部变量i，然后g()函数返回完成，i的生命周期已经完结。然而，返回的lambda函数还持有i的引用，并且被调用了，对i进行了i=100的访问。这直接导致未定义行为。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">12</span>;</span><br><span class="line">  <span class="keyword">return</span> [=] () <span class="keyword">mutable</span> &#123;</span><br><span class="line">    i = <span class="number">100</span>; </span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> j = g()();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>知道了原因很容易改正确，把lambda函数的引用捕获改成值传递捕获，这样i就是lambda的隐式的非静态数据成员，而且i的生命周期与lambda的生命周期就绑定了，简单来说，i的生命周期就是lambda的生命周期。</p>
<h4 id="代码样例对比-23"><a href="#代码样例对比-23" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> outer = [val] &#123;</span><br><span class="line">    <span class="keyword">int</span> i = val;</span><br><span class="line">    <span class="keyword">auto</span> inner = [&amp;] &#123;</span><br><span class="line">      i += <span class="number">30</span>;</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> inner;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> outer();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> fn = g(<span class="number">12</span>);</span><br><span class="line">  <span class="keyword">int</span> j = fn();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面代码可以看出。inner的lambda函数引用捕获了outer lambda函数的局部变量，但是inner函数对变量i的访问超出了outer函数和变量i的生命周期，，所以会导致未定义行为。这样就改成以下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> outer = [val] &#123;</span><br><span class="line">    <span class="keyword">int</span> i = val;</span><br><span class="line">    <span class="keyword">auto</span> inner = [i] &#123;</span><br><span class="line">      <span class="keyword">return</span> i + <span class="number">30</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> inner;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> outer();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> fn = g(<span class="number">12</span>);</span><br><span class="line">  <span class="keyword">int</span> j = fn();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="EXP62-CPP-不要访问不属于对象的value-representation的bit位域"><a href="#EXP62-CPP-不要访问不属于对象的value-representation的bit位域" class="headerlink" title="EXP62-CPP. 不要访问不属于对象的value representation的bit位域"></a>EXP62-CPP. 不要访问不属于对象的value representation的bit位域</h3><p>严重等级：高。依赖于Bit位的访问会导致implementation-defined的行为以及恶意代码执行的后果。</p>
<p>C++标准[basic.types]对于对象的value representation有如下说明：</p>
<blockquote>
<p>The object representation of an object of type T is the sequence of N unsigned char objects taken up by the object of type T, where N equals sizeof(T). The value representation of an object is the set of bits that hold the value of type T.</p>
</blockquote>
<h4 id="代码样例对比-24"><a href="#代码样例对比-24" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> buffType;</span><br><span class="line">  <span class="keyword">int</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> S &amp;s1, <span class="keyword">const</span> S &amp;s2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">std</span>::<span class="built_in">memcmp</span>(&amp;s1, &amp;s2, <span class="keyword">sizeof</span>(S))) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码片段很明显的可以看出，作者想用object presentation的对比两个对象是否相等，但是这是很可能出问题的，根据C++标准，类的内存布局可能会因为内存对齐而被编译器插入padding位。这就导致了这些padding位的具体内容是implementation-defined的。所以我们不能依赖实现。因为两个对象的padding位的具体内容可能不同，造成比较对象不正确。</p>
<p>改成以下代码手工对比：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> buffType;</span><br><span class="line">  <span class="keyword">int</span> size;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> S &amp;lhs, <span class="keyword">const</span> S &amp;rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.buffType == rhs.buffType &amp;&amp; lhs.size == rhs.size;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> S &amp;s1, <span class="keyword">const</span> S &amp;s2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (s1 == s2) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码样例对比-25"><a href="#代码样例对比-25" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> i, j, k;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  S *s = <span class="keyword">new</span> S;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(S));</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  s-&gt;f(); <span class="comment">// undefined behavior</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码意图通过memset把S类型的s对象置0，如果S类型没有虚函数还好，但是错误就在S类型有虚函数，所以s对象有个虚函数表的指针，这个指针的值也被置为0了。这显然是意料之外。一旦调用虚函数，那么该指针无效，引发未定义行为。如果对于这种类型，最好自己写一个清空函数，如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> i, j, k;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; i = j = k = <span class="number">0</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  S *s = <span class="keyword">new</span> S;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  s-&gt;clear();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  s-&gt;f(); <span class="comment">// ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码看clear()函数的实现，把非静态数据成员全部置为0了，而且也没有覆盖虚函数表指针。</p>
<h3 id="EXP63-CPP-不要依赖moved-from对象的值"><a href="#EXP63-CPP-不要依赖moved-from对象的值" class="headerlink" title="EXP63-CPP. 不要依赖moved-from对象的值"></a>EXP63-CPP. 不要依赖moved-from对象的值</h3><p>严重程度： 中等。一般来说，moved-from对象的状态是合法的，但是状态是未指定的。依赖非指定的值可能会导致程序非正常终止也会导致数据完整性违例。</p>
<p>许多类型，包括用户自定义的类型，还有STL所提供的类型都支持move语义（移动语义）。</p>
<p>如果一个函数的参数是某类型对象的右值引用，那么当该函数调用的时候，函数参数对象就会隐式调用自身的移动赋值函数或者移动构造函数。所谓移动就是把一个对象的状态移动到另一个对象中，这就产生了，前一个对象状态被掏空，处于一个未指定值的状态，所以不能依赖前一个对象的值。</p>
<h4 id="代码样例对比-26"><a href="#代码样例对比-26" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> &amp;&amp;v)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    s.append(<span class="number">1</span>, <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(<span class="string">'0'</span> + i));</span><br><span class="line">    g(<span class="built_in">std</span>::move(s));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上这段代码为了提高性能，g()函数的参数用了std::string的右值引用。首先对象s和g()函数的操作都在for循环中，开始的第一步不会有问题，但是第一步最后std::move把对象s的状态给掏空了，处于未指定状态，但是第二步开始，又对这个对象s进行append操作，这就导致了问题了,非期待的输出结果。</p>
<p>知道了原因，就好办了，不应该依赖被移动过的对象的状态，应该新创建一个对象，代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> &amp;&amp;v)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="number">1</span>, <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(<span class="string">'0'</span> + i))</span></span>;</span><br><span class="line">    g(<span class="built_in">std</span>::move(s));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码样例对比-27"><a href="#代码样例对比-27" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;c)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::remove(c.begin(), c.end(), <span class="number">42</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> v : c) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Container element: "</span> &lt;&lt; v &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上的代码元素42被移除以后，那么vector c的迭代范围就是非法的范围了，强制进行range for会导致非指定行为(unspecified behavior)。</p>
<p>可以用以下两种方式来改正:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;c)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> e = <span class="built_in">std</span>::remove(c.begin(), c.end(), <span class="number">42</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i = c.begin(); i != c.end(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; e) &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>换一种方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;c)</span> </span>&#123;</span><br><span class="line">  c.erase(<span class="built_in">std</span>::remove(c.begin(), c.end(), <span class="number">42</span>), c.end());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> v : c) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Container element: "</span> &lt;&lt; v &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://alexiachen.github.io/blog/2017/06/29/cert-cpp-one/" data-id="cjtctmcin009sqfqfrqc9zhfw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/C-C/">C/C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/CERT/">CERT</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-cert-cpp-zero" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2017/06/02/cert-cpp-zero/" class="article-date">
  <time datetime="2017-06-02T09:16:53.000Z" itemprop="datePublished">2017-06-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2017/06/02/cert-cpp-zero/">CERT C++编码规范翻译（DCL）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><hr>
<p>本文翻译自<a href="http://www.cert.org/" target="_blank" rel="noopener">CERT</a>(计算机安全应急响应组)提供的C++安全编码规范（2016版），与其他规范不一样的是，该规范侧重软件安全的编码规范。翻译不完全逐字段翻译，可能有简化删改。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><hr>
<h2 id="声明与初始化（DCL）"><a href="#声明与初始化（DCL）" class="headerlink" title="声明与初始化（DCL）"></a>声明与初始化（DCL）</h2><h3 id="DCL50-CPP-不要定义C风格的可变参函数"><a href="#DCL50-CPP-不要定义C风格的可变参函数" class="headerlink" title="DCL50-CPP 不要定义C风格的可变参函数"></a>DCL50-CPP 不要定义C风格的可变参函数</h3><p>严重等级：高</p>
<ul>
<li>C风格的可变参函数的参数没有类型安全保证，也就是说，编译器不检查参数的类型是否匹配，如果类型不匹配这样会导致运行时出现未定义行为。这样的未定义行为可以让黑客很容易构造非法运行的代码（exploit）。</li>
</ul>
<h4 id="不允许的代码样例"><a href="#不允许的代码样例" class="headerlink" title="不允许的代码样例"></a>不允许的代码样例</h4><p>这个函数读取参数直到0才会终止循环，如果不以0终止参数，那么这个函数就会出现未定义行为。如果不小心传递成了其他非int类型的参数，那么编译阶段不会报错，运行时将出现未定义行为。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdarg&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> second, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = first + second;</span><br><span class="line">    va_list va;</span><br><span class="line">    va_start(va,second);</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">int</span> v = va_arg(va, <span class="keyword">int</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        r += v;</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(va);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">0</span>); <span class="comment">// print 10</span></span><br><span class="line">add(<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>); <span class="comment">//can be any number or even crash your PC</span></span><br></pre></td></tr></table></figure></p>
<h4 id="允许的代码样例（递归包扩展）"><a href="#允许的代码样例（递归包扩展）" class="headerlink" title="允许的代码样例（递归包扩展）"></a>允许的代码样例（递归包扩展）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Arg, <span class="keyword">typename</span> </span><br><span class="line"><span class="built_in">std</span>::enable_if&lt;<span class="built_in">std</span>::is_integral&lt;Arg&gt;::value&gt;::type * = <span class="literal">nullptr</span>&gt;</span><br><span class="line"><span class="keyword">int</span> add(Arg f, Arg s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> f + s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Arg, <span class="keyword">typename</span>... Ts, <span class="keyword">typename</span></span><br><span class="line"><span class="built_in">std</span>::enable_if&lt;<span class="built_in">std</span>::is_integral&lt;Arg&gt;::value&gt;::type * = <span class="literal">nullptr</span>&gt;</span><br><span class="line"><span class="keyword">int</span> add(Arg f, Ts... tail)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> f + add(tail...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add&lt;&gt;(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>); <span class="comment">//print 12</span></span><br><span class="line">add&lt;&gt;(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="string">'c'</span>); <span class="comment">// compile error</span></span><br></pre></td></tr></table></figure>
<p>以上的样例利用了std::enable_if来保证任何非整型的参数会导致ill-formed的程序。</p>
<h4 id="允许的代码样例（大括号初始化列表扩展）"><a href="#允许的代码样例（大括号初始化列表扩展）" class="headerlink" title="允许的代码样例（大括号初始化列表扩展）"></a>允许的代码样例（大括号初始化列表扩展）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Arg, <span class="keyword">typename</span>... Ts, <span class="keyword">typename</span></span><br><span class="line"><span class="built_in">std</span>::enable_if&lt;<span class="built_in">std</span>::is_integral&lt;Arg&gt;::value&gt;::type * = <span class="literal">nullptr</span>&gt;</span><br><span class="line"><span class="keyword">int</span> add(Arg i, Arg j, Ts... all)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> values[] = &#123; i, j, all... &#125;;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : values)</span><br><span class="line">    &#123;</span><br><span class="line">        r += v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add&lt;&gt;(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>); <span class="comment">//print 12</span></span><br><span class="line">add&lt;&gt;(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="string">'c'</span>); <span class="comment">// compile error</span></span><br></pre></td></tr></table></figure>
<h3 id="DCL51-CPP-不要声明或定义保留标识符"><a href="#DCL51-CPP-不要声明或定义保留标识符" class="headerlink" title="DCL51-CPP 不要声明或定义保留标识符"></a>DCL51-CPP 不要声明或定义保留标识符</h3><p>严重等级：低</p>
<ul>
<li>避免与编译器的符号冲突</li>
</ul>
<h4 id="代码样例对比（Header-Guard）"><a href="#代码样例对比（Header-Guard）" class="headerlink" title="代码样例对比（Header Guard）"></a>代码样例对比（Header Guard）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bad</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _MY_HEADER_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _MY_HEADER_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// _MY_HEADER_H_</span></span></span><br></pre></td></tr></table></figure>
<p>以上样例，大部分C++ 头文件是这样写法，自己写的头文件加前缀后缀下划线容易冲突</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//good</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MY_HEADER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_HEADER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// MY_HEADER_H</span></span></span><br></pre></td></tr></table></figure>
<h4 id="代码样例对比（自定义字面量）"><a href="#代码样例对比（自定义字面量）" class="headerlink" title="代码样例对比（自定义字面量）"></a>代码样例对比（自定义字面量）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bad</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">operator</span><span class="string">""</span> x(<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="built_in">std</span>::<span class="keyword">size_t</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//good</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">operator</span><span class="string">""</span> _x(<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="built_in">std</span>::<span class="keyword">size_t</span>);</span><br></pre></td></tr></table></figure>
<h4 id="代码样例对比（文件作用域对象）"><a href="#代码样例对比（文件作用域对象）" class="headerlink" title="代码样例对比（文件作用域对象）"></a>代码样例对比（文件作用域对象）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bad</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt; // std::for size_t</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> _max_limit = <span class="number">1024</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">size_t</span> _limit = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">get_value</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> count &lt; _limit ? count : _limit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//good</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt; // for size_t</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> max_limit = <span class="number">1024</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">size_t</span> limit = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">get_value</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> count &lt; limit ? count : limit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码样例对比（保留的宏）"><a href="#代码样例对比（保留的宏）" class="headerlink" title="代码样例对比（保留的宏）"></a>代码样例对比（保留的宏）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bad</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cinttypes&gt; // for int_fast16_t</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">int_fast16_t</span> val)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">enum</span> &#123; MAX_SIZE = <span class="number">80</span> &#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//good</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cinttypes&gt; // for std::int_fast16_t</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">int_fast16_t</span> val)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">enum</span> &#123; BufferSize = <span class="number">80</span> &#125;;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DCL52-CPP-不要用const或volatile限定一个引用类型"><a href="#DCL52-CPP-不要用const或volatile限定一个引用类型" class="headerlink" title="DCL52-CPP 不要用const或volatile限定一个引用类型"></a>DCL52-CPP 不要用const或volatile限定一个引用类型</h3><p>严重等级：低</p>
<ul>
<li>C++会阻止或忽略这样的限定，只有非引用类型的值才能这样限定。</li>
</ul>
<h4 id="代码样例对比"><a href="#代码样例对比" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bad</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> &amp;<span class="keyword">const</span> p = c; <span class="comment">// plz instead of char const &amp;p;  Or: const char &amp;p;</span></span><br><span class="line">p = <span class="string">'p'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码，会导致未定义行为，在VS2013 VS2015下，这段代码编译时会有警告warning C4227: anachronism used : qualifiers on reference are ignored。运行结果会是p，const 没有产生任何期望的作用。</p>
<p>在Clang 3.9下，这段代码直接产生编译错误error: ‘const’ qualifier may not be applied to a reference</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//good</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> &amp;p = c;</span><br><span class="line">  p = <span class="string">'p'</span>; <span class="comment">//产生期望结果，编译错误，及时发现</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DCL53-CPP-不要写在语法上引起歧义的声明"><a href="#DCL53-CPP-不要写在语法上引起歧义的声明" class="headerlink" title="DCL53-CPP 不要写在语法上引起歧义的声明"></a>DCL53-CPP 不要写在语法上引起歧义的声明</h3><p>严重等级：低</p>
<ul>
<li>因为依赖编译器的起义规则来决定该声明的语义结果</li>
</ul>
<h4 id="代码样例对比-1"><a href="#代码样例对比-1" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bad</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::mutex m;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> shared_resource;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increment_by_42</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt;(m);</span><br><span class="line">  shared_resource += <span class="number">42</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上样例是一个匿名的std::unique_lock对象，这样的语法歧义可能会被编译器解释成：</p>
<ul>
<li>声明一个匿名std::unique_lock对象，并且调用自身的单参转化构造函数</li>
<li>声明了一个名为m的std::unique_lock对象，然后调用默认的构造函数构造</li>
</ul>
<p>如果是情况2，那么m这个互斥量就永远不会被锁上了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//good</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::mutex m;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> shared_resource;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increment_by_42</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(m); <span class="comment">//一定要加上对象名字</span></span><br><span class="line">  shared_resource += <span class="number">42</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码样例对比-2"><a href="#代码样例对比-2" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">  Widget() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Constructed"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Widget <span class="title">w</span><span class="params">()</span></span>; <span class="comment">// 有歧义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上的代码本意是想声明一个类型为Widget局部变量w，然后执行它的默认构造函数。然而，这个声明有语法歧义，还可能是一个函数声明，这个函数是一个无参并且返回类型为Widget的函数。</p>
<p>所以，如果是第二种，那么程序根本就不会如你预想的输出Constructed文本。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">Widget() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Constructed"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Widget w1; <span class="comment">// Elide the parentheses</span></span><br><span class="line">Widget w2&#123;&#125;; <span class="comment">// Use direct initialization</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上使用正确的初始化方法才能如预想工作。</p>
<h4 id="代码样例对比-3"><a href="#代码样例对比-3" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Widget</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Widget constructed"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Gadget</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Gadget</span><span class="params">(Widget wid)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Gadget constructed"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">3</span>;</span><br><span class="line">  <span class="function">Gadget <span class="title">g</span><span class="params">(Widget(i))</span></span>;<span class="comment">// 该声明有歧义</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上的声明有歧义，不会被解释为一个Gadget类型的对象g，而是被解释成函数g，返回类型为Gadget。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Widget</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Widget constructed"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Gadget</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Gadget</span><span class="params">(Widget wid)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Gadget constructed"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">3</span>;</span><br><span class="line">  <span class="function">Gadget <span class="title">g1</span><span class="params">((Widget(i)))</span></span>; <span class="comment">// Use extra parentheses</span></span><br><span class="line">  Gadget g2&#123;Widget(i)&#125;; <span class="comment">// Use direct initialization</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上的代码才会正确输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Widget constructed</span><br><span class="line">Gadget constructed</span><br><span class="line">Widget constructed</span><br><span class="line">Gadget constructed</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<h3 id="DCL54-CPP-在同一个作用域同时重载alloc和dealloc的函数"><a href="#DCL54-CPP-在同一个作用域同时重载alloc和dealloc的函数" class="headerlink" title="DCL54-CPP 在同一个作用域同时重载alloc和dealloc的函数"></a>DCL54-CPP 在同一个作用域同时重载alloc和dealloc的函数</h3><p>严重等级：低</p>
<ul>
<li>比如，一个重载的alloc函数使用私有堆来创建它的分配，传递进去的指针的值被默认的dealloc函数返回可能会导致未定义行为。</li>
</ul>
<h4 id="代码样例对比-4"><a href="#代码样例对比-4" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> size)</span> <span class="title">noexcept</span><span class="params">(<span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Private, expandable heap.</span></span><br><span class="line">  <span class="keyword">static</span> HANDLE h = ::HeapCreate(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (h) &#123;</span><br><span class="line">    <span class="keyword">return</span> ::HeapAlloc(h, <span class="number">0</span>, size);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="built_in">std</span>::bad_alloc();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// No corresponding global delete operator defined.</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">以上样例中，alloc函数是在全局作用域中重载的，然而，与之匹配的dealloc函数却没有声明，如果有一个对象是这个重载的alloc函数分配的，那么用默认的<span class="keyword">delete</span> 删除对象的时候会导致未定义行为</span><br><span class="line"></span><br><span class="line">``` cpp</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeapAllocator</span> &#123;</span></span><br><span class="line">  <span class="keyword">static</span> HANDLE h;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">bool</span> init;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">alloc</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> size)</span> <span class="title">noexcept</span><span class="params">(<span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!init) &#123;</span><br><span class="line">      h = ::HeapCreate(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// Private, expandable heap.</span></span><br><span class="line">      init = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (h) &#123;</span><br><span class="line">      <span class="keyword">return</span> ::HeapAlloc(h, <span class="number">0</span>, size);</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">std</span>::bad_alloc();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dealloc</span><span class="params">(<span class="keyword">void</span> *ptr)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h) &#123;</span><br><span class="line">      (<span class="keyword">void</span>)::HeapFree(h, <span class="number">0</span>, ptr);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HANDLE HeapAllocator::h = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">bool</span> HeapAllocator::init = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> size)</span> <span class="title">noexcept</span><span class="params">(<span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> HeapAllocator::alloc(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *ptr)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> HeapAllocator::dealloc(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码样例对比-5"><a href="#代码样例对比-5" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C++"</span> <span class="function"><span class="keyword">void</span> <span class="title">update_bookkeeping</span><span class="params">(<span class="keyword">void</span> *allocated_ptr,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="built_in">std</span>::<span class="keyword">size_t</span> size, <span class="keyword">bool</span> alloc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> size)</span> <span class="title">noexcept</span><span class="params">(<span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr = ::<span class="keyword">operator</span> <span class="keyword">new</span>(size);</span><br><span class="line">    update_bookkeeping(ptr, size, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上代码，operator new() 实在类作用域重载的，但是却没有与之匹配的在类作用域重载的delete，所以当然分配好的类S的对象，需要删除的时候，调用的是全局默认的delete函数，这样就会导致程序处于一个未确定状态（未定义行为）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C++"</span> <span class="function"><span class="keyword">void</span> <span class="title">update_bookkeeping</span><span class="params">(<span class="keyword">void</span> *allocated_ptr,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="built_in">std</span>::<span class="keyword">size_t</span> size, <span class="keyword">bool</span> alloc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> size)</span> <span class="title">noexcept</span><span class="params">(<span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr = ::<span class="keyword">operator</span> <span class="keyword">new</span>(size);</span><br><span class="line">    update_bookkeeping(ptr, size, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//需要一个与之匹配的delete</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="built_in">std</span>::<span class="keyword">size_t</span> size)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(ptr)</span></span>;</span><br><span class="line">    update_bookkeeping(ptr, size, <span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="DCL55-CPP-当传递一个类对象需要跨边界的时候要避免信息泄露"><a href="#DCL55-CPP-当传递一个类对象需要跨边界的时候要避免信息泄露" class="headerlink" title="DCL55-CPP 当传递一个类对象需要跨边界的时候要避免信息泄露"></a>DCL55-CPP 当传递一个类对象需要跨边界的时候要避免信息泄露</h3><p>严重等级：低</p>
<p>C++标准对于非union类的非静态数据成员的布局如下所述：</p>
<blockquote>
<p>Nonstatic data members of a (non-union) class with the same access control are<br>allocated so that later members have higher addresses within a class object. The order<br>of allocation of non-static data members with different access control is unspecified.<br>Implementation alignment requirements might cause two adjacent members not to be<br>allocated immediately after each other; so might requirements for space for managing<br>virtual functions and virtual base classes.</p>
</blockquote>
<p>还有，关于类位域（bit-fields）的声明如下：</p>
<blockquote>
<p>Allocation of bit-fields within a class object is implementation-defined. Alignment of bitfields is implementation-defined. Bit-fields are packed into some addressable allocation<br>unit.</p>
</blockquote>
<p>因此 padding bits可能出现在类对象实例中的任何内存地址上，这就导致其中可能包含一些敏感信息。</p>
<h4 id="代码样例对比-6"><a href="#代码样例对比-6" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bad</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  <span class="keyword">char</span> b;</span><br><span class="line">  <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Safely copy bytes to user space</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">copy_to_user</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">void</span> *src, <span class="built_in">std</span>::<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_stuff</span><span class="params">(<span class="keyword">void</span> *usr_buf)</span> </span>&#123;</span><br><span class="line">  test arg&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">  copy_to_user(usr_buf, &amp;arg, <span class="keyword">sizeof</span>(arg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果以上代码运行在操作系统的内核空间，它把数据arg拷贝到用户空间，然而，这个test类型的对象可能有padding-bits（内存对齐），比如，为了保证类数据成员的对齐，这个padding-bits可能包含敏感信息，然后就导致这些信息从内核空间随着拷贝泄露到用户空间了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  <span class="keyword">char</span> b;</span><br><span class="line">  <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Safely copy bytes to user space</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">copy_to_user</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">void</span> *src, <span class="built_in">std</span>::<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_stuff</span><span class="params">(<span class="keyword">void</span> *usr_buf)</span> </span>&#123;</span><br><span class="line">  test arg&#123;&#125;;</span><br><span class="line">  arg.a = <span class="number">1</span>;</span><br><span class="line">  arg.b = <span class="number">2</span>; <span class="comment">// 关键在这里</span></span><br><span class="line">  arg.c = <span class="number">3</span>;</span><br><span class="line">  copy_to_user(usr_buf, &amp;arg, <span class="keyword">sizeof</span>(arg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上这段代码倒是在使用前用初始化保证了arg对象的字段都初始化为0了，用memset也可以达到同样效果。但是编译器对arg.b = 2 这个赋值的实现是自由的，也就是说，各个厂商的编译器实现可能不一样。可能有些编译器仅仅只是把最低8位赋值为2，高24位（padding-bits）没有变化，最后就导致高位字节随着拷贝泄漏到用户空间了。</p>
<p>其实可以给出以下两种方案解决这个信息泄露问题</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  <span class="keyword">char</span> b;</span><br><span class="line">  <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Safely copy bytes to user space.</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">copy_to_user</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">void</span> *src, <span class="built_in">std</span>::<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_stuff</span><span class="params">(<span class="keyword">void</span> *usr_buf)</span> </span>&#123;</span><br><span class="line">  test arg&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">  <span class="comment">// May be larger than strictly needed.</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> buf[<span class="keyword">sizeof</span>(arg)];</span><br><span class="line">  <span class="built_in">std</span>::<span class="keyword">size_t</span> offset = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">memcpy</span>(buf + offset, &amp;arg.a, <span class="keyword">sizeof</span>(arg.a));</span><br><span class="line">  offset += <span class="keyword">sizeof</span>(arg.a);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">memcpy</span>(buf + offset, &amp;arg.b, <span class="keyword">sizeof</span>(arg.b));</span><br><span class="line">  offset += <span class="keyword">sizeof</span>(arg.b);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">memcpy</span>(buf + offset, &amp;arg.c, <span class="keyword">sizeof</span>(arg.c));</span><br><span class="line">  offset += <span class="keyword">sizeof</span>(arg.c);</span><br><span class="line">  copy_to_user(usr_buf, buf, offset <span class="comment">/* size of info copied */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上这段代码就保证了未初始化的padding-bits不会被拷贝到用户空间去。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  <span class="keyword">char</span> b;</span><br><span class="line">  <span class="keyword">char</span> padding_1, padding_2, padding_3;</span><br><span class="line">  <span class="keyword">int</span> c;</span><br><span class="line">  test(<span class="keyword">int</span> a, <span class="keyword">char</span> b, <span class="keyword">int</span> c) : a(a), b(b),</span><br><span class="line">  padding_1(<span class="number">0</span>), padding_2(<span class="number">0</span>), padding_3(<span class="number">0</span>),</span><br><span class="line">  c(c) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ensure c is the next byte after the last padding byte.</span></span><br><span class="line"><span class="keyword">static_assert</span>(offsetof(test, c) == offsetof(test, padding_3) + <span class="number">1</span>,</span><br><span class="line"><span class="string">"Object contains intermediate padding"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ensure there is no trailing padding.</span></span><br><span class="line"><span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(test) == offsetof(test, c) + <span class="keyword">sizeof</span>(<span class="keyword">int</span>),</span><br><span class="line"><span class="string">"Object contains trailing padding"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Safely copy bytes to user space.</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">copy_to_user</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">void</span> *src, <span class="built_in">std</span>::<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_stuff</span><span class="params">(<span class="keyword">void</span> *usr_buf)</span> </span>&#123;</span><br><span class="line">  test arg&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">  copy_to_user(usr_buf, &amp;arg, <span class="keyword">sizeof</span>(arg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码是通过显式声明padding-bits，但是这个方案不具有可移植性，因为依赖目标内存的架构与实现。以上代码是限定于x86-32的平台。</p>
<h4 id="代码样例对比-7"><a href="#代码样例对比-7" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~base() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> base &#123;</span><br><span class="line">  alignas(<span class="number">32</span>) <span class="keyword">double</span> h;</span><br><span class="line">  <span class="keyword">char</span> i;</span><br><span class="line">  <span class="keyword">unsigned</span> j : <span class="number">80</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">unsigned</span> k;</span><br><span class="line">  <span class="keyword">unsigned</span> l : <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> m : <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">char</span> n;</span><br><span class="line">  <span class="keyword">double</span> o;</span><br><span class="line">  test(<span class="keyword">double</span> h, <span class="keyword">char</span> i, <span class="keyword">unsigned</span> j, <span class="keyword">unsigned</span> k, <span class="keyword">unsigned</span> l,<span class="keyword">unsigned</span> <span class="keyword">short</span> m, <span class="keyword">char</span> n, <span class="keyword">double</span> o) :h(h), i(i), j(j), k(k), l(l), m(m), n(n), o(o) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Safely copy bytes to user space.</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">copy_to_user</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">void</span> *src, <span class="built_in">std</span>::<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_stuff</span><span class="params">(<span class="keyword">void</span> *usr_buf)</span> </span>&#123;</span><br><span class="line">  test arg&#123;<span class="number">0.0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7.0</span>&#125;;</span><br><span class="line">  copy_to_user(usr_buf, &amp;arg, <span class="keyword">sizeof</span>(arg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码可能还是会把padding-bits泄露到用户空间中，因为padding-bits是implementation-defined，所以对象内存布局在各个编译器下不一样。可能出现以下的情况：</p>
<ul>
<li><p>为了对齐产生的padding-bits在虚函数表之后，或者在虚基类的数据之后。之后才是各种数据成员</p>
</li>
<li><p>padding-bits可能在各个拥有不同访问控制权限的数据成员之间</p>
</li>
<li><p>可能编译器会在类的实例中开辟出一个专门存放padding-bits的数组，这个数组位置也是implementation-defined</p>
</li>
</ul>
<p>以下给出解决方案：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~base() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> base &#123;</span><br><span class="line">  alignas(<span class="number">32</span>) <span class="keyword">double</span> h;</span><br><span class="line">  <span class="keyword">char</span> i;</span><br><span class="line">  <span class="keyword">unsigned</span> j : <span class="number">80</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">unsigned</span> k;</span><br><span class="line">  <span class="keyword">unsigned</span> l : <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> m : <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">char</span> n;</span><br><span class="line">  <span class="keyword">double</span> o;</span><br><span class="line">  test(<span class="keyword">double</span> h, <span class="keyword">char</span> i, <span class="keyword">unsigned</span> j, <span class="keyword">unsigned</span> k, <span class="keyword">unsigned</span> l,<span class="keyword">unsigned</span> <span class="keyword">short</span> m, <span class="keyword">char</span> n, <span class="keyword">double</span> o) :h(h), i(i), j(j), k(k), l(l), m(m), n(n), o(o) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">serialize</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *buffer, <span class="built_in">std</span>::<span class="keyword">size_t</span> &amp;size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="keyword">sizeof</span>(test)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> offset = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">memcpy</span>(buffer + offset, &amp;h, <span class="keyword">sizeof</span>(h));</span><br><span class="line">    offset += <span class="keyword">sizeof</span>(h);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">memcpy</span>(buffer + offset, &amp;i, <span class="keyword">sizeof</span>(i));</span><br><span class="line">    offset += <span class="keyword">sizeof</span>(i);</span><br><span class="line">    <span class="comment">// Only sizeof(unsigned) bits are valid, so the following is</span></span><br><span class="line">    <span class="comment">// not narrowing.</span></span><br><span class="line">    <span class="keyword">unsigned</span> loc_j = j;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">memcpy</span>(buffer + offset, &amp;loc_j, <span class="keyword">sizeof</span>(loc_j));</span><br><span class="line">    offset += <span class="keyword">sizeof</span>(loc_j);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">memcpy</span>(buffer + offset, &amp;k, <span class="keyword">sizeof</span>(k));</span><br><span class="line">    offset += <span class="keyword">sizeof</span>(k);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> loc_l = l &amp; <span class="number">0b1111</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">memcpy</span>(buffer + offset, &amp;loc_l, <span class="keyword">sizeof</span>(loc_l));</span><br><span class="line">    offset += <span class="keyword">sizeof</span>(loc_l);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> loc_m = m &amp; <span class="number">0b111</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">memcpy</span>(buffer + offset, &amp;loc_m, <span class="keyword">sizeof</span>(loc_m));</span><br><span class="line">    offset += <span class="keyword">sizeof</span>(loc_m);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">memcpy</span>(buffer + offset, &amp;n, <span class="keyword">sizeof</span>(n));</span><br><span class="line">    offset += <span class="keyword">sizeof</span>(n);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">memcpy</span>(buffer + offset, &amp;o, <span class="keyword">sizeof</span>(o));</span><br><span class="line">    offset += <span class="keyword">sizeof</span>(o);</span><br><span class="line">    size -= offset;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Safely copy bytes to user space.</span></span><br><span class="line">  <span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">copy_to_user</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">void</span> *src, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">do_stuff</span><span class="params">(<span class="keyword">void</span> *usr_buf)</span> </span>&#123;</span><br><span class="line">    test arg&#123;<span class="number">0.0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7.0</span>&#125;;</span><br><span class="line">    <span class="comment">// May be larger than strictly needed, will be updated by</span></span><br><span class="line">    <span class="comment">// calling serialize() to the size of the buffer remaining.</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> size = <span class="keyword">sizeof</span>(arg);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> buf[<span class="keyword">sizeof</span>(arg)];</span><br><span class="line">    <span class="keyword">if</span> (arg.serialize(buf, size)) &#123;</span><br><span class="line">      copy_to_user(usr_buf, buf, <span class="keyword">sizeof</span>(test) - size);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Handle error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码就手工上保证没有初始化的padding-bits不会泄漏到用户空间了。</p>
<h3 id="DCL56-CPP-静态对象的初始化期间避免循环初始化"><a href="#DCL56-CPP-静态对象的初始化期间避免循环初始化" class="headerlink" title="DCL56-CPP 静态对象的初始化期间避免循环初始化"></a>DCL56-CPP 静态对象的初始化期间避免循环初始化</h3><p>严重等级：低</p>
<ul>
<li>可能导致未指定行为（unspecified behavior）</li>
<li>可能导致死锁</li>
</ul>
<h4 id="代码样例对比-8"><a href="#代码样例对比-8" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fact</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="title">noexcept</span><span class="params">(<span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// Negative factorials are undefined.</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">std</span>::domain_error(<span class="string">"i must be &gt;= 0"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> cache[] = &#123;</span><br><span class="line">    fact(<span class="number">0</span>), fact(<span class="number">1</span>), fact(<span class="number">2</span>), fact(<span class="number">3</span>), fact(<span class="number">4</span>), fact(<span class="number">5</span>),</span><br><span class="line">    fact(<span class="number">6</span>), fact(<span class="number">7</span>), fact(<span class="number">8</span>), fact(<span class="number">9</span>), fact(<span class="number">10</span>), fact(<span class="number">11</span>),</span><br><span class="line">    fact(<span class="number">12</span>), fact(<span class="number">13</span>), fact(<span class="number">14</span>), fact(<span class="number">15</span>), fact(<span class="number">16</span>)</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (i &lt; (<span class="keyword">sizeof</span>(cache) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>))) &#123;</span><br><span class="line">    <span class="keyword">return</span> cache[i];</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">return</span> i &gt; <span class="number">0</span> ? i * fact(i - <span class="number">1</span>) : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上的代码本意是想用cache的思想实现一个高效的求阶乘的函数，但是静态数组cache的初始化包含了递归，这个行为是未定义的，即使这个递归是有边界的。</p>
<p>从实现上看，VS2015和GCC 6.1.0 中，这个静态数组的初始化在线程安全的方式下可能死锁。而且还不一定能算出正确结果。</p>
<p>下面给出解决方案</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fact</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="title">noexcept</span><span class="params">(<span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// Negative factorials are undefined.</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">std</span>::domain_error(<span class="string">"i must be &gt;= 0"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Use the lazy-initialized cache.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> cache[<span class="number">17</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (i &lt; (<span class="keyword">sizeof</span>(cache) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>))) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == cache[i]) &#123;</span><br><span class="line">      cache[i] = i &gt; <span class="number">0</span> ? i * fact(i - <span class="number">1</span>) : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cache[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i &gt; <span class="number">0</span> ? i * fact(i - <span class="number">1</span>) : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码使用了懒初始化的方式，本质上是把静态初始化变成赋值了。完全可以计算出正确结果。</p>
<h4 id="代码样例对比-9"><a href="#代码样例对比-9" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> FILE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_H</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> numWheels;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Car() : numWheels(<span class="number">4</span>) &#123;&#125;</span><br><span class="line">  explicit Car(int numWheels) : numWheels(numWheels) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">get_num_wheels</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> numWheels; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// FILE_H</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// file1.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"file.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> Car c;</span><br><span class="line"><span class="keyword">int</span> numWheels = c.get_num_wheels();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; numWheels &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 不一定输出6</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// file2.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"file.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">Car <span class="title">get_default_car</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Car(<span class="number">6</span>); &#125;</span><br><span class="line">Car c = get_default_car();</span><br></pre></td></tr></table></figure>
<p>file1.cpp中numWheels的值依赖于c的初始化，然而，c被定义在了不同的翻译单元中（file2.cpp），所以对于c，没有任何保证c通过get_default_car()初始化是在numWheels = c.get_num_wheels()之前，专业上这叫“静态初始化顺序失效”，导致的结果也是未指定的。</p>
<p>从实现细节上说，打印到标准输出流上的值依赖于翻译单元的链接顺序，比如，在Clang 3.8.0（x86 Linux）下，clang++<br>file1.cpp file2.cpp &amp;&amp; ./a.out  这组命令会输出0， clang++ file2.cpp<br>file1.cpp &amp;&amp; ./a.out 才会输出所期望的结果6。</p>
<p>下面给出解决办法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> FILE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_H</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> numWheels;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Car() : numWheels(<span class="number">4</span>) &#123;&#125;</span><br><span class="line">  explicit Car(int numWheels) : numWheels(numWheels) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">get_num_wheels</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> numWheels; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// FILE_H</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// file1.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"file.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp;<span class="title">get_num_wheels</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">extern</span> Car c;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> numWheels = c.get_num_wheels();</span><br><span class="line">  <span class="keyword">return</span> numWheels;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; get_num_wheels() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//一定是6</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// file2.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"file.h"</span></span></span><br><span class="line"><span class="function">Car <span class="title">get_default_car</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Car(<span class="number">6</span>); &#125;</span><br><span class="line">Car c = get_default_car();</span><br></pre></td></tr></table></figure>
<p>以上代码是用“construct on first use”的idiom来解决静态初始化顺序的问题的，file.h和file2.cpp的代码都没有变，只有静态的numWheels被移到了函数体内，结果就是numWheels的初始化会发生在它声明的时候，全局对象c在main函数执行之前就初始化完毕，所以最终结果一定是6。</p>
<h3 id="DCL57-CPP-不要让异常逃离析构函数和dealloc函数的范围"><a href="#DCL57-CPP-不要让异常逃离析构函数和dealloc函数的范围" class="headerlink" title="DCL57-CPP 不要让异常逃离析构函数和dealloc函数的范围"></a>DCL57-CPP 不要让异常逃离析构函数和dealloc函数的范围</h3><p>严重等级：低</p>
<p>通过抛出异常的方式终止析构函数,operator delete 和 operator delete []会触发未定义行为。</p>
<p>在C++标准中， [basic.stc.dynamic.deallocation], paragraph 3 [ISO/IEC 14882-<br>2014]有如下声明：</p>
<blockquote>
<p>If a deallocation function terminates by throwing an exception, the behavior is undefined.</p>
</blockquote>
<p>所以在这些情况下，函数就必须声明为noexcept的，因为从一个函数抛出异常本来就不会有well-defined的行为，C++ 标准[except.spec]有如下声明：</p>
<blockquote>
<p>A deallocation function with no explicit exception-specification is treated as if it were specified with noexcept(true).</p>
</blockquote>
<p>C++标准中，[class.dtor]部份有以下声明：</p>
<blockquote>
<p>A declaration of a destructor that does not have an exception-specification is implicitly considered to have the same exception-specification as an implicit declaration.</p>
</blockquote>
<h4 id="代码样例对比-10"><a href="#代码样例对比-10" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">has_error</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ~S() <span class="keyword">noexcept</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// Normal processing</span></span><br><span class="line">    <span class="keyword">if</span> (has_error()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">std</span>::logic_error(<span class="string">"Something bad"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上代码会触发未定义行为，因为类析构函数没有满足隐式保证noexcept，所以还是可能抛出异常。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">has_error</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ~S() <span class="keyword">noexcept</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// Normal processing</span></span><br><span class="line">    <span class="keyword">if</span> (has_error() &amp;&amp; !<span class="built_in">std</span>::uncaught_exception()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">std</span>::logic_error(<span class="string">"Something bad"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上代码在析构函数中使用了std::uncaught_exception()，通过避免异常扩展的方式解决了终止问题。但是还是会导致一些重要资源的泄露。</p>
<p>再举个例子，比如以下代码存在于第三方库中，用户不能修改：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Assume that this class is provided by a 3rd party and it is not</span></span><br><span class="line"><span class="comment">//something</span></span><br><span class="line"><span class="comment">// that can be modified by the user.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bad</span> &#123;</span></span><br><span class="line">  ~Bad() <span class="keyword">noexcept</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为了安全的使用Bad类，SomeClass的析构函数意图catch Bad类可能抛出的异常来阻止扩散。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> &#123;</span></span><br><span class="line">  Bad bad_member;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ~SomeClass()</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(...) &#123;</span><br><span class="line">        <span class="comment">// Handle the exception thrown from the Bad destructor.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但是在C++ 标准中[except.handle]声明如下：</p>
<blockquote>
<p>The currently handled exception is rethrown if control reaches the end of a handler of the function-try-block of a constructor or destructor.</p>
</blockquote>
<p>根据标准的说法，也就是在构造函数或析构函数中当控制流抵达catch块尾部的时候，异常还是会被重新抛出。结果还是不可避免的会被抛出异常。</p>
<p>下面给出一个解决方案：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> &#123;</span></span><br><span class="line">  Bad bad_member;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ~SomeClass()</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(...) &#123;</span><br><span class="line">        <span class="comment">// Catch exceptions thrown from noncompliant destructors of</span></span><br><span class="line">        <span class="comment">// member objects or base class subobjects.</span></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> Flowing off the end of a destructor function-try-block</span></span><br><span class="line">        <span class="comment">// causes the caught exception to be implicitly rethrown, but</span></span><br><span class="line">        <span class="comment">// an explicit return statement will prevent that from</span></span><br><span class="line">        <span class="comment">// happening.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的代码使用显式的return语句阻止了控制流到达了catch块的尾部，这样做必然可以捕捉bad_member销毁时候所抛出的异常了，而且这么用法可以捕捉其他任何异常，异常也不会重新在SomeClass的析构函数中被重新抛出导致被终止的问题了。</p>
<h4 id="代码样例对比-11"><a href="#代码样例对比-11" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">perform_dealloc</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *ptr)</span> <span class="title">noexcept</span><span class="params">(<span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (perform_dealloc(ptr)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">std</span>::logic_error(<span class="string">"Something bad"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过了之前的分析，可以很简单的看出上面的代码，全局dealloc函数必然会导致未定义行为。需要改成下面这样。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">perform_dealloc</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">log_failure</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *ptr)</span> <span class="title">noexcept</span><span class="params">(<span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (perform_dealloc(ptr)) &#123;</span><br><span class="line">    log_failure(<span class="string">"Deallocation of pointer failed"</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">exit</span>(<span class="number">1</span>); <span class="comment">// Fail, but still call destructors</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码通过不抛出异常，直接结束程序，而且也会正确调用析构函数。</p>
<h3 id="DCL58-CPP-不要修改标准名字空间"><a href="#DCL58-CPP-不要修改标准名字空间" class="headerlink" title="DCL58-CPP. 不要修改标准名字空间"></a>DCL58-CPP. 不要修改标准名字空间</h3><p>严重等级：高</p>
<p>C++ 标准[namespace.std]规定了：</p>
<blockquote>
<p>The behavior of a C++ program is undefined if it adds declarations or definitions to namespace std or to a namespace within namespace std unless otherwise specified. A program may add a template specialization for any standard library template to namespace std only if the declaration depends on a user-defined type and the specialization meets the standard library requirements for the original template and is not explicitly prohibited.</p>
</blockquote>
<blockquote>
<p>The behavior of a C++ program is undefined if it declares an explicit specialization of any member function of a standard library class template, or an explicit specialization of any member function template of a standard library class or class template, or an explicit or partial specialization of any member class template of a standard library class or class template.</p>
</blockquote>
<p>除了要限制对std名字空间的扩展，C++标准[namespace.posix]还规定限制对posix名字空间的扩展:</p>
<blockquote>
<p>The behavior of a C++ program is undefined if it adds declarations or definitions to namespace posix or to a namespace within namespace posix unless otherwise specified. The namespace posix is reserved for use by ISO/IEC 9945 and other POSIX standards.</p>
</blockquote>
<h3 id="DCL59-CPP-不要在头文件中定义一个未命名的名字空间"><a href="#DCL59-CPP-不要在头文件中定义一个未命名的名字空间" class="headerlink" title="DCL59-CPP 不要在头文件中定义一个未命名的名字空间"></a>DCL59-CPP 不要在头文件中定义一个未命名的名字空间</h3><p>严重等级：中</p>
<p>C++标准[namespace.unnamed]对此作出描述:</p>
<blockquote>
<p>An unnamed-namespace-definition behaves as if it were replaced by:</p>
</blockquote>
<blockquote>
<p>inline namespace unique { /<em> empty body </em>/ }</p>
</blockquote>
<blockquote>
<p>using namespace unique ;</p>
</blockquote>
<blockquote>
<p>namespace unique { namespace-body }</p>
</blockquote>
<blockquote>
<p>where inline appears if and only if it appears in the unnamed-namespace-definition, all occurrences of unique in a translation unit are replaced by the same identifier, and this identifier differs from all other identifiers in the entire program.</p>
</blockquote>
<p>因为定义在头文件中的未命名名字空间，可能通过#include 插入到任何.cpp文件中（任何翻译单元），会导致对未命名的名字空间在不同的翻译单元有自己的实例名字，所以可能导致奇怪的结果。</p>
<h3 id="DCL60-CPP-遵循只有一个定义的原则"><a href="#DCL60-CPP-遵循只有一个定义的原则" class="headerlink" title="DCL60-CPP 遵循只有一个定义的原则"></a>DCL60-CPP 遵循只有一个定义的原则</h3><p>严重等级：高</p>
<p>正经的C++项目一般都会把程序分割成多个翻译单元，然后通过链接器把多个翻译单元链接在一起成为一个可执行文件。为了支持这一种模型，C++限制已命名的对象定义，通过在跨所有翻译单元中只有一个定义来保证。这种模型叫one-definition rule(ODR)。 而且也在C++标准 [basic.def.odr] 中描述了：</p>
<blockquote>
<p>Every program shall contain exactly one definition of every non-inline function or variable that is odr-used in that program; no diagnostic required. The definition can appear explicitly in the program, it can be found in the standard or a user-defined library, or (when appropriate) it is implicitly defined. An inline function shall be defined in every translation unit in which it is odr-used.</p>
</blockquote>
<p>当然，多个翻译单元通常会包含多种声明，因为大部分是通过#include头文件被插入到翻译单元中的。在头文件中的这些声明也有可能也含有定义了。比如类和函数模板的定义。这些也在C++标准中描述了：</p>
<blockquote>
<p>There can be more than one definition of a class type, enumeration type, inline function with external linkage, class template, non-static function template, static data member of a class template, member function of a class template, or template specialization for which some template parameters are not specified in a program provided that each definition appears in a different translation unit, and provided the definitions satisfy the following requirements. Given such an entity named D defined in more than one translation unit…. If the definitions of D satisfy all these requirements, then the program shall behave as if there were a single definition of D. If the definitions of D do not satisfy these requirements, then the behavior is undefined.</p>
</blockquote>
<h4 id="代码样例对比-12"><a href="#代码样例对比-12" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.cpp</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.cpp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上代码在两个不同的翻译单元中定义了一个相同的类，struct本质上也是类。而且这两个类都有一个非静态数据成员a。所以以上代码违反了ODR，并且会导致未定义行为。</p>
<p>下面给出解决方案：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// S.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"S.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// b.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"S.h"</span></span></span><br></pre></td></tr></table></figure>
<p>以上代码就不会存在问题了，其实解决这种类似的问题依赖于编程者的意图，如果编程者需要在同样的类定义在不同的翻译单元中可见，那么就可以定义在头文件中，并且通过include插入。就像以上代码的做法。</p>
<p>如果由于ODR原则导致了符号名字的冲突，那么可以通过名字空间来保证类是唯一的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.cpp</span></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.cpp</span></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码样例对比（Visual-Studio）"><a href="#代码样例对比（Visual-Studio）" class="headerlink" title="代码样例对比（Visual Studio）"></a>代码样例对比（Visual Studio）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// s.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> c;</span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_s</span><span class="params">(S &amp;s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// s.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"s.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_s</span><span class="params">(S &amp;s)</span></span>; &#123;</span><br><span class="line">  s.c = <span class="string">'a'</span>;</span><br><span class="line">  s.a = <span class="number">12</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(push, 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"s.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(pop)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  S s;</span><br><span class="line">  init_s(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上的代码通过#include把一个类定义插入到了不同的翻译单元中，然而，其中一个翻译单元（a.cpp）通过implementation-defined的#pragma指令来实现了结构体成员对齐，所以导致了两个翻译单元（s.cpp a.cpp）S的定义具有了不同的二进制布局，这就违反了ODR原则，导致了未定义行为。</p>
<p>要解决这个问题比较简单，把#pragma指令移除就可以了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> c;</span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_s</span><span class="params">(S &amp;s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// s.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"s.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_s</span><span class="params">(S &amp;s)</span></span>; &#123;</span><br><span class="line">  s.c = <span class="string">'a'</span>;</span><br><span class="line">  s.a = <span class="number">12</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"s.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  S s;</span><br><span class="line">  init_s(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码样例对比-13"><a href="#代码样例对比-13" class="headerlink" title="代码样例对比"></a>代码样例对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;lhs, <span class="keyword">const</span> <span class="keyword">int</span> &amp;rhs)</span></span>;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> g(k, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码也违反了ODR，但是一下子难以看出来，下面来逐个分析：</p>
<p>常量对象n有个内部链接，但是被函数f()依赖了，函数f()具有外部链接。因为函数f()被声明为了一个inline，所以f函数的定义在所有翻译单元中都是唯一的（在所有翻译单元中f的二进制布局都一样）。然而，对象n在每个翻译单元中都会具有一个唯一的实例（在所有翻译单元中n的实例不一样），所以由于n的不同导致了函数f违反了ODR。</p>
<p>下面的代码解决了该问题:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">42</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> lhs, <span class="keyword">int</span> rhs)</span></span>; <span class="comment">// 把常引用消除</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> g(k, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者像下面这样修改，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Constants &#123;</span><br><span class="line">  N = <span class="number">42</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;lhs, <span class="keyword">const</span> <span class="keyword">int</span> &amp;rhs)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> g(k, N);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把常量N改为命名的enum类型，所以N在不同的翻译单元中布局都一样了，这样就不会影响函数f，它们具有同样的链接。不违反ODR。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://alexiachen.github.io/blog/2017/06/02/cert-cpp-zero/" data-id="cjtctmcih009mqfqfzkr1qgqc" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/C-C/">C/C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/CERT/">CERT</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-true-researcher" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2017/05/19/true-researcher/" class="article-date">
  <time datetime="2017-05-19T08:51:06.000Z" itemprop="datePublished">2017-05-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2017/05/19/true-researcher/">什么才是真正的研究者</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> 无意中在Github上访问了一个学长的个人博客网站，我知道这个人的，当年室友给我推荐过这么一个有潜力的学长，喜欢研究Linux kernel。当然，上了他的博客之后才知道他业余喜欢研究点计算理论，认知论还有点哲学。看了他几篇文章，感觉他什么都懂一点但什么都不精，喜欢东拉西扯，其实很多基本理论和基本概念都含糊不清，把计算理论的东西非要跟认知论粘在一起，分析个算法还要把符号系统给扯上关系，任何严谨的理论研究工作者是绝对不会把自己专业的东西强行与另一些理论bind在一起的。另外，我从来没有在他的博客上见到他业余研究的理论的形式化推导与分析，写的非常玄，我相信把计算理论的专家请来看他的博客专家都看不懂他在说啥。</p>
<p> 我建议他抛弃这些似是而非的理论，别想得太多，先深入研究一个方向，好好动手做一做，在简单的问题上分析出一个结果都算不错啊，这样以来思路就会清晰很多。这个过程往往很痛苦，但是一定得经历，这个是从民科到科班的必要步骤。这才是一个真正的研究者该做的事情。不然很容易变民科。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://alexiachen.github.io/blog/2017/05/19/true-researcher/" data-id="cjtctmcfn0028qfqfqo2rr0t6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/学术/">学术</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/研究/">研究</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/blog/page/3/">&laquo; Prev</a><a class="page-number" href="/blog/">1</a><a class="page-number" href="/blog/page/2/">2</a><a class="page-number" href="/blog/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/blog/page/5/">5</a><a class="page-number" href="/blog/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/8/">8</a><a class="extend next" rel="next" href="/blog/page/5/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/blog/tags/Bloom-Filter/" style="font-size: 10px;">Bloom Filter</a> <a href="/blog/tags/C-C/" style="font-size: 20px;">C/C++</a> <a href="/blog/tags/CERT/" style="font-size: 18.33px;">CERT</a> <a href="/blog/tags/CMake/" style="font-size: 10px;">CMake</a> <a href="/blog/tags/DLL/" style="font-size: 10px;">DLL</a> <a href="/blog/tags/DNS/" style="font-size: 10px;">DNS</a> <a href="/blog/tags/IM/" style="font-size: 13.33px;">IM</a> <a href="/blog/tags/IO/" style="font-size: 10px;">IO</a> <a href="/blog/tags/Java/" style="font-size: 10px;">Java</a> <a href="/blog/tags/Linux/" style="font-size: 13.33px;">Linux</a> <a href="/blog/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/blog/tags/Oracle/" style="font-size: 10px;">Oracle</a> <a href="/blog/tags/Qos/" style="font-size: 11.67px;">Qos</a> <a href="/blog/tags/RFB协议/" style="font-size: 10px;">RFB协议</a> <a href="/blog/tags/SQLite/" style="font-size: 10px;">SQLite</a> <a href="/blog/tags/Scala/" style="font-size: 10px;">Scala</a> <a href="/blog/tags/TCP-IP/" style="font-size: 10px;">TCP/IP</a> <a href="/blog/tags/VNC协议/" style="font-size: 10px;">VNC协议</a> <a href="/blog/tags/Visual-Studio/" style="font-size: 10px;">Visual Studio</a> <a href="/blog/tags/Win32/" style="font-size: 13.33px;">Win32</a> <a href="/blog/tags/Y组合子/" style="font-size: 10px;">Y组合子</a> <a href="/blog/tags/bat/" style="font-size: 10px;">bat</a> <a href="/blog/tags/ioccc/" style="font-size: 10px;">ioccc</a> <a href="/blog/tags/lambda演算/" style="font-size: 10px;">lambda演算</a> <a href="/blog/tags/windows/" style="font-size: 11.67px;">windows</a> <a href="/blog/tags/上下文无关文法/" style="font-size: 10px;">上下文无关文法</a> <a href="/blog/tags/事业/" style="font-size: 10px;">事业</a> <a href="/blog/tags/互联网/" style="font-size: 10px;">互联网</a> <a href="/blog/tags/人生/" style="font-size: 10px;">人生</a> <a href="/blog/tags/传统行业/" style="font-size: 10px;">传统行业</a> <a href="/blog/tags/信息安全/" style="font-size: 10px;">信息安全</a> <a href="/blog/tags/内存模型/" style="font-size: 10px;">内存模型</a> <a href="/blog/tags/函数式编程/" style="font-size: 11.67px;">函数式编程</a> <a href="/blog/tags/单例模式/" style="font-size: 10px;">单例模式</a> <a href="/blog/tags/双向链表/" style="font-size: 10px;">双向链表</a> <a href="/blog/tags/可计算性/" style="font-size: 10px;">可计算性</a> <a href="/blog/tags/同步异步/" style="font-size: 10px;">同步异步</a> <a href="/blog/tags/团队管理/" style="font-size: 11.67px;">团队管理</a> <a href="/blog/tags/多核编程/" style="font-size: 10px;">多核编程</a> <a href="/blog/tags/多线程编程/" style="font-size: 10px;">多线程编程</a> <a href="/blog/tags/天体物理/" style="font-size: 10px;">天体物理</a> <a href="/blog/tags/套路/" style="font-size: 10px;">套路</a> <a href="/blog/tags/学术/" style="font-size: 10px;">学术</a> <a href="/blog/tags/宇宙学/" style="font-size: 10px;">宇宙学</a> <a href="/blog/tags/性能优化/" style="font-size: 10px;">性能优化</a> <a href="/blog/tags/技术/" style="font-size: 10px;">技术</a> <a href="/blog/tags/指令重排序/" style="font-size: 10px;">指令重排序</a> <a href="/blog/tags/操作系统/" style="font-size: 10px;">操作系统</a> <a href="/blog/tags/敏捷开发/" style="font-size: 10px;">敏捷开发</a> <a href="/blog/tags/数据压缩/" style="font-size: 10px;">数据压缩</a> <a href="/blog/tags/数据库/" style="font-size: 10px;">数据库</a> <a href="/blog/tags/数据恢复/" style="font-size: 10px;">数据恢复</a> <a href="/blog/tags/数据结构与算法/" style="font-size: 11.67px;">数据结构与算法</a> <a href="/blog/tags/旅行/" style="font-size: 10px;">旅行</a> <a href="/blog/tags/无线网卡/" style="font-size: 10px;">无线网卡</a> <a href="/blog/tags/有限自动机/" style="font-size: 10px;">有限自动机</a> <a href="/blog/tags/构建工具/" style="font-size: 10px;">构建工具</a> <a href="/blog/tags/模板元编程/" style="font-size: 10px;">模板元编程</a> <a href="/blog/tags/民主/" style="font-size: 11.67px;">民主</a> <a href="/blog/tags/汇编语言/" style="font-size: 10px;">汇编语言</a> <a href="/blog/tags/消息推送/" style="font-size: 10px;">消息推送</a> <a href="/blog/tags/混乱代码/" style="font-size: 10px;">混乱代码</a> <a href="/blog/tags/物联网/" style="font-size: 10px;">物联网</a> <a href="/blog/tags/猎人/" style="font-size: 10px;">猎人</a> <a href="/blog/tags/理想/" style="font-size: 10px;">理想</a> <a href="/blog/tags/理论计算机/" style="font-size: 10px;">理论计算机</a> <a href="/blog/tags/生活/" style="font-size: 13.33px;">生活</a> <a href="/blog/tags/研究/" style="font-size: 10px;">研究</a> <a href="/blog/tags/程序语言理论/" style="font-size: 15px;">程序语言理论</a> <a href="/blog/tags/类型系统/" style="font-size: 10px;">类型系统</a> <a href="/blog/tags/线程/" style="font-size: 10px;">线程</a> <a href="/blog/tags/线程安全/" style="font-size: 10px;">线程安全</a> <a href="/blog/tags/缓存/" style="font-size: 10px;">缓存</a> <a href="/blog/tags/编程范式/" style="font-size: 10px;">编程范式</a> <a href="/blog/tags/编程语言/" style="font-size: 10px;">编程语言</a> <a href="/blog/tags/编译原理/" style="font-size: 11.67px;">编译原理</a> <a href="/blog/tags/美国/" style="font-size: 10px;">美国</a> <a href="/blog/tags/职业生涯/" style="font-size: 10px;">职业生涯</a> <a href="/blog/tags/自然语言处理/" style="font-size: 10px;">自然语言处理</a> <a href="/blog/tags/自由/" style="font-size: 11.67px;">自由</a> <a href="/blog/tags/英语/" style="font-size: 10px;">英语</a> <a href="/blog/tags/装修/" style="font-size: 10px;">装修</a> <a href="/blog/tags/计算机体系结构/" style="font-size: 10px;">计算机体系结构</a> <a href="/blog/tags/计算机科学/" style="font-size: 10px;">计算机科学</a> <a href="/blog/tags/计算机网络/" style="font-size: 11.67px;">计算机网络</a> <a href="/blog/tags/计算理论/" style="font-size: 11.67px;">计算理论</a> <a href="/blog/tags/词法分析/" style="font-size: 10px;">词法分析</a> <a href="/blog/tags/诗歌/" style="font-size: 10px;">诗歌</a> <a href="/blog/tags/语义学/" style="font-size: 10px;">语义学</a> <a href="/blog/tags/调试/" style="font-size: 11.67px;">调试</a> <a href="/blog/tags/软件工程/" style="font-size: 16.67px;">软件工程</a> <a href="/blog/tags/软件开发/" style="font-size: 10px;">软件开发</a> <a href="/blog/tags/软件调试/" style="font-size: 10px;">软件调试</a> <a href="/blog/tags/远程桌面/" style="font-size: 10px;">远程桌面</a> <a href="/blog/tags/逻辑/" style="font-size: 11.67px;">逻辑</a> <a href="/blog/tags/重构/" style="font-size: 10px;">重构</a> <a href="/blog/tags/错误处理/" style="font-size: 10px;">错误处理</a> <a href="/blog/tags/闭包/" style="font-size: 10px;">闭包</a> <a href="/blog/tags/阻塞非阻塞/" style="font-size: 10px;">阻塞非阻塞</a> <a href="/blog/tags/项目管理/" style="font-size: 11.67px;">项目管理</a> <a href="/blog/tags/马尔科夫链/" style="font-size: 10px;">马尔科夫链</a> <a href="/blog/tags/驱动开发/" style="font-size: 10px;">驱动开发</a> <a href="/blog/tags/黑洞/" style="font-size: 10px;">黑洞</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/02/">February 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/01/">January 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2015/11/">November 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2014/11/">November 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2014/09/">September 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2014/08/">August 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2014/07/">July 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2014/06/">June 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2014/05/">May 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2014/03/">March 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2014/02/">February 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2013/07/">July 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2013/06/">June 2013</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2019/03/17/bloom-filter/">实现一个简单的高性能布隆过滤器</a>
          </li>
        
          <li>
            <a href="/blog/2019/03/10/auto-complete-markov-chain/">用马尔科夫链来做自动补全</a>
          </li>
        
          <li>
            <a href="/blog/2018/12/15/manjaro-rtl8821ce/">manjaro下安装配置无线网卡驱动</a>
          </li>
        
          <li>
            <a href="/blog/2018/11/11/cpp-closure/">C++的闭包</a>
          </li>
        
          <li>
            <a href="/blog/2018/10/15/finite-automaton/">最简单的计算机之有限自动机</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2013-2019 MathxH Chen<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/blog/" class="mobile-nav-link">Home</a>
  
    <a href="/blog/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/blog/about" class="mobile-nav-link">About</a>
  
    <a href="/blog/resume" class="mobile-nav-link">Resume</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">
  <script src="/blog/fancybox/jquery.fancybox.pack.js"></script>


<script src="/blog/js/script.js"></script>



  </div>
</body>
</html>