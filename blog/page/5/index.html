<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>MathxH</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="System Software Engineer">
<meta property="og:type" content="website">
<meta property="og:title" content="MathxH">
<meta property="og:url" content="https://alexiachen.github.io/blog/page/5/index.html">
<meta property="og:site_name" content="MathxH">
<meta property="og:description" content="System Software Engineer">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MathxH">
<meta name="twitter:description" content="System Software Engineer">
  
    <link rel="alternate" href="/blog/atom.xml" title="MathxH" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/blog/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog/" id="logo">MathxH</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/blog/" id="subtitle">MathxH</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blog/">Home</a>
        
          <a class="main-nav-link" href="/blog/archives">Archives</a>
        
          <a class="main-nav-link" href="/blog/about">About</a>
        
          <a class="main-nav-link" href="/blog/resume">Resume</a>
        
      </nav>
      <nav id="sub-nav">
        <a></a>
        
          <a id="nav-rss-link" class="nav-icon" href="/blog/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://alexiachen.github.io/blog"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-language-grammar" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2017/03/28/language-grammar/" class="article-date">
  <time datetime="2017-03-28T02:48:27.000Z" itemprop="datePublished">2017-03-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2017/03/28/language-grammar/">出来混迟早是要还的之程序设计语言的文法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p><em>唉，好像又回到大学被《编译原理》狂虐的时代了。因为最近在设计自己的脚本语言解释器，由于词法分析阶段用正则文法(3型文法)就能搞定，但是语法分析阶段不学习上下文无关文法(2型文法)是不行的了，所以出来混迟早是要还的</em></p>
</blockquote>
<h2 id="关于程序设计语言一点有趣的背景"><a href="#关于程序设计语言一点有趣的背景" class="headerlink" title="关于程序设计语言一点有趣的背景"></a>关于程序设计语言一点有趣的背景</h2><hr>
<p>我在之前的文章《什么是类型安全》提到过著名语言学家乔姆斯基的一个例子，是为了说明语法和语义的区别。其实乔姆斯基作为世界顶级的语言学专家为语言学的研究发展做出了很大的贡献，不要以为人类的语言与程序设计语言没有半点关系（确实，它们之间的关系并不大），乔姆斯基的贡献之一，就是在<a href="https://en.wikipedia.org/wiki/Formal_language" target="_blank" rel="noopener">形式语言(formal language)</a>领域提出了著名的<a href="https://en.wikipedia.org/wiki/Chomsky_hierarchy" target="_blank" rel="noopener">乔姆斯基层级谱系(Chomsky hierarchy)</a>，它把所有的形式语言的形式文法分成了四大类，分别是0型文法，1型文法，2型文法，3型文法。从包含关系上来说，0型文法 &gt; 1型文法 &gt; 2型文法 &gt; 3型文法。 符号’&gt;’表示，X范围大于X， 0型文法是1，2，3型文法的超集(superset)。</p>
<p>那么计算机编程语言到底与上面的形式文法有什么关系呢？因为计算机编程语言的定义就需要用到上面的形式化文法来描述。</p>
<p>其实很多计算机相关的语言背后都有一定的基础。比如：</p>
<ul>
<li><p>LISP，背后是λ演算，这个数学基础给了LISP非常强大的表达能力；（虽然多数人不直接用LISP）至少，LISP给现在各种支持函数式编程的语言提供了借鉴。</p>
</li>
<li><p>正则表达式。背后是正则文法（也就是3型文法）。凡是可以使用正则文法定义的语言，都可以使用正则表达式定义描述。当然，经常有人试图用它来匹配各种编程语言的代码，这基本上是肯定要出bug的。原因很简单，多数主流编程语言都是『上下文无关语言』，它是正则语言的超集（参考乔姆斯基层级），记住，正则语言一定是上下文无关的，但是上下文无关的语言不一定能用正则语言来描述定义。</p>
</li>
<li><p><a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form" target="_blank" rel="noopener">BNF范式</a>。背后是上下文无关文法（也就是2型文法）。这也是为什么各种编程语言（即使复杂如C++或C#，还包括SQL和正则表达式）的规范文档，甚至不少『标准格式』（如JSON，URI等）的规范文档都喜欢用BNF或EBNF定义。更好玩的是，当你用BNF定义好一门语言时，还可以使用一种称为Parser Generator的程序（如YACC及各语言上的移植，Flex，Bison，ANTLR等，它们有时候也被称作编译器的编译器）来生成这门语言的解析程序(Parser)！当然了，一般工业制作的编程语言的编译器前端部分大部分会这么干，定义好语言描述，用工具直接就生成该语言的抽象语法树了(abstract snytax tree), 不需要自己写词法分析和语法分析了，避免不必要的苦力劳动。为什么能做到这么厉害的功能？这涉及到计算理论的很多知识，但归根到底，就是上下文无关文法。</p>
</li>
</ul>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><hr>
<ul>
<li><a href="https://www.zhihu.com/question/52049459" target="_blank" rel="noopener">有哪些匹配文本的需求是正则表达式做不了的?</a></li>
<li><a href="http://www.cs.wcupa.edu/rkline/fcs/cfls.html" target="_blank" rel="noopener">Context-free language</a></li>
<li><a href="https://www.zhihu.com/question/21833944" target="_blank" rel="noopener">应该如何理解“上下文无关文法”？</a> </li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://alexiachen.github.io/blog/2017/03/28/language-grammar/" data-id="cjtctj22g0014lbqfr8kygrm2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/上下文无关文法/">上下文无关文法</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/程序语言理论/">程序语言理论</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/编译原理/">编译原理</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-script-lexer" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2017/03/27/script-lexer/" class="article-date">
  <time datetime="2017-03-27T06:48:40.000Z" itemprop="datePublished">2017-03-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2017/03/27/script-lexer/">词法分析器完成</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>经过昨天一天的努力，我制作的Stone语言的Tokenizer已经完成了，之前不支持解析带有空格的String Literal，也不支持带有空格的注释(comments)。现在可以完美支持了，当然与其他语言工业级别的tokenizer，这个当然没法比，这仅仅是个玩具，为了方便之后的语法分析，Stone语言的本身设计也很简单，一些代码格式结构会强制要求，不然会解析错误。</p>
<p>这个tokenzier设计原理很简单，它根据文件按照行扫描的方式，逐行读取和解析，然后根据解析出来的token作分类，大致有String类，Identifier类，还有Number类，没有做更详细的细分，因为之后这个Stone语言的解释器会逐步完善添加功能，所以我把每个token都与它所在的行号做了关联，以后会有用处，类似于下面:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Token&gt; EOF_TOEKN; <span class="comment">// end of file</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> EOL_TOKEN; <span class="comment">// end of line</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> int32_t <span class="title">getLineNumber</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_line_number; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">isIdentifier</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">isNumber</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">isString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> int32_t <span class="title">getNumber</span><span class="params">()</span> </span>&#123; <span class="keyword">throw</span> StoneException(<span class="string">"not number token"</span>); &#125;</span><br><span class="line">    <span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getText</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">""</span>); &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    explicit Token(int32_t line):m_line_number(line)&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int32_t</span> m_line_number;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面是Token的抽象类，如果需要自己实现特定的Token类，就子类化Token就可以了。</p>
<p>该词法分析器依赖于C++ 11的正则表达式库。我的想法也是尽量使用C++ 11/14的特性来完成一些功能。就这样吧，还有很多要做，以后还要加入语言的闭包等等，挑战不小。</p>
<p>这里是该项目的<a href="https://github.com/AlexiaChen/stone-lang-in-cpp" target="_blank" rel="noopener">Github地址</a>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://alexiachen.github.io/blog/2017/03/27/script-lexer/" data-id="cjtctj22x001zlbqf3upgh6nm" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/编译原理/">编译原理</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/词法分析/">词法分析</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-about-computation" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2017/03/23/about-computation/" class="article-date">
  <time datetime="2017-03-23T04:01:23.000Z" itemprop="datePublished">2017-03-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2017/03/23/about-computation/">有关于计算机科学</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="我的大学"><a href="#我的大学" class="headerlink" title="我的大学"></a>我的大学</h2><hr>
<p>刚上大学的时候，在大教室上的第一堂课是计算机科学系的系主任给我们上的一堂“思想开导课”。是这么说的，我们专业是计算机里面最古老，历史最久远的一个专业，比之软件工程，网络工程历史久远的多，也是最博大精深的专业，因为它是计算机科学！是一门理论性质比较强的学科。</p>
<p>这由此真正打开了我对计算机世界的憧憬，刚开始我确实不懂什么是计算机科学，以为就是写写代码，懂点数据结构和算法，也不去管什么叫图灵，丘奇的人物。</p>
<p>但是后来，由于工作以后，随着业余研究的深入，我发现我真不懂计算机科学，其实呢，在学校的时候包括现在，大部分同学和教授也对什么是计算机科学也是差不多一窍不通的（因为我的学校真的很次，不是牛校，不会出现什么特别有名的牛人）。</p>
<p>不过，他们懂与不懂也与我无关了。随着后来我逐渐对函数式语言的理解，以及程序语言理论的了解，接触了计算理论的一些皮毛，才慢慢打开了计算机科学的大门。</p>
<h2 id="计算模型与计算能力"><a href="#计算模型与计算能力" class="headerlink" title="计算模型与计算能力"></a>计算模型与计算能力</h2><hr>
<p>因为我以前对C++模板元编程很不熟悉，最近的工作业余喜欢写些有趣的C++模板代码来表达实现我以前的一些思想（算法）。可能遭到了一些不理解实情的人的好奇，他们可能想，玩这样的trick有什么意思吗？ 不要注重这些或有或无的东西，工程经验才是王道！语言只是工具！最重要的还是数据结构与算法，还有项目经验。</p>
<p>我当然知道这些人的意思，其实他们的初衷是好的，不希望我沉迷语言的某些技巧不能自拔。</p>
<p>其实呢不是这样的，因为C++的模板元本身就是自成一套体系的，它对比之C++可能说是“另外一门语言”，最重要的是模板这套“符号系统”本身就是<a href="https://en.wikipedia.org/wiki/Turing_completeness" target="_blank" rel="noopener">图灵完备的</a>。也就是说，模板本身的计算能力与Java，Python等图灵完备的语言计算能力等价，它们能做的事情，模板也能做。</p>
<p>所以，当我在用模板解决问题的时候，我所思考的是如何将自身的想法在这套“计算模型”上表现。我是在尝试模板自身的计算能力到底有多强？什么问题模板可以计算？什么问题又不可计算？</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fix = lambda f.(lambda x f(lambda.x x y)) (lambda. f (lambday. x x y))</span><br><span class="line">g = lambda fct lambda n if reqleq n c0 then c1 else (<span class="name">times</span> n (<span class="name">fct</span>(<span class="name">prdn</span>)))</span><br><span class="line">factorial = fix g</span><br></pre></td></tr></table></figure>
<p>上面是通过lambda演算求不动点定义阶乘算子，这种表达能力是lambda演算的计算能力所体现的,这个东西最核心的就是：<font color="red">不动点算子。</font></p>
<p>其实举着例子，我也只是想把问题又转移到C++模板元上，还是上面那个问题，模板的计算能力有多强？同样一个计算问题在模板这种另一种计算模型上该如何表现？这并不是无趣的自我提问，因为它的本质甚至涉及到了我们今天电子数字计算机的诞生，图灵和丘奇这两位前辈的研究成果。</p>
<p>在计算机的世界，有可计算问题，有不可计算问题（例如著名的停机问题）。如果可计算那么它的计算复杂度是多少？如果不可计算，这又是为什么不可计算？ 我在试图探讨更本质的一些东西，换句话说，对一些问题，模板是否能计算？如果是，是为什么？ 如果不是，又是为什么？</p>
<p>如果对于这些问题有深入研究的程序员，就不可能大部分看不懂Knuth老爷子的<a href="">《计算机程序设计的艺术（TAOCP）》</a>了吧。</p>
<h2 id="路漫漫其修远兮"><a href="#路漫漫其修远兮" class="headerlink" title="路漫漫其修远兮"></a>路漫漫其修远兮</h2><hr>
<p>什么是计算？以及以上的自我式提问。</p>
<p>当然这些问题不是我现在就能说得清楚的，还得继续，路漫漫其修远兮。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://alexiachen.github.io/blog/2017/03/23/about-computation/" data-id="cjtctj21h0001lbqfpwpnjt76" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/可计算性/">可计算性</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/模板元编程/">模板元编程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/理论计算机/">理论计算机</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/计算机科学/">计算机科学</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/计算理论/">计算理论</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-type-safety" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2017/03/16/type-safety/" class="article-date">
  <time datetime="2017-03-16T07:30:48.000Z" itemprop="datePublished">2017-03-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2017/03/16/type-safety/">什么是类型安全?</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="什么是类型安全？"><a href="#什么是类型安全？" class="headerlink" title="什么是类型安全？"></a>什么是类型安全？</h2><hr>
<p>有时候有些人说，Java是个类型安全的语言，那么这些人到底是在说什么？所有的类型安全的语言是一样的吗？</p>
<p>事实上，一个语言类型安全的定义是取决于语言类型系统的定义。简而言之，类型安全能保证程序的行为是意义明确的（well-defined）。更广泛的来说，我将要讨论的话题就是，一个语言的类型系统是推导程序正确性，安全性的一个有利工具。类型系统也是程序语言理论一个热门的研究领域。</p>
<p>思考下，为什么动态类型的语言，比如，Python，Javascript这些语言没有良好的代码提示工具呢？也为什么没有良好的函数定义跳转工具呢？</p>
<p>其实就是由于类型系统的影响，导致没有工具能非常正确分析程序结构，导致跳转，提示不正确。简单的程序可能可以分析出来，但是一旦程序结构复杂了，就难以作出代码的正确提示。所以为了弥补Javascript的不足，才有了静态类型的<a href="http://www.typescriptlang.org/" target="_blank" rel="noopener">TypeScript</a>，这样静态类型的语言在语言编译的时候就可以借助编译器或者静态分析工具分析出大量隐含的错误(警告)，也更利于为其开发良好的代码提示，重构工具，也更利于大型项目的开发维护。好处是不言自明了。</p>
<h2 id="基本的类型安全"><a href="#基本的类型安全" class="headerlink" title="基本的类型安全"></a>基本的类型安全</h2><hr>
<p>类型安全基本可以用一句话总结：<font color="red">有良好的类型系统的语言能保证自身程序不出错。</font></p>
<p>这句话其实不是我创造的，是来自于<a href="https://en.wikipedia.org/wiki/Robin_Milner" target="_blank" rel="noopener">Robin Milner</a>他1978年的一篇论文，论文叫<a href="https://courses.engr.illinois.edu/cs421/sp2013/project/milner-polymorphism.pdf" target="_blank" rel="noopener">《A Theory of Type Polymorphism in Programming》</a>。翻译过来就是，编程中的类型多态理论。</p>
<p>好，下面我们来逐步讲解这句话是什么意思。</p>
<p><strong>1. 程序出错</strong></p>
<p>编程语言是由其语法和语义定义的，语法就是程序该怎么写。 语义就是程序的表述意义。</p>
<p>其实对于现实中的语言来讲，很多表达方法都是语法正确，但语义存在问题的。</p>
<p>就拿一个顶级语言学家<a href="https://en.wikipedia.org/wiki/Noam_Chomsky" target="_blank" rel="noopener">乔姆斯基(Chomsky)</a>经典的英文例子来说，Colorless green ideals sleep furiously。这句英文语法上是完全正确的，但是句子表述的意义本身毫无意义，无颜色的绿色是什么鬼？ </p>
<p>再来一个<a href="https://en.wikipedia.org/wiki/OCaml" target="_blank" rel="noopener">Ocaml</a>编程语言的例子，1 + “foo” , 根据Ocaml语言的语义这个句子毫无意义，数值和字符串做加法是什么鬼？ </p>
<p>还有个C语言的例子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buffer[<span class="number">5</span>];</span><br><span class="line">buffer[<span class="number">5</span>] = <span class="string">'F'</span>;</span><br></pre></td></tr></table></figure></p>
<p>以上代码语法完全正确，但是数组的下标越界了，在C语言规范中，这样的写法是<a href="https://en.wikipedia.org/wiki/Undefined_behavior" target="_blank" rel="noopener">未定义行为(undefined bahavior)</a>。这是毫无意义的，基于该语句所导致的任何后果现象作出讨论都是无意义的，程序可能崩溃，也可能看上去“运行良好”，但是实际上已经错了。无意义的程序就是错误。类型系统就是为了对这样的行为做出约束。</p>
<p><strong>2. 良好的类型系统可以保证程序不出错</strong></p>
<p>在类型安全的语言中，其类型系统能保证程序的正确运行，如果说，一个语言的类型系统能保证程序不出错,我们就可以说这个语言是良好类型的(well-typed)的。一个well-typed的语言肯定是well-defined的语言。<br>well-defined包含well-typed,well-typed包含于well-defined。</p>
<p>在类型安全的语言中，well-typed的语言是well-defined语言的子集，它们都是语法正确的语言的子集。</p>
<blockquote>
<p>all langauge &gt; well defined language &gt; well typed language </p>
</blockquote>
<h2 id="什么语言才是类型安全的？"><a href="#什么语言才是类型安全的？" class="headerlink" title="什么语言才是类型安全的？"></a>什么语言才是类型安全的？</h2><hr>
<p>我们来看看几种流行的语言是否是类型安全的。</p>
<p><strong>1. C/C++</strong></p>
<p>非类型安全，C语言的类型系统不对无意义的行为做约束，例子数组越界。而C++可以认为是C语言的超集（为了兼容垃圾C语言这个历史包袱不得不作出的妥协），也没有对数组下标越界作出约束，所以也是非类型安全的。当然还有为了兼容C，C++允许随意的强制类型转换很容易破坏类型系统。所以更加类型安全的类型转换，dynamic_cast, static_cast, const_cast等。</p>
<p><strong>2. C#/Java</strong></p>
<p>可能是类型安全的，因为很难通过观察对一个成熟的语言实现作出断言。例如，<a href="http://www.seas.upenn.edu/~sweirich/types/archive/1999-2003/msg00849.html" target="_blank" rel="noopener">早期的Java版本泛型的类型推导是不正确的</a>。当然一种叫<a href="http://dl.acm.org/citation.cfm?id=503505" target="_blank" rel="noopener">Featherweight Java</a>的方言就是类型安全的。至于为什么，可以告诉你，这是理论证明出来的。</p>
<p>有趣的是，满足类型安全的一个要点就是，C语言的语义没有对数组越界作出约束，而C#和Java对于数组越界统统会抛ArrayBoundsException的异常。</p>
<p><strong>3. Python/Ruby</strong></p>
<p>它们是否是类型安全的值得商榷。Python和Ruby往往被人称作动态类型(也被称作<a href="https://en.wikipedia.org/wiki/Duck_typing" target="_blank" rel="noopener">鸭子类型</a>)语言，它们在执行中如果发生类型错误，就会抛出异常。就像Java对于数组越界在运行时会抛出异常，Ruby也一样，在运行时如果进行一个整数和字符串类型的加法也会抛异常。这样的行为是被语言的语义所规定约束的，所以它们都有良好的定义(well-defined)。</p>
<p>事实上，正是语言的语义赋予程序以意义。所以就本身而言，这些语言都是类型安全的，这种类型安全依赖于一种<a href="https://en.wikipedia.org/wiki/Talk:Typed_and_untyped_languages" target="_blank" rel="noopener">“无类型”系统(null type system)</a>,因为它能接收任何程序并且不让程序出错稳定运行。因此，是类型安全的。</p>
<p>这个结论看样子有点奇怪。在Java中，如果一个程序, object.method()被视为well-typed。那么类型安全会保证object是一个真正合法的对象，所以对method方法的调用总会成功。如果换做Ruby的话，那么object.method()依赖于Ruby的null type system保证是well-typed，虽然当我们运行Ruby的这段程序（没有任何保证object对象确实定义了一个叫method的方法），这段程序要么成功，要么会抛出异常，它确实会正常运行下去。如果是Java直接在编译时就报错了。</p>
<p>所以简短来说，类型安全不是万能的，类型安全所作出的保证是依赖于语言的语义的，语义隐式定义了语言的错误的行为(wrong behavior)。在Java中，这样调用一个不存在的方法就是错误的行为，在Ruby中，就不是错误的，它仅仅是抛出一个异常。</p>
<h2 id="深入点的探讨"><a href="#深入点的探讨" class="headerlink" title="深入点的探讨"></a>深入点的探讨</h2><hr>
<p>一般来说，类型安全确确实实是有用的，如果没有它，我们就无法保证程序按照我们的意图，并像它们所定义的那样运行下去，这样程序就能做一些非法的事了。</p>
<p>C/C++对未定义行为作出了一定程度的忍让，所以这也让C/C++编写的程序是导致很多漏洞，软件攻击的根源,比如<a href="https://en.wikipedia.org/wiki/Stack_buffer_overflow" target="_blank" rel="noopener">stack smashing</a>,利用栈溢出进行攻击， 再比如<a href="https://www.owasp.org/index.php/Format_string_attack" target="_blank" rel="noopener">格式化字符串攻击</a>。这种类型的漏洞和攻击是不可能发生在类型安全的语言编写的软件中的。</p>
<p>上面只是简单对Java和Ruby作出了一定的阐述。下面来对类型系统做一些更深入的探索。不是所有语言的类型系统都一样，有些类型系统能保证的指标，其他类型系统却不能保证。所以，我们在探索一门语言的时候，不要只确认它是否是类型安全的，而是确认这个类型系统满足了哪些指标，哪些指标是你所关心的，哪些不是。  废话了这么多，下面开始吧。</p>
<h3 id="1-缩小鸿沟"><a href="#1-缩小鸿沟" class="headerlink" title="1.缩小鸿沟"></a>1.缩小鸿沟</h3><p>之前文章提到过，well-defined &gt; well-typed，well-defined的语言不一定是well-typed。所以这两者类型系统之间有什么区别呢？从well defined到well typed的过渡是什么情况？先说结论，这类过渡的语言都是well defined的，但是这类语言的类型系统不会“拒绝”，举个例子，对于大多数类型系统会“拒绝”下面一段程序：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//虽然是javascript的语言的语法，但是不要理解成js语言，这里</span></span><br><span class="line"><span class="comment">//只是为了方便表述思想</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">p</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">var</span> x;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">if</span> (p) x = <span class="number">5</span>;</span><br><span class="line"> <span class="keyword">else</span> x = <span class="string">"hello"</span>;</span><br><span class="line"> <span class="keyword">if</span> (p) <span class="keyword">return</span> x+<span class="number">5</span>;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">return</span> strlen(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数，无论p的值是true，还是false，该函数都会返回一个int类型。<br>但是如果是非well typed语言的类型系统就不会会“拒绝”这段程序，而well typed语言的类型系统会“拒绝”这段程序。因为变量x的类型“同时”是String类型和int类型，用类型推导的理论就是，bool -&gt; int ^ bool -&gt; String，这种表示的是<a href="http://stackoverflow.com/questions/5653678/union-types-and-intersection-types" target="_blank" rel="noopener">intersection type</a>,而不是union type。intersection type表示的是变量x“同时”是String和int类型，而不是“有时”是String类型，“有时”是int类型。</p>
<p>再举个类似的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">param</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> param;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = test(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> b = test(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">var</span> c = test(<span class="string">"Hello"</span>);</span><br></pre></td></tr></table></figure></p>
<p>以上的函数test类型就是intersection type的，bool -&gt; bool ^ String -&gt; String ^ int -&gt; int 。也就是函数的输出输入可以”同时”是这三种类型。如果是Union Type,那么调用test(1)就会报错，因为test函数类型还有可能是bool -&gt; bool ， String -&gt; String。 调用test(true),test(“Hello”)都会出错，原理一样的，左右不是人。<a href="http://www.yinwang.org/blog-cn/2016/04/07/cfa" target="_blank" rel="noopener">垠神的文章</a>也解释过。</p>
<p>回过头来看第一段程序，根据静态分析工具其语言的类型系统是正确但不完备的。这不完备性也让很多程序员失望。一个补救的措施就是，让其类型系统能够处理，缩小well-defined与well typed的鸿沟。</p>
<blockquote>
<p>给一个参考，<a href="http://stackoverflow.com/questions/964910/is-javascript-an-untyped-language" target="_blank" rel="noopener">JavaScript是无类型的语言吗?</a></p>
</blockquote>
<p>一个例子，Java的类型系统在1.5版本的时候引入了<a href="http://docs.oracle.com/javase/tutorial/java/generics/" target="_blank" rel="noopener">泛型的概念</a>，在1.4中，你需要类型转换来告诉java的类型系统来接受程序，1.5就不需要转化了。另一个例子是<a href="https://en.wikipedia.org/wiki/Lambda_calculus" target="_blank" rel="noopener">lambda演算</a>，函数式编程语言的基础，lambda演算其中一个加入类型的版本叫<a href="https://en.wikipedia.org/wiki/Simply_typed_lambda_calculus" target="_blank" rel="noopener">Simply Typed lambda calculus</a>，这个类型系统相对于<a href="https://courses.engr.illinois.edu/cs421/sp2013/project/milner-polymorphism.pdf" target="_blank" rel="noopener">Milner’s polymorphic type system</a>能接受更少的程序，而Milner’s type system又比支持<a href="https://wiki.haskell.org/Rank-N_types" target="_blank" rel="noopener">Rank-2 (or higher) polymorphism</a>的类型系统接受更少的程序。</p>
<p>所以设计一个完备，表现力强大，可用的类型系统是程序语言理论的热门领域。</p>
<h3 id="2-强制不变性"><a href="#2-强制不变性" class="headerlink" title="2.强制不变性"></a>2.强制不变性</h3><p>一些你所见过的经典编程语言都有类型声明，int，string等等。类型安全可以保证表达式的类型必须与类型所声明的一致。不必限于int类型，一个类型系统可以支持更加广泛丰富的类型，从而表达程序更加有趣的特性。</p>
<p>比如在研究领域一个<a href="https://en.wikipedia.org/wiki/Refinement_(computing" target="_blank" rel="noopener">细化类型(refinement types)</a>#Refinement_types)有趣的例子，就是利用逻辑公式描述一个类型一组的可能的值。类型<strong>{v: int | 0 &lt;= v}</strong>,用公式<strong>0 &lt;= v</strong>细化了int类型，它简洁高效的定义了非负整数类型。细化类型允许程序员为数据结构的类型表达数据结构不变性，类型安全正是由于这些不变性保证的。细化类型系统已经有实例了，比如，在Haskell中的<a href="https://wiki.haskell.org/Liquid_Haskell" target="_blank" rel="noopener">Liquid Haskell</a>,F#中的<a href="http://research.microsoft.com/en-us/projects/f7/" target="_blank" rel="noopener">F7</a>。</p>
<p>另一个例子,我们可以用类型系统(通过强制共享数据不变性)，来防止数据竞争(data race)。这个情况下，那么共享变量的类型本质上就是一个锁来保护它的不变性。这样叫Types for safe locking第一次是在Abadi 和Flanagan的<a href="https://users.soe.ucsc.edu/~cormac/papers/esop99.pdf" target="_blank" rel="noopener">文章</a>中第一次被提及。 这个特性有Java版本的实现,<a href="http://dl.acm.org/citation.cfm?id=1119480" target="_blank" rel="noopener">戳这里</a>。也有C语言版本的<a href="http://www.cs.umd.edu/projects/PL/locksmith/" target="_blank" rel="noopener">实现</a>。</p>
<p>当然还有很多使用有趣类型系统的例子，<a href="http://www.cs.umd.edu/~jfoster/cqual/" target="_blank" rel="noopener">限制被污染数据的使用</a>，<a href="http://www.cs.cornell.edu/jif/" target="_blank" rel="noopener">防止私有信息的泄露</a>等等。</p>
<h3 id="3-类型抽象和信息隐藏"><a href="#3-类型抽象和信息隐藏" class="headerlink" title="3.类型抽象和信息隐藏"></a>3.类型抽象和信息隐藏</h3><p>许多编程语言都允许数据抽象（也叫信息隐藏）。这些语言提供了一些抽象手段，比如提供类(classes)，模块(modules)，函数(functions)这样的概念。它们可以把内部的结构不暴露给使用者,面向接口编程，接口不变，实现变化。</p>
<p>类型系统在这样的抽象中就扮演至关重要的角色。<a href="http://dl.acm.org/citation.cfm?id=512669" target="_blank" rel="noopener">表述独立(Representation independence)</a>说明了程序的运行只应该依赖其抽象，不应该依赖其实现。之后的<a href="https://en.wikipedia.org/wiki/John_C._Reynolds" target="_blank" rel="noopener">John Reynolds</a>在类型和抽象上又做出了开创性的工作，发表于他1983年的<a href="http://www.cse.chalmers.se/edu/year/2010/course/DAT140_Types/Reynolds_typesabpara.pdf" target="_blank" rel="noopener">一篇paper</a>，用一句简单的话来概括这论文就是，类型结构是维护抽象级别的一个语法工具，也就是说，<font color="red">类型是构建可维护系统的最基础重要(fundamental)的角色。</font></p>
<p>所以！！！！</p>
<p> 为啥Haskell写出来的代码在懂的开发人员面前更好维护？ 为啥Haskell编译通过的代码基本能保证正确？？  为什么需要给动态类型语言做静态分析工具？？ 为什么静态类型的语言有更智能的代码提示和重构工具？？ 为什么基于动态类型的语言开发的没有特别大型的开源项目？？为什么要在javascript之上还要再开发一个TypeScript语言用来支持大型项目的开发？？ 难道是闲着蛋疼？？ 所有的所有，都是因为，<font color="red">程序是类型上的证明。</font></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><hr>
<ul>
<li><a href="https://www.zhihu.com/question/19918532" target="_blank" rel="noopener">弱类型、强类型、动态类型、静态类型语言的区别是什么？</a></li>
<li><a href="https://www.zhihu.com/question/22416404" target="_blank" rel="noopener">程序语言中的类型系统怎么理解，它有哪些要素？如何由它演化出一门编程语言的？</a></li>
<li><a href="https://www.zhihu.com/question/23434097" target="_blank" rel="noopener">编程语言的类型系统为何如此重要？</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://alexiachen.github.io/blog/2017/03/16/type-safety/" data-id="cjtctj24i007glbqfozty1fer" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/程序语言理论/">程序语言理论</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/类型系统/">类型系统</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-my-birthday" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2017/03/16/my-birthday/" class="article-date">
  <time datetime="2017-03-16T00:30:48.000Z" itemprop="datePublished">2017-03-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2017/03/16/my-birthday/">今天生日</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>女友给我买了SONY的游戏机——PSVita。系统是3.61的，不过上论坛查了下，只有3.60的系统被破解了。于是没办法，就花了100大洋买了《神秘海域—黄金深渊》。体验下传说中看电影的感觉 :)</p>
<p><img src="http://wx3.sinaimg.cn/large/a1ac93f3gy1fdorpqikhvj20zk0qogqc.jpg" alt=""></p>
<p><img src="http://wx1.sinaimg.cn/large/a1ac93f3gy1fdtd039trkj20zk0qotg1.jpg" alt=""></p>
<p><img src="http://wx3.sinaimg.cn/large/a1ac93f3gy1fdtcxuonyaj21kw16o1kx.jpg" alt=""></p>
<p><img src="http://wx1.sinaimg.cn/large/a1ac93f3gy1fdtcxwwa5wj21kw16oe81.jpg" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://alexiachen.github.io/blog/2017/03/16/my-birthday/" data-id="cjtctj22r001klbqfhni6v3d8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/生活/">生活</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-how-dns-works" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2017/03/09/how-dns-works/" class="article-date">
  <time datetime="2017-03-09T07:38:56.000Z" itemprop="datePublished">2017-03-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2017/03/09/how-dns-works/">DNS是怎样工作的？</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p><em>直接开始正文算了，主要是总结。</em></p>
</blockquote>
<h2 id="Episode-1—–网站是未知的"><a href="#Episode-1—–网站是未知的" class="headerlink" title="Episode 1—–网站是未知的"></a>Episode 1—–网站是未知的</h2><hr>
<p>先来陈述一个事实，计算机和其他设备在因特网上互相通信识别对方都是通过IP地址进行的。但是人们并不擅长记忆类似于10.0.0.1 192.168.1.0等这样的IP地址，所以就用了字符文字串（google.com, wikipidia.org）</p>
<p>而域名系统（Domain Name System, DNS）,就是把IP地址和字符文本串关联在一起的系统，这样就能找到IP地址了。</p>
<p>假设个场景： 小A在浏览器里输入的一串mathxh.com的网址</p>
<p>首先，浏览器和操作系统会去它们各自的缓存中检查是否有mathxh.com的地址，如果没有，那么操作系统会去请求<strong>解析器</strong>(resolver)</p>
<p>啥是resolver呀？请看下一章</p>
<h2 id="Episode-2—–漫漫长路"><a href="#Episode-2—–漫漫长路" class="headerlink" title="Episode 2—–漫漫长路"></a>Episode 2—–漫漫长路</h2><hr>
<p>当当当，因为前一章节提到，cache里面没有mathxh.com的IP，所以这个请求到resolver了，resolver通常是你上网的ISP(Internet Service Provider)提供,也就是因特网服务提供商，你家办的是电信的宽带吗？ 这时候电信公司就是你的ISP。所有的Resolver必须知道一件事：<font color="red">根服务器在哪。</font></p>
<p>根服务器又知道.com TLD 服务器(Top-Level Domain，顶级域名)在哪里。</p>
<p>等等，Resolver到底是啥？还是没有说清楚，其实Resolver就是我们通常所说的DNS服务器，你需要知道配置DNS server的IP地址来的，通常这个server由ISP提供，当然，也可以采用免费的域名提供商提供的server。比如：<a href="https://www.opendns.com/" target="_blank" rel="noopener">OpenDNS</a>。至于，怎么使用，配置下它提供的DNS server的IP地址就可以了。所以中国封锁网站都是封IP，不是封域名。对于个别封锁域名的网站，用OpenDNS提供的服务既可以上被封的网站，因为OpenDNS找得倒被封域名的IP啊。</p>
<h2 id="Episode-3—–层级结构的顶层"><a href="#Episode-3—–层级结构的顶层" class="headerlink" title="Episode 3—–层级结构的顶层"></a>Episode 3—–层级结构的顶层</h2><hr>
<p>好了，咱的请求经过询问了根服务器后，得知了COM顶级域名服务器的地址（这个地址会缓存下来，下次就不必找根服务器了）。</p>
<p>然后，刚刚我们请求到达的根服务器只是全球13个根服务器其中的一个。根服务器在DNS层级结构中的最顶层。</p>
<p><img src="http://wx1.sinaimg.cn/large/a1ac93f3gy1fdmgg2b0iwj207q04bt8o.jpg" alt=""></p>
<p>全球分散着13个独立的组织,他们与13个根服务器一一对应，这些服务器的名字是以[A-M].root-servers.net的形式存在，字符A-M，刚好是13个。<br>但是！这不是意味着全球只有13个物理根服务器来支撑整个互联网！这个13个根服务器每一个都会有多份自己的镜像服务器分布在全球各地。</p>
<h2 id="Episode-4—–顶级域名的大杂烩"><a href="#Episode-4—–顶级域名的大杂烩" class="headerlink" title="Episode 4—–顶级域名的大杂烩"></a>Episode 4—–顶级域名的大杂烩</h2><hr>
<p>当当当，我们的请求到达了.COM顶级域名服务器。</p>
<p>先说个题外话:</p>
<blockquote>
<p><em>大部分顶级域名是归一个叫Internet Corporation for Assigned Names and Numbers(ICANN)的组织机构管理分配的。.COM这个顶级域名是世界上最早的一批创建的了，在1985年。现如今已成为互联网上最广泛的域名。</em></p>
</blockquote>
<p>当然了，还有很多其他类型的顶级域名，比如，.jp代表日本，.fr代表法国, .中国代表中国, 还有广为人知的.net,.org, .edu 。 最后还有一种域名,基础设施顶级域名(InfTLDs),比如, <a href="https://en.wikipedia.org/wiki/.arpa" target="_blank" rel="noopener">.ARPA</a>, 一般用来DNS反向查找,简单来说就是，从IP地址查域名。</p>
<p>现今，还有很多杂七杂八的顶级域名被建立了：.hot , .pizza, .app, .health等等。</p>
<p>现在回到之前的场景，我们的请求到达了.COM顶级域名服务器，.COM服务器为我们找到了一系列已授权的名字服务器：ns1.mathxh.com, ns2.mathxh.com …. ns6.mathxh.com （可能更多）。</p>
<h2 id="Episode-5—–回家"><a href="#Episode-5—–回家" class="headerlink" title="Episode 5—–回家"></a>Episode 5—–回家</h2><hr>
<p>由前一章节得知，问题来了，那么多个已授权的名字服务器，我到底该与哪个建立连接？（抓耳挠腮）。</p>
<p>简单！ 这就需要域名注册商的帮助了。</p>
<p>当买下域名的那一刻，域名注册商就联系顶级域名登记处预定这个名字,并把这个域名注册到已授权的名字服务器上（当然，这名字服务器有很多）。比如，一个域名example.com下面，就有多台对自己负责的名字服务器。</p>
<p>请求会直接去找ns1.mathxh.com的名字服务器，然后使用<a href="https://en.wikipedia.org/wiki/WHOIS" target="_blank" rel="noopener">WHOIS查询</a>，一般电脑上都安装这个工具了，最后，由其中一台nsX.mathxh.com告诉了我们mathxh.com的IP地址。</p>
<p>好了，完工了，请求记住了IP地址该原路返回回家了。请求把带回来的IP地址缓存了下来，以免下次需要使用又需要请求Resolver。最后，把IP地址告诉浏览器，浏览器就对IP地址开始真正请求访问了。</p>
<h2 id="终章——–哎哎？-好像错过了什么"><a href="#终章——–哎哎？-好像错过了什么" class="headerlink" title="终章——–哎哎？ 好像错过了什么"></a>终章——–哎哎？ 好像错过了什么</h2><hr>
<p>在找到mathxh.com的IP地址之前，是怎么找到ns1.mathxh.com的地址的？<br>不是要询问ns1.mathxh.com才找到mathxh.com的IP吗？还没有找到主域名的IP，就可以找到子域名ns1.mathxh.com的IP了吗？好矛盾呀。</p>
<p>我们是不可能在找到主域名mathxh.com的IP前,就得到子域名的IP的，无解！</p>
<p>其实实际情况是这样的：<br>当resolver询问.COM顶级域名服务器的时候，会有一个额外的信息response。这个response内就包含mathxh.com底下至少一个子域名的实际IP地址，所以resolver就知道nsX.mathxh.com的IP地址了。</p>
<p>所以resolver不仅知道子域名的名字，还知道子域名的IP地址，所以就打破了之前无解的循环依赖，由子域名就可以找到主域名的IP地址，主域名也可以找到子域名IP。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://alexiachen.github.io/blog/2017/03/09/how-dns-works/" data-id="cjtctj22a000xlbqfgyqdq4ln" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/DNS/">DNS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/TCP-IP/">TCP/IP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/计算机网络/">计算机网络</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-functional-programming-cpp11" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2017/03/03/functional-programming-cpp11/" class="article-date">
  <time datetime="2017-03-03T02:48:40.000Z" itemprop="datePublished">2017-03-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2017/03/03/functional-programming-cpp11/">C++11之函数式风格编程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p><em>C++是多范式编程语言，程序员可以选择多重范式的结合来编程，比如面向对象，面向过程，泛型编程，函数式特性。尤其是C++ 11标准中完善了函数式的一些特性，比如，lambda表达式，变参模版，新的STL函数bind。下面就讲讲怎样用C++ 11来写函数式风格的代码。</em></p>
</blockquote>
<h1 id="函数式风格编程"><a href="#函数式风格编程" class="headerlink" title="函数式风格编程"></a>函数式风格编程</h1><hr>
<ul>
<li><p>自动类型推导，<font color="red">auto</font>和<font color="red">decltype</font></p>
</li>
<li><p>lambda表达式的支持, 闭包，函数即数据</p>
</li>
<li><p>偏函数应用（partial funtion application），<font color="red">std::function</font>和<font color="red">std::bind</font>,lambda表达式和auto</p>
</li>
<li><p>STL与高阶函数的组合</p>
</li>
<li><p>用变参模版(variadic templates)来进行列表生成(List manipulation)</p>
</li>
<li><p>用模版全特化(full  template<br>specialisation)和偏特化(partial template<br>specialisation)来进行模式匹配(pattern matching)</p>
</li>
<li><p>用<font color="red">std::async</font>来进行惰性求值</p>
</li>
</ul>
<h1 id="为什么要以函数式风格来编程"><a href="#为什么要以函数式风格来编程" class="headerlink" title="为什么要以函数式风格来编程"></a>为什么要以函数式风格来编程</h1><hr>
<h3 id="STL结合lambda表达式更加简洁高效"><a href="#STL结合lambda表达式更加简洁高效" class="headerlink" title="STL结合lambda表达式更加简洁高效"></a>STL结合lambda表达式更加简洁高效</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">std</span>::accumulate(<span class="built_in">std</span>::begin(vec),<span class="built_in">std</span>::end(vec),                            </span><br><span class="line">         [](<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;<span class="keyword">return</span> a+b;&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="模式匹配之模版元编程"><a href="#模式匹配之模版元编程" class="headerlink" title="模式匹配之模版元编程"></a>模式匹配之模版元编程</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译时计算阶乘</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> N&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fac</span>&#123;</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="keyword">const</span> val= N * Fac&lt;N<span class="number">-1</span>&gt;::val; &#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fac</span>&lt;0&gt;&#123;</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="keyword">const</span> val= <span class="number">1</span>; &#125;;</span><br></pre></td></tr></table></figure>
<h3 id="还有更好更简洁的编程风格"><a href="#还有更好更简洁的编程风格" class="headerlink" title="还有更好更简洁的编程风格"></a>还有更好更简洁的编程风格</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用range for</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> v: vec) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h1 id="什么是函数式编程"><a href="#什么是函数式编程" class="headerlink" title="什么是函数式编程"></a>什么是函数式编程</h1><hr>
<ul>
<li><p>函数式编程就是以数学中的函数概念进行编程</p>
</li>
<li><p>数学中的函数在给定同样参数的情况下，每次调用函数的返回值都相同，不会有副作用(side-effect)</p>
</li>
<li><p>正因为函数调用没有副作用，那么函数从语义上相当于结果（Result）,是等价的，可以互相替换</p>
</li>
<li><p>因为无副作用的特性，编译器的优化器可以从更高层次来优化，增加优化潜力，重新组合函数的调用顺序，或者把不同的函数调用放到不同的线程中并行计算，提高并发可能性</p>
</li>
<li><p>程序的控制流就是以数据依赖驱动的了，而不是指令顺序</p>
</li>
</ul>
<h1 id="函数式编程的特点"><a href="#函数式编程的特点" class="headerlink" title="函数式编程的特点"></a>函数式编程的特点</h1><hr>
<ul>
<li>惰性求值(Lazy evaluation)</li>
<li>一等函数（first-class function）</li>
<li>高阶函数(higher-order function)</li>
<li>纯函数（pure function）  (这个C++不是纯函数，只有Haskell是纯函数)</li>
<li>递归</li>
<li>列表生成（manipulation of list）</li>
</ul>
<h1 id="一等函数"><a href="#一等函数" class="headerlink" title="一等函数"></a>一等函数</h1><hr>
<ul>
<li>一等函数属于一等公民，与数据地位相同，函数即是数据</li>
<li>函数可以当作参数来传递</li>
<li>函数可以当作值一样被其他函数返回</li>
<li>函数能被存储在变量或者数据结构中</li>
</ul>
<p>其实C语言也有类似的特性，函数指针，这样就有更强的表现能力，也明面上支持了回调。C++ 11直接支持lambda表达式了。就不需要那么复杂和不安全的函数指针了。</p>
<h1 id="一等函数表达能力之分发表（Dispatch-Table）"><a href="#一等函数表达能力之分发表（Dispatch-Table）" class="headerlink" title="一等函数表达能力之分发表（Dispatch Table）"></a>一等函数表达能力之分发表（Dispatch Table）</h1><hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>,<span class="built_in">std</span>::function&lt;<span class="keyword">double</span>(<span class="keyword">double</span>,<span class="keyword">double</span>)&gt;&gt;  tab;</span><br><span class="line"></span><br><span class="line">tab.insert(<span class="built_in">std</span>::make_pair(<span class="string">'+'</span>,[](<span class="keyword">double</span> a,<span class="keyword">double</span> b)&#123;<span class="keyword">return</span> a + b;&#125;));</span><br><span class="line">tab.insert(<span class="built_in">std</span>::make_pair(<span class="string">'-'</span>,[](<span class="keyword">double</span> a,<span class="keyword">double</span> b)&#123;<span class="keyword">return</span> a - b;&#125;));</span><br><span class="line">tab.insert(<span class="built_in">std</span>::make_pair(<span class="string">'*'</span>,[](<span class="keyword">double</span> a,<span class="keyword">double</span> b)&#123;<span class="keyword">return</span> a * b;&#125;));</span><br><span class="line">tab.insert(<span class="built_in">std</span>::make_pair(<span class="string">'/'</span>,[](<span class="keyword">double</span> a,<span class="keyword">double</span> b)&#123;<span class="keyword">return</span> a / b;&#125;));</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3.5+4.5= "</span> &lt;&lt; tab[<span class="string">'+'</span>](<span class="number">3.5</span>,<span class="number">4.5</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">//8</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3.5*4.5= "</span> &lt;&lt; tab[<span class="string">'*'</span>](<span class="number">3.5</span>,<span class="number">4.5</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 15.75</span></span><br><span class="line"></span><br><span class="line">tab.insert(<span class="built_in">std</span>::make_pair(<span class="string">'^'</span>,                                        </span><br><span class="line">                  [](<span class="keyword">double</span> a,<span class="keyword">double</span> b)&#123;<span class="keyword">return</span> <span class="built_in">pow</span>(a,b);&#125;));</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3.5^4.5= "</span> &lt;&lt; tab[<span class="string">'^'</span>](<span class="number">3.5</span>,<span class="number">4.5</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 280.741</span></span><br></pre></td></tr></table></figure>
<h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><hr>
<ul>
<li>高阶函数是一种接受其他函数作为参数或者是返回其他函数的一种函数</li>
</ul>
<p>说到这里，可能有人懵了，一等函数和高阶函数有啥不一样？请看以下代码块就知道了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">make_add</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>)</span>&#123; <span class="keyword">return</span> a + b;&#125;; </span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码，函数make_add就是高阶函数，匿名函数function(a,b)可以被bind到变量f上，或者本身也可以直接返回，所以这匿名函数就是一等函数。</p>
<p>所以，高阶函数用朴素的观点来理解的话，可以这么说：<font color="red">高阶函数是一等函数的应用</font></p>
<p>很多函数式编程语言，有三种经典的高阶函数应用直接体现：</p>
<ul>
<li><p>map , 应用一个函数到列表的每一个元素（element）上</p>
</li>
<li><p>filter, 从一个列表中移除一些元素</p>
</li>
<li><p>fold， 通过二分操作分解一个列表，直到一个列表变成单值(a single value)</p>
</li>
</ul>
<p>很多编程语言已经有以上三种语义的支持了：</p>
<p><img src="http://wx4.sinaimg.cn/large/a1ac93f3gy1fd9gqk9pduj20jx02yweu.jpg" alt=""></p>
<p>这三种语义有无数经典的应用场景：</p>
<p> Map + Reduce = <a href="https://en.wikipedia.org/wiki/MapReduce" target="_blank" rel="noopener">MapReduce</a></p>
<p>Haskell<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">vec</span> = [<span class="number">1</span> . . <span class="number">9</span>]</span><br><span class="line"><span class="title">str</span> = [<span class="string">"Programming"</span>,<span class="string">"in"</span>,<span class="string">"a"</span>,<span class="string">"functional"</span>,<span class="string">"style."</span>]</span><br><span class="line"></span><br><span class="line"><span class="title">map</span>(\a → a^<span class="number">2</span>) vec    <span class="comment">-- [1,4,9,16,25,36,49,64,81]</span></span><br><span class="line"><span class="title">map</span>(\a -&gt; length a) str <span class="comment">-- [11,2,1,10,6]</span></span><br><span class="line"></span><br><span class="line"><span class="title">filter</span>(\x-&gt; x&lt;<span class="number">3</span> || x&gt;<span class="number">8</span>) vec  <span class="comment">-- [1,2,9] </span></span><br><span class="line"><span class="title">filter</span>(\x → isUpper(head x)) str <span class="comment">-- [“Programming”]</span></span><br><span class="line"></span><br><span class="line"><span class="title">foldl</span> (\a b → a * b) <span class="number">1</span> vec   <span class="comment">-- 362800</span></span><br><span class="line"><span class="title">foldl</span> (\a b → a ++ <span class="string">":"</span> ++ b ) <span class="string">""</span> str <span class="comment">-- “:Programming:in:a:functional:style.”</span></span><br></pre></td></tr></table></figure></p>
<p>  Python<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vec = range(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line">str = [<span class="string">"Programming"</span>,<span class="string">"in"</span>,<span class="string">"a"</span>,<span class="string">"functional"</span>,<span class="string">"style."</span>]</span><br><span class="line"></span><br><span class="line">map(<span class="keyword">lambda</span> x :  x*x , vec) <span class="comment"># [1,4,9,16,25,36,49,64,81]</span></span><br><span class="line">map(<span class="keyword">lambda</span> x : len(x), str) <span class="comment"># [11,2,1,10,6]</span></span><br><span class="line"></span><br><span class="line">filter(<span class="keyword">lambda</span> x: x&lt;<span class="number">3</span> <span class="keyword">or</span> x&gt;<span class="number">8</span> , vec) <span class="comment"># [1,2,9]</span></span><br><span class="line">filter(<span class="keyword">lambda</span> x: x[<span class="number">0</span>].isupper(),str) <span class="comment"># [“Programming”]</span></span><br><span class="line"></span><br><span class="line">reduce(<span class="keyword">lambda</span> a , b: a * b, vec, <span class="number">1</span>) <span class="comment"># 362800</span></span><br><span class="line">reduce(<span class="keyword">lambda</span> a, b: a + b, str,<span class="string">""</span>) <span class="comment"># “:Programming:in:a:functional:style.”</span></span><br></pre></td></tr></table></figure></p>
<p>  C++ 11<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; str&#123;<span class="string">"Programming"</span>,<span class="string">"in"</span>,<span class="string">"a"</span>,<span class="string">"functional"</span>,       </span><br><span class="line">                <span class="string">"style."</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::transform(vec.begin(),vec.end(),vec.begin(),                 </span><br><span class="line">        [](<span class="keyword">int</span> i)&#123; <span class="keyword">return</span> i*i; &#125;); <span class="comment">// [1,4,9,16,25,36,49,64,81]</span></span><br><span class="line"><span class="built_in">std</span>::transform(str.begin(),str.end(),back_inserter(vec2),         </span><br><span class="line">        [](<span class="built_in">std</span>::<span class="built_in">string</span> s)&#123; <span class="keyword">return</span> s.length(); &#125;); <span class="comment">// [11,2,1,10,6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// [1,2,9]</span></span><br><span class="line">vec.erase(<span class="built_in">std</span>::remove_if(vec.begin(),vec.end(),</span><br><span class="line">[](<span class="keyword">int</span> i)&#123; <span class="keyword">return</span> !((i &lt; <span class="number">3</span>) <span class="keyword">or</span> (i &gt; <span class="number">8</span>)) &#125;),vec.end());</span><br><span class="line"><span class="comment">// [“Programming”]</span></span><br><span class="line">str.erase(<span class="built_in">std</span>::remove_if(str.begin(),str.end(),                   </span><br><span class="line">        [](<span class="built_in">string</span> s)&#123; <span class="keyword">return</span> !(<span class="built_in">isupper</span>(s[<span class="number">0</span>])); &#125;),str.end());</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::accumulate(vec.begin(),vec.end(),<span class="number">1</span>,                          </span><br><span class="line">         [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123; <span class="keyword">return</span> a*b; &#125;); <span class="comment">// 362800</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//“:Programming:in:a:functional:style.” </span></span><br><span class="line"><span class="built_in">std</span>::accumulate(str.begin(),str.end(),<span class="built_in">string</span>(<span class="string">""</span>),                 </span><br><span class="line">         [](<span class="built_in">string</span> a,<span class="built_in">string</span> b)&#123; <span class="keyword">return</span> a+<span class="string">":"</span>+b; &#125;);</span><br></pre></td></tr></table></figure></p>
<h1 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h1><hr>
<ul>
<li>纯函数VS不纯的函数（下图来自于<a href="https://book.douban.com/subject/3134515/" target="_blank" rel="noopener">《Real World Haskell》</a>）:</li>
</ul>
<p><img src="http://wx3.sinaimg.cn/large/a1ac93f3gy1fd9in6lmasj20j6048q3u.jpg" alt=""></p>
<ul>
<li><p>纯函数是独立的，这样让程序验证更加容易，也更加利于重构,测试，维护</p>
</li>
<li><p>非常有利于优化，比如，保存函数的调用结果，并行化</p>
</li>
<li><p>单子（Monad），是Haskell处理“不纯世界”的一种解决方案,它封装了不纯的世界，也是Haskell中的一个很重要的子系统，它也是表示计算的一种结构，甚至可以定义一组计算的组成结构</p>
</li>
</ul>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>C++ 11<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译时计算阶乘</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> N&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fac</span>&#123;</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="keyword">const</span> val= N * Fac&lt;N<span class="number">-1</span>&gt;::val; &#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fac</span>&lt;0&gt;&#123;</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="keyword">const</span> val= <span class="number">1</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算过程</span></span><br><span class="line">Fac&lt;<span class="number">3</span>&gt;::value = <span class="number">3</span> * Fac&lt;<span class="number">2</span>&gt;::value</span><br><span class="line">              = <span class="number">3</span> * <span class="number">2</span> * Fac&lt;<span class="number">1</span>&gt;::value</span><br><span class="line">              = <span class="number">3</span> * <span class="number">2</span> * <span class="number">1</span> * Fac&lt;<span class="number">0</span>&gt;::value</span><br><span class="line">              = <span class="number">3</span> * <span class="number">2</span> * <span class="number">1</span> * <span class="number">1</span></span><br><span class="line">              = <span class="number">6</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>递归是一种控制结构</li>
<li>递归和列表处理结合在函数式语言中是一种强力的模式</li>
</ul>
<p>同样的计算阶乘方式，我们用Haskell的模式匹配来实现以下：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fac</span> <span class="number">0</span> = <span class="number">1</span></span><br><span class="line"><span class="title">fac</span> n = n * fac (n<span class="number">-1</span>)</span><br></pre></td></tr></table></figure></p>
<h1 id="列表处理"><a href="#列表处理" class="headerlink" title="列表处理"></a>列表处理</h1><hr>
<ul>
<li>处理列表头head(x)</li>
<li>递归处理到列表尾tail(xs)</li>
</ul>
<p>比如：[1,2,3,4,5]  head(x) = [1] tail(xs) = [2,3,4,5]</p>
<p>那么用模式匹配+递归写出如下Haskell代码:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 求和</span></span><br><span class="line"><span class="title">mySum</span> []     = <span class="number">0</span></span><br><span class="line"><span class="title">mySum</span> (x:xs) = x + mySum xs</span><br><span class="line"><span class="title">mySum</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]    <span class="comment">-- 15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 计算过程</span></span><br><span class="line"><span class="title">mySum</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] = <span class="number">1</span> + mySum [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">                  = <span class="number">1</span> + <span class="number">2</span> mySum [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">                  = <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> mySum [<span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">                  = <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> + <span class="number">4</span> mySum [<span class="number">5</span>]</span><br><span class="line">                  = <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> + <span class="number">4</span> + <span class="number">5</span> + mySum []</span><br><span class="line">                  = <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> + <span class="number">4</span> + <span class="number">5</span> + <span class="number">0</span></span><br><span class="line">                  = <span class="number">15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 实现map语义</span></span><br><span class="line"><span class="title">myMap</span> f [] = []</span><br><span class="line"><span class="title">myMap</span> f (x:xs)= f x: myMap f xs  </span><br><span class="line"><span class="title">myMap</span> (\x → x*x)[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="comment">-- [1,4,9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 计算过程</span></span><br><span class="line"><span class="title">myMap</span> (\x → x*x)[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] </span><br><span class="line">=&gt; (\x -&gt; x*x) <span class="number">1</span> : myMap (\x -&gt; x*x) [<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">=&gt; <span class="number">1</span> : (\x -&gt; x*x) <span class="number">2</span> : myMap (\x -&gt; x*x) [<span class="number">3</span>]</span><br><span class="line">=&gt; <span class="number">1</span> : <span class="number">4</span> : (\x -&gt; x*x) <span class="number">3</span> : myMap (\x -&gt; x*x) []</span><br><span class="line">=&gt; <span class="number">1</span> : <span class="number">4</span> : <span class="number">9</span> : []</span><br><span class="line">=&gt; [<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>]</span><br></pre></td></tr></table></figure>
<p>下面用C++ 11 的变参模版来做以上的求和：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> ...&gt; <span class="class"><span class="keyword">struct</span> <span class="title">mySum</span>;</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;<span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class"><span class="title">mySum</span>&lt;&gt;&#123;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> head, <span class="keyword">int</span> ... tail&gt; <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class"><span class="title">mySum</span>&lt;head,tail...&gt;&#123;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> value= head + mySum&lt;tail...&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = mySum&lt;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&gt;::value;  <span class="comment">// 15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//计算过程</span></span><br><span class="line">mySum&lt;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&gt;::value</span><br><span class="line">=&gt; <span class="number">1</span> + mySum&lt;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&gt;::value</span><br><span class="line">=&gt; <span class="number">1</span> + <span class="number">2</span> + mySum&lt;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&gt;::value</span><br><span class="line">=&gt; <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> + mySum&lt;<span class="number">4</span>,<span class="number">5</span>&gt;::value</span><br><span class="line">=&gt; <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> + <span class="number">4</span> + mySum&lt;<span class="number">5</span>&gt;::value</span><br><span class="line">=&gt; <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> + <span class="number">4</span> + <span class="number">5</span> + mySum&lt;&gt;::value</span><br><span class="line">=&gt; <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> + <span class="number">4</span> + <span class="number">5</span> + <span class="number">0</span></span><br><span class="line">=&gt; <span class="number">15</span></span><br></pre></td></tr></table></figure>
<p>其实呢，归而结网，列表处理的核心思想就是模式匹配。</p>
<p>再举个例子，用Haskell的模式匹配写一个乘法函数：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">mult</span> n <span class="number">0</span> = <span class="number">0</span></span><br><span class="line"><span class="title">mult</span> n m = (mult n (m – <span class="number">1</span>)) + n</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 6</span></span><br><span class="line"><span class="title">mult</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--计算过程</span></span><br><span class="line"><span class="title">mult</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line">=&gt; (mult <span class="number">3</span> (<span class="number">2</span> - <span class="number">1</span>)) + <span class="number">3</span></span><br><span class="line">=&gt; (mult <span class="number">3</span> <span class="number">1</span>) + <span class="number">3</span></span><br><span class="line">=&gt; (mult <span class="number">3</span> (<span class="number">1</span> - <span class="number">1</span>)) + <span class="number">3</span> + <span class="number">3</span></span><br><span class="line">=&gt; (mult <span class="number">3</span> <span class="number">0</span>) + <span class="number">3</span> + <span class="number">3</span></span><br><span class="line">=&gt; <span class="number">0</span> + <span class="number">3</span> + <span class="number">3</span></span><br><span class="line">=&gt; <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>用C++ 11的模版元编程来写乘法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">int</span> N1, <span class="keyword">int</span> N2 &gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mult</span> &#123;</span> </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> value =  Mult&lt;N1, N2 - <span class="number">1</span>&gt;::value + N1; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">int</span> N1 &gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mult</span> &lt;N1,0&gt; &#123;</span> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> value = <span class="number">0</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="keyword">int</span> result = Mult&lt;<span class="number">3</span>,<span class="number">2</span>&gt;::value;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算过程</span></span><br><span class="line">Mult&lt;<span class="number">3</span>,<span class="number">2</span>&gt;::value</span><br><span class="line">=&gt; Mult&lt;<span class="number">3</span>,<span class="number">1</span>&gt;::value + <span class="number">3</span></span><br><span class="line">=&gt; Mult&lt;<span class="number">3</span>,<span class="number">0</span>&gt;::value + <span class="number">3</span> + <span class="number">3</span></span><br><span class="line">=&gt; <span class="number">0</span> + <span class="number">3</span> + <span class="number">3</span></span><br><span class="line">=&gt; <span class="number">6</span></span><br></pre></td></tr></table></figure>
<h1 id="惰性求值"><a href="#惰性求值" class="headerlink" title="惰性求值"></a>惰性求值</h1><hr>
<ul>
<li>简单说，就是到需要的时候再计算，不需要的时候不必计算</li>
<li>优势是，节省计算时间，节省内存使用。还有可以和无限数据结构结合(infinite data structures)</li>
</ul>
<h1 id="EOF"><a href="#EOF" class="headerlink" title="EOF"></a>EOF</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://alexiachen.github.io/blog/2017/03/03/functional-programming-cpp11/" data-id="cjtctj24b0070lbqfm0ia7xgr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/C-C/">C/C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/函数式编程/">函数式编程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-singleton-thread-safe" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2017/02/27/singleton-thread-safe/" class="article-date">
  <time datetime="2017-02-27T07:48:40.000Z" itemprop="datePublished">2017-02-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2017/02/27/singleton-thread-safe/">单例模式的线程安全</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在写单例模式的时候，一般我们都需要保证这个单例类的线程安全，当然，网络上有大部分“解决方案了”，加锁和双重检查锁配合来“保证”单例类的线程安全，可是，如果把指令重排序也考虑到其中的话，这样的写法，就是非线程安全了。</p>
<p>随便列出网络上几篇博文的单例模式都<font color="red">不是</font>线程安全的：</p>
<ul>
<li><a href="http://www.cnblogs.com/weixliu/p/3900764.html" target="_blank" rel="noopener">单例模式全面学习（C++版）</a></li>
<li><a href="http://www.cnblogs.com/qiaoconglovelife/p/5851163.html" target="_blank" rel="noopener">C++的单例模式与线程安全单例模式（懒汉/饿汉）</a></li>
<li><a href="http://www.cnblogs.com/xudong-bupt/p/3433643.html" target="_blank" rel="noopener">设计模式之单例模式(线程安全)</a></li>
</ul>
<p>以下是网络上大部分的“经典”的“线程安全”单例模式实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@ actually <span class="keyword">not</span> thread safe</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> singleton* p&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::mutex m_mutex;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> singleton* <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    singleton(<span class="keyword">const</span> singleton&amp; s) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">singleton* singleton:: getInstance()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// double-check locker</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) <span class="comment">// first check</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(m_mutex); <span class="comment">// lock</span></span><br><span class="line">            <span class="keyword">if</span> (p == <span class="literal">nullptr</span>)   <span class="comment">// second check</span></span><br><span class="line">                p = <span class="keyword">new</span> singleton(); <span class="comment">// but this may cause non-thread-safe</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先，先讲解一下，指令重排会发生在系统的好几个层面，我分别用C++和Java来讲解：</p>
<ul>
<li><p>C++ 被编译器编译成机器码的时候，机器码的顺序可能被重排过，在程序运行的时候，在CPU内部也可能会选择性的又进行一次重排，总共2次，重排是必定会发生的。</p>
</li>
<li><p>Java 被编译器编译成字节码的时候会重排一次，JVM执行字节码的时候又进行一次重排，JVM执行的字节码最终也是变成机器码在CPU内部又会进行重排，总共是3次。</p>
</li>
</ul>
<p>所以了，到头来，指令重排是不可能消除的，这是编译器和CPU优化的领域，就不进行过多的探讨。</p>
<p>下面来讲解一下以上的单例类的代码，以及为什么它在指令重排序的情况下会变成非线程安全：</p>
<p>我上面把代码的注释写了，问题就出现在new 那里，熟悉C++的开发者可能知道new语句的大概执行动作，我把它分解成如下几步：</p>
<ol>
<li>分配对象的内存空间，可以简单理解为malloc</li>
<li>调用对象的构造函数初始化对象（内存空间上的对象状态此刻是合法的了）</li>
<li>把内存空间的地址赋值给p指针</li>
</ol>
<p>注意了，如果编译器生成的代码，和CPU内部的执行顺序永远是按以上的顺序执行，那么永远都不用担心线程安全的问题，但是由于<a href="https://en.wikipedia.org/wiki/Happened-before" target="_blank" rel="noopener">happens-before语义</a>，2和3步骤没有严格的依赖顺序，编译器有些时候为了优化，完全可以把3放到2时候执行，2也会放到3时候执行。那么这样情况下，可以就会变成下面这样了：</p>
<ol>
<li>分配对象的内存空间，可以简单理解为malloc</li>
<li>把内存空间的地址赋值给p指针 （此刻内存空间上的对象状态不合法，没初始化）</li>
<li>调用对象的构造函数初始化对象（内存空间上的对象状态此刻是合法的了）</li>
</ol>
<p>还想深入了解happens-before的，可以看<a href="http://ifeve.com/happens-before/" target="_blank" rel="noopener">这里</a>。</p>
<p>那么，指令重排下，以上的单例代码可能变成以下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@ actually <span class="keyword">not</span> thread safe</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> singleton* p&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::mutex m_mutex;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> singleton* <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    singleton(<span class="keyword">const</span> singleton&amp; s) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">singleton* singleton:: getInstance()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// double-check locker</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) <span class="comment">// first check</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(m_mutex); <span class="comment">// lock</span></span><br><span class="line">            <span class="keyword">if</span> (p == <span class="literal">nullptr</span>)   <span class="comment">// second check</span></span><br><span class="line">             &#123;</span><br><span class="line">                    <span class="comment">//以下是抽象出来的伪代码</span></span><br><span class="line">                    memory_addr = <span class="built_in">malloc</span>();   <span class="comment">//1：分配对象的内存空间  </span></span><br><span class="line">                    p = memory_addr;     <span class="comment">//2：设置p指向刚分配的内存地址  </span></span><br><span class="line">                                 <span class="comment">//注意，此时对象还没有被初始化！  </span></span><br><span class="line">                    singleton_constructor(memory);  <span class="comment">//3：初始化对象  </span></span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>聪明的人，一下子就可以看出来以上的代码在多线程下可能会导致的问题了，<br>还不明白的话，我做了一个线程执行时间表：</p>
<table>
<thead>
<tr>
<th>时间序列</th>
<th style="text-align:center">线程A</th>
<th style="text-align:right">线程B</th>
</tr>
</thead>
<tbody>
<tr>
<td>t1</td>
<td style="text-align:center">分配对象的内存空间</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>t2</td>
<td style="text-align:center">设置p指向内存空间</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>t3</td>
<td style="text-align:center"></td>
<td style="text-align:right">判断p是否为nullptr</td>
</tr>
<tr>
<td>t4</td>
<td style="text-align:center"></td>
<td style="text-align:right">由于p不为nullptr，线程B将访问p指向的对象（而这个时候对象还没有初始化）</td>
</tr>
<tr>
<td>t5</td>
<td style="text-align:center">初始化对象（调用构造函数）</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>t6</td>
<td style="text-align:center">访问p指向的对象</td>
</tr>
</tbody>
</table>
<p>线程B拿到一个未初始化的对象（对象状态不合法）去操作，结果肯定就出错了。</p>
<p>那么如何写才能保证线程安全呢？ 我给出几种方案:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@ thread safe</span><br><span class="line"><span class="comment">// 以下代码虽然是C++ 11的，但是你可以把它理解非C++ 11，如果是C++ 11的话，从标准上就保证 静态初始化就是线程安全的，完全没必要像下面这样做了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> atomic &lt; singleton* &gt; p&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::mutex m_mutex;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> singleton* <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    singleton(<span class="keyword">const</span> singleton&amp; s) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">singleton* singleton:: getInstance()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// double-check locker</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) <span class="comment">// first check</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(m_mutex); <span class="comment">// lock</span></span><br><span class="line">            <span class="keyword">if</span> (p == <span class="literal">nullptr</span>)   <span class="comment">// second check</span></span><br><span class="line">             &#123;</span><br><span class="line">                    p = <span class="keyword">new</span> singleton(); </span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是C++ 11的代码，完全没必要这么繁琐了，可以直接像下面这么干：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ 11标准保证这是线程安全的，当然也得看编译器产商怎么实现了，比如悲剧的是</span></span><br><span class="line"><span class="comment">// VS2013下这么做是非线程安全的,但VS2015下绝对是线程安全</span></span><br><span class="line"><span class="comment">// 参考： https://msdn.microsoft.com/en-gb/library/hh567368.aspx</span></span><br><span class="line"><span class="function">singleton*&amp; <span class="title">getInst</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> singleton* p = <span class="keyword">new</span> singleton();</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>详情请戳<a href="http://stackoverflow.com/questions/2576022/efficient-thread-safe-singleton-in-c" target="_blank" rel="noopener">这里</a>。</p>
<p>如果是Java代码，建议按以下这么干，保证线程安全：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> singleton INSTANCE = <span class="keyword">new</span> singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// rest of class omitted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上Java代码完全不需要加锁，Java的类加载器已经保证必定会在访问类的时候，最先初始化singleton。</p>
<p>详情请戳<a href="http://stackoverflow.com/questions/16106260/thread-safe-singleton-class" target="_blank" rel="noopener">这里</a>和<a href="http://stackoverflow.com/questions/4482533/thread-safe-efficient-way-to-implement-singleton-pattern-in-java" target="_blank" rel="noopener">这里</a>。</p>
<p>EOF</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://alexiachen.github.io/blog/2017/02/27/singleton-thread-safe/" data-id="cjtctj22z0023lbqflopqi54g" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/单例模式/">单例模式</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/指令重排序/">指令重排序</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/线程安全/">线程安全</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-sqlite-concurrency" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2017/02/23/sqlite-concurrency/" class="article-date">
  <time datetime="2017-02-23T09:48:40.000Z" itemprop="datePublished">2017-02-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2017/02/23/sqlite-concurrency/">SQLite的并发</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p><em>以前没有好好看过SQLite，并没有对它有更深入点的了解，就当软件本地的配置文件和小规模数据统计来使用，对它的一些知识不是很清晰，今天就借助SQLite官方文档选择性的了解下，主要关注并发，多线程和多进程访问</em></p>
</blockquote>
<h4 id="多个进程应用实例是否能同时访问单个数据库文件？"><a href="#多个进程应用实例是否能同时访问单个数据库文件？" class="headerlink" title="多个进程应用实例是否能同时访问单个数据库文件？"></a>多个进程应用实例是否能同时访问单个数据库文件？</h4><hr>
<p>多进程能同时打开一个数据库，多进程也能同时对一个数据库进行SELECT，但是任意一时刻，有且仅有一个进程能修改一个数据库。</p>
<p>SQLite使用读写锁来控制数据库的访问。但是，使用时请注意：这种锁机制可能在网络文件系统（NFS）上不能正确工作。所以，应该避免多进程访问一个在网络文件系统上的数据库文件。另外，在Windows下，这个锁机制如果在不运行Share.exe守护进程的情况下，在FAT文件系统下就无法工作，由于锁机制，数据库文件在Windows网络共享中多进程访问有严重BUG，所以不要在多台Windows机器之间共享数据库文件。</p>
<p>应该明白，没有一个为嵌入式设计的数据库会支持高并发的，SQLIte允许多进程同时打开，读取数据。但是多进程写数据库下，当任意一个进程想写的话，那么在进程修改数据库期间SQLite会锁住整个数据库文件。但是这样一般只会耗费几毫秒。其他进程只用简单等待锁释放就可以进行操作了。</p>
<p>如果有高并发的需求，一定选择C/S模型的数据库（MySQL，SQLserver，PostgreSQL）。</p>
<p>但是，从经验上讲，大多数应用程序不需要这么大的并发。</p>
<p>当SQLite试图访问一个被其他进程锁住的数据库文件，那么SQLite默认行为会返回SQLITE_BUSY。</p>
<h4 id="SQLite是否线程安全？"><a href="#SQLite是否线程安全？" class="headerlink" title="SQLite是否线程安全？"></a>SQLite是否线程安全？</h4><hr>
<p>是的，如果要让SQLite支持线程安全，就使用SQLITE_THREADSAFE预编译宏来编译SQlite。当然，不用担心，Windows和Linux的二进制发布版就是这样编译的。</p>
<p>SQLite支持线程安全是为了用互斥量同步公共的数据结构。然而要请求和释放锁，所以SQLite性能会略有下降。如果开发者没有线程安全这样的需求，可以重新编译SQLite，关闭互斥量以得到最大性能。</p>
<p>实际上加锁不会太影响性能，影响性能的是锁争用，如果不是多线程，我觉得也可以单线程程序使用线程安全版本的SQLite。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://alexiachen.github.io/blog/2017/02/23/sqlite-concurrency/" data-id="cjtctj22y0021lbqfe0jyxvum" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/SQLite/">SQLite</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/数据库/">数据库</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-cpp-best-practices" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2017/02/22/cpp-best-practices/" class="article-date">
  <time datetime="2017-02-22T00:58:23.000Z" itemprop="datePublished">2017-02-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2017/02/22/cpp-best-practices/">C++最佳实践</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>该篇文章是我自己的经验总结，不可能100%适合读者，当然相关的C++工程实践书籍类似《Effective C++》，《More Effective C++》，《Modern Effective C++》，《Learning C++ Best Practices》 《Google C++ Coding Style》等等可能都有类似描述,我这篇文章可能也是从以上的书籍文章汲取了一些。</p>
</blockquote>
<h1 id="工欲善其事必先利其器"><a href="#工欲善其事必先利其器" class="headerlink" title="工欲善其事必先利其器"></a>工欲善其事必先利其器</h1><hr>
<p>现在软件工程越来越发达，C++的标准也一直在改进更新，这门在大众来看的“古老”语言也在慢慢变得更加像现代编程语言一样了，现代软件工程持续交付，持续集成等工具概念层出不穷，这里我想推荐些工具给读者改进优化项目开发流程</p>
<ul>
<li><p><a href="https://cmake.org/" target="_blank" rel="noopener">Cmake</a>，最好的C++跨平台构建工具，没有之一，automake，qmake在它面前黯然失色。</p>
</li>
<li><p><a href="http://travis-ci.org/" target="_blank" rel="noopener">Travis CI</a>, 这个是持续集成工具，能在Github上很好的工作。</p>
</li>
<li><p><a href="http://cppcheck.sourceforge.net/" target="_blank" rel="noopener">CppCheck</a>, C/C++ 静态分析工具，免费的，能查出很多类型缺陷，内存泄漏和资源泄漏。当然还有很多语言的静态分析工具，如果有兴趣，请看<a href="https://en.wikipedia.org/wiki/List_of_tools_for_static_code_analysis" target="_blank" rel="noopener">这里</a></p>
</li>
</ul>
<p>另外，在个人项目和公司项目中，C++编译器，无论在g++，MSVC，或者clang上，请把警告级别调整到最高。MSVC我是调整到W4级别，g++上，由于本人不熟悉g++的警告类型，那么请开-Wall -Wextra警告并严格观察，另外g++上还可以开-Weffc++选项，编译器会按照《Effective C++》的实践规范来检查代码的隐患。这些都是很重要，编译器的警告很<a href="https://www.zhihu.com/question/29155164" target="_blank" rel="noopener">重要</a>！！要好好利用静态类型语言带来的优点。最后把警告尽量消除到0 warnings为止！ 最后的最后，用C++的静态分析工具检查一遍所有的源码，选择性的消除工具报告出来的缺陷。这样你会发现，后期的软件的运行时的BUG会少很多，特别是不明不白的crash。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><hr>
<h4 id="1-基本C-命名规范"><a href="#1-基本C-命名规范" class="headerlink" title="1.基本C++命名规范"></a>1.基本C++命名规范</h4><hr>
<ul>
<li>类名用驼峰命名法: MyClass</li>
<li>类的成员函数和变量名开头单词用小写：myMethod</li>
<li>常量全用大写：const double PI = 3.1415926</li>
</ul>
<p>另外C++标准库和Boost采用另一种规范，如果你的代码与标准库和Boost混合写契合度很高，推荐用以下的规范：</p>
<ul>
<li>宏名称单词全用大写，单词之间用下划线隔开： INT_MAX</li>
<li>模版参数使用驼峰命名法： InputInterator</li>
<li>其他所有变量和函数名，类名全用小写单词加下划线隔开：make_shared,unordered_map,dynamic_cast</li>
</ul>
<h4 id="2-区分私有成员变量"><a href="#2-区分私有成员变量" class="headerlink" title="2.区分私有成员变量"></a>2.区分私有成员变量</h4><hr>
<ul>
<li>在私有成员变量前面加入m_前缀, m代表“member”： m_height</li>
</ul>
<p>当然，个别一些习惯，是在私有成员变量后加下划线后缀： object_</p>
<h4 id="3-区分函数参数"><a href="#3-区分函数参数" class="headerlink" title="3.区分函数参数"></a>3.区分函数参数</h4><hr>
<ul>
<li>在函数参数名加入t_前缀： t_height</li>
</ul>
<p>当然，代码最重要的还是要与CodeBase一致，最终看公司的规范，这里只是一个样例，t可以认为是“the”的缩写。这只是区分函数参数与局部变量的一种策略。</p>
<h4 id="4-任何命名不能是下划线开头"><a href="#4-任何命名不能是下划线开头" class="headerlink" title="4.任何命名不能是下划线开头"></a>4.任何命名不能是下划线开头</h4><hr>
<p>如果你这么做，那么可能会与编译器的扩展关键字造成冲突。如果好奇，那么请看stackoverflow的这个<a href="http://stackoverflow.com/questions/228783/what-are-the-rules-about-using-an-underscore-in-a-c-identifier" target="_blank" rel="noopener">讨论</a>。</p>
<h4 id="5-一个良好的样例"><a href="#5-一个良好的样例" class="headerlink" title="5.一个良好的样例"></a>5.一个良好的样例</h4><hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  MyClass(<span class="keyword">int</span> t_data, <span class="keyword">int</span> t_attr)</span><br><span class="line">    : m_data(t_data),m_attr(t_attr)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_data;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">attribute</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> m_attr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> m_data;</span><br><span class="line">  <span class="keyword">int</span> m_attr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="6-空指针的表示请用nullptr"><a href="#6-空指针的表示请用nullptr" class="headerlink" title="6.空指针的表示请用nullptr"></a>6.空指针的表示请用nullptr</h4><hr>
<p>C++ 11 中的空指针是一个特定的值，用以代替0或NULL。 如果好奇，请看知乎的<a href="https://www.zhihu.com/question/55936870" target="_blank" rel="noopener">讨论</a>, 不然值会有二义性。另外，知乎上还有<a href="https://www.zhihu.com/question/22203461" target="_blank" rel="noopener">讨论2</a>。</p>
<h4 id="7-注释"><a href="#7-注释" class="headerlink" title="7.注释"></a>7.注释</h4><hr>
<p>优先使用//来注释代码块，不要使用/**/</p>
<h4 id="8-不要在头文件中使用using-namespace"><a href="#8-不要在头文件中使用using-namespace" class="headerlink" title="8.不要在头文件中使用using namespace"></a>8.不要在头文件中使用using namespace</h4><hr>
<p>这会导致using的名字空间污染范围扩散，因为使用了这个头文件的源文件都隐式使用这个名字空间了，这将来容易造成名字空间的冲突，该错误查找困难。不利于后来开发人员维护。</p>
<h4 id="9-头文件守护"><a href="#9-头文件守护" class="headerlink" title="9.头文件守护"></a>9.头文件守护</h4><hr>
<p>这个想必很多人已经习惯了，不过如果不这样做的危害还是要说一下，这样可以防止头文件被重复包含多次而造成的问题,也能解决意外包含其他工程头文件的冲突。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYPROJECT_MYCLASS_HPP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYPROJECT_MYCLASS_HPP</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> MyProject &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4 id="10-代码块一定要用"><a href="#10-代码块一定要用" class="headerlink" title="10.代码块一定要用{}"></a>10.代码块一定要用{}</h4><hr>
<p>如果不这么做，可能会导致一些语义错误。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad Idea</span></span><br><span class="line"><span class="comment">// 这么做虽然没错，能按照预想运行，但是会给后来人员造成迷惑</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; ++i)</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bad Idea</span></span><br><span class="line"><span class="comment">// 这就有错了，std::cout没在循环内，变量i也不是循环内的，与预想不一致</span></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; ++i)</span><br><span class="line">  ++sum;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Good Idea</span></span><br><span class="line"><span class="comment">// 这个语义就完全正确了。</span></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; ++i) &#123;</span><br><span class="line">  ++sum;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="11-限制代码列的字符数"><a href="#11-限制代码列的字符数" class="headerlink" title="11.限制代码列的字符数"></a>11.限制代码列的字符数</h4><hr>
<p>一般推荐是80-100个字符之间，我自己是80。一般IDE和文本编辑器都可以强制限制。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad Idea</span></span><br><span class="line"><span class="comment">// 难阅读</span></span><br><span class="line"><span class="keyword">if</span> (x &amp;&amp; y &amp;&amp; myFunctionThatReturnsBool() &amp;&amp; caseNumber3 &amp;&amp; (<span class="number">15</span> &gt; <span class="number">12</span> || <span class="number">2</span> &lt; <span class="number">3</span>)) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good Idea</span></span><br><span class="line"><span class="comment">// 逻辑思路跟得上了，容易阅读</span></span><br><span class="line"><span class="keyword">if</span> (x &amp;&amp; y &amp;&amp; myFunctionThatReturnsBool()</span><br><span class="line">    &amp;&amp; caseNumber3</span><br><span class="line">    &amp;&amp; (<span class="number">15</span> &gt; <span class="number">12</span> || <span class="number">2</span> &lt; <span class="number">3</span>)) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="12-使用””包含本地头文件"><a href="#12-使用””包含本地头文件" class="headerlink" title="12.使用””包含本地头文件"></a>12.使用””包含本地头文件</h4><hr>
<p>&lt;&gt; 是保留给标准库和系统库头文件的，自己写的本地头文件#include “MyHeader.h”</p>
<h4 id="13-初始化成员变量"><a href="#13-初始化成员变量" class="headerlink" title="13.初始化成员变量"></a>13.初始化成员变量</h4><hr>
<p>最好用初始化成员列表来初始化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad Idea</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  MyClass(<span class="keyword">int</span> t_value)</span><br><span class="line">  &#123;</span><br><span class="line">    m_value = t_value; <span class="comment">//这是赋值，而不是初始化</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> m_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Good Idea</span></span><br><span class="line"><span class="comment">// C++ 初始化成员列表是C++语言特有的，这样写代码更加清晰干净，</span></span><br><span class="line"><span class="comment">// 而且还有潜在的性能提升，因为初始化和赋值不是一个概念。</span></span><br><span class="line"><span class="comment">// 《Effective C++》也提到过</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  MyClass(<span class="keyword">int</span> t_value)</span><br><span class="line">    : m_value(t_value)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> m_value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>好奇请戳知乎的<a href="https://www.zhihu.com/question/37345224" target="_blank" rel="noopener">讨论</a>。</p>
<p>当然，在C++ 11中，你可以考虑总是给成员变量一个默认值，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... //</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> m_value = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// ... //</span></span><br></pre></td></tr></table></figure>
<p>使用大括号初始化,因为它在编译时不允许数据收窄。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Best Idea</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ... //</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> m_value&#123; <span class="number">0</span> &#125;; <span class="comment">// allowed</span></span><br><span class="line">  <span class="keyword">unsigned</span> m_value_2 &#123; <span class="number">-1</span> &#125;; <span class="comment">// compile-time error, narrowing from signed to unsigned.</span></span><br><span class="line"><span class="comment">// ... //</span></span><br></pre></td></tr></table></figure>
<p>优先使用大括号初始化，除非有原因的特殊要求不那么做。</p>
<h4 id="14-总是使用名字空间"><a href="#14-总是使用名字空间" class="headerlink" title="14.总是使用名字空间"></a>14.总是使用名字空间</h4><hr>
<p>在C语言时代，很多库的开发者，为了防止函数符号链接时冲突，就在函数名加入库名称的前缀，比如OpenCV的函数都是cv_xxxx。当然，这是历史原因，如果是采用C++ 编译器，就应该使用namespace防止符号冲突，采用boost库的方式。</p>
<h4 id="15-使用标准库提供的正确的整型类型"><a href="#15-使用标准库提供的正确的整型类型" class="headerlink" title="15.使用标准库提供的正确的整型类型"></a>15.使用标准库提供的正确的整型类型</h4><hr>
<p>在C++中，最好不要出现int类型，最好是intxxx_t , uintxxx_t。 表示大小请使用std::size_t。</p>
<p>可以看这里的<a href="http://www.cplusplus.com/reference/cstdint/" target="_blank" rel="noopener">参考</a>，这样提高可移植性，因为在不同类型的平台上，这些类型会typedef到特定类型上去。</p>
<p>注意： signed char 保证至少 8 位，int 保证至少 16 位，long 保证至少 32 位，long long 保证至少 64 位。</p>
<p>如果还不明白，去看stackoverflow的<a href="http://stackoverflow.com/questions/13398630/why-are-c-int-and-long-types-both-4-bytes" target="_blank" rel="noopener">讨论</a></p>
<h4 id="16-Tab和空格不要混合使用"><a href="#16-Tab和空格不要混合使用" class="headerlink" title="16.Tab和空格不要混合使用"></a>16.Tab和空格不要混合使用</h4><hr>
<p>这个绝对禁止，应该从编辑器和IDE里面更改设置，比如让Tab等于4个空格。至于设置Tab等于多少个空格合理，这个是个人喜好问题，不然就是Emacs和Vim之争了。</p>
<h4 id="17-不要害怕模版"><a href="#17-不要害怕模版" class="headerlink" title="17.不要害怕模版"></a>17.不要害怕模版</h4><hr>
<p>这个，我对于C++的模版元编程不熟悉，就不做过多讨论了。模版可以说是另外一种语言，另一种“函数式”语言。它是图灵完备(Turing-Complete)的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// check specific class if it has foo() function</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Ty&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">has_foo_function</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">char</span> yes[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">char</span> no[<span class="number">2</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Inner&gt;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> yes&amp; <span class="title">test</span><span class="params">(Inner *I, <span class="keyword">decltype</span>(I-&gt;foo()) * = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> no&amp; <span class="title">test</span><span class="params">(...)</span></span>;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">bool</span> value =</span><br><span class="line">		<span class="keyword">sizeof</span>(test&lt;Ty&gt;(<span class="literal">nullptr</span>)) == <span class="keyword">sizeof</span>(yes);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTest1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTest2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTest3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123; <span class="keyword">return</span> s; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; has_foo_function&lt;MyTest1&gt;::value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 1</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; has_foo_function&lt;MyTest2&gt;::value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 0</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; has_foo_function&lt;MyTest3&gt;::value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>感兴趣可以在网络上看到各种玩法：</p>
<ul>
<li><a href="https://www.zhihu.com/question/46612915" target="_blank" rel="noopener">玩模板元编程走火入魔是一种怎样的体验</a></li>
<li><a href="https://www.zhihu.com/question/21656266" target="_blank" rel="noopener">C++ 模板元编程的应用有哪些，意义是什么</a></li>
<li><a href="https://www.zhihu.com/question/39637015" target="_blank" rel="noopener">模板元编程和泛函编程都是函数式编程吗</a></li>
<li><a href="https://www.zhihu.com/question/23463256" target="_blank" rel="noopener">如何正确的学习C++的模板和模板元编程</a></li>
<li><a href="https://www.zhihu.com/question/19794858" target="_blank" rel="noopener">怎么样才算是精通 C++</a></li>
</ul>
<h4 id="18-慎用操作符重载"><a href="#18-慎用操作符重载" class="headerlink" title="18.慎用操作符重载"></a>18.慎用操作符重载</h4><hr>
<p>重载操作符是个很方便的特性，比如用C++ 实现一个BigInteger类，一个类的实体表示一个大整数，如果给类实现一个add函数表示大整数做加法，a.add(b),那么太不直观了，a + b更加方便直观。另一个官方例子就是std::string重载了+号操作符，以便字符串的拼接。当然，重载操作符本质上还是调用函数。</p>
<p>虽然方便，但是如果随意重载操作符，可能导致许多诡异的错误，详情见这里的<a href="http://stackoverflow.com/questions/4421706/operator-overloading/4421708" target="_blank" rel="noopener">讨论</a>。</p>
<p>尤其是，当需要编写重载操作符的时候，应该把以下几点时时刻刻记住在脑子里：</p>
<ul>
<li>当有必须的理由的时候才重载 operator= </li>
<li>对于剩下的全部操作符，也是有需要在一个场景下使用的时候才重载它们，这个场景比如，+ - 是一对语义上有关联的符号</li>
<li>时刻注意<a href="http://en.cppreference.com/w/cpp/language/operator_precedence" target="_blank" rel="noopener">操作符的优先级</a>，即使重载了，那操作符的优先级也不会改变，不能凭感觉猜测。</li>
<li>不要重载一些特殊奇怪的操作符，比如 ~ 和 % #之类的，除非有理由让你这么做</li>
<li><a href="http://stackoverflow.com/questions/5602112/when-to-overload-the-comma-operator" target="_blank" rel="noopener"><strong>永远</strong></a>不要重载逗号(,)操作符</li>
</ul>
<p>剩下给出一个重载操作符的<a href="http://courses.cms.caltech.edu/cs11/material/cpp/donnie/cpp-ops.html" target="_blank" rel="noopener">参考资料</a></p>
<h4 id="19-消除隐式转换"><a href="#19-消除隐式转换" class="headerlink" title="19.消除隐式转换"></a>19.消除隐式转换</h4><hr>
<ul>
<li>对于单参构造函数,必须在构造函数前加入 explicit 关键字，要求显式调用</li>
<li>对于操作符转换也是一样的，需要加 explicit 关键字 </li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bad idea</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//good idea</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="20-考虑零原则（Rule-of-Zero）"><a href="#20-考虑零原则（Rule-of-Zero）" class="headerlink" title="20.考虑零原则（Rule of Zero）"></a>20.考虑零原则（Rule of Zero）</h4><hr>
<p>该原则声称，不要提供任何编译器能自动生成的函数（拷贝构造，拷贝赋值构造，移动构造，移动赋值构造，析构函数），除非该类需要构造一些关于所有权（ownership）的概念。</p>
<p>该原则的目的是让当更多的成员变量被添加到该类时，让编译器提供最佳的版本，换句话说，这些东西最好让编译器来维护。</p>
<p>该原则的背景在<a href="http://blog.florianwolters.de/educational/2015/01/31/The_Rule_of_Zero/" target="_blank" rel="noopener">这里</a>，然后<a href="http://www.nirfriedman.com/2015/06/27/cpp-rule-of-zero/" target="_blank" rel="noopener">这篇文章</a>做了实现并解释了技术。</p>
<h4 id="21-尽可能多的用const修饰"><a href="#21-尽可能多的用const修饰" class="headerlink" title="21.尽可能多的用const修饰"></a>21.尽可能多的用const修饰</h4><hr>
<p>const 告诉编译器方法或变量是不可变（immutable）的，这也能帮助编译器优化代码,同时也能帮助开发者知道函数是否有副作用（side-effect）。另外，常引用(const &amp;)也能阻止编译器进行不必要的拷贝代价。感兴趣的可以看这篇文章底下<a href="http://kotaku.com/454293019" target="_blank" rel="noopener">John Carmack的评论</a>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If the parameter is input parameter, not output</span></span><br><span class="line"><span class="comment">// Bad Idea</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">do_something</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">do_something</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> str)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Good Idea</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">do_something</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">do_something</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;str)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">#### <span class="number">22.</span>小心函数返回的类型</span><br><span class="line"></span><br><span class="line">----</span><br><span class="line"></span><br><span class="line">Getters:</span><br><span class="line">- 以引用返回或者常引用返回的,在观察者模式下这会有一定的性能提升。</span><br><span class="line">- 以值返回更加有助于线程安全（thread safety）,即使有拷贝的代价，由于[RVO](https:<span class="comment">//en.wikipedia.org/wiki/Return_value_optimization)的作用，性能也不会损失。</span></span><br><span class="line"></span><br><span class="line">临时和局部变量：</span><br><span class="line">- 总是以值返回</span><br><span class="line"></span><br><span class="line">#### <span class="number">23.</span>不要用常引用(<span class="keyword">const</span> &amp;)来传递或返回一个基本类型变量</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">``` cpp</span><br><span class="line"><span class="comment">// Very Bad Idea</span></span><br><span class="line">class MyClass</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">explicit</span> MyClass(<span class="keyword">const</span> <span class="keyword">int</span>&amp; t_int_value)</span><br><span class="line">    : m_int_value(t_int_value)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span>&amp; get_int_value() <span class="keyword">const</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> m_int_value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> m_int_value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good Idea</span></span><br><span class="line">class MyClass</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">explicit</span> MyClass(<span class="keyword">const</span> <span class="keyword">int</span> t_int_value)</span><br><span class="line">    : m_int_value(t_int_value)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> get_int_value() <span class="keyword">const</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> m_int_value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> m_int_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么呢？ 因为对于基本类型变量用引用传递或返回会导致指针操作，这会更加慢。如果通过值传递，是利用处理器寄存器直接传递的，会更加快。</p>
<h4 id="24-避免裸指针访问内存"><a href="#24-避免裸指针访问内存" class="headerlink" title="24.避免裸指针访问内存"></a>24.避免裸指针访问内存</h4><hr>
<p>直接内存分配和释放在C++中做到完全消除内存错误和内存泄漏是很难的，要善于利用RAII，C++ 11提供了智能指针这种方便的工具，基本可能杜绝内存泄漏。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad Idea</span></span><br><span class="line">MyClass *myobj = <span class="keyword">new</span> MyClass;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">delete</span> myobj;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Good Idea</span></span><br><span class="line"><span class="keyword">auto</span> myobj = <span class="built_in">std</span>::make_unique&lt;MyClass&gt;(constructor_param1, constructor_param2); <span class="comment">// C++14</span></span><br><span class="line"><span class="keyword">auto</span> myobj = <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;MyClass&gt;(<span class="keyword">new</span> MyClass(constructor_param1, constructor_param2)); <span class="comment">// C++11</span></span><br><span class="line"><span class="keyword">auto</span> mybuffer = <span class="built_in">std</span>::make_unique&lt;<span class="keyword">char</span>[]&gt;(length); <span class="comment">// C++14</span></span><br><span class="line"><span class="keyword">auto</span> mybuffer = <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">char</span>[]&gt;(<span class="keyword">new</span> <span class="keyword">char</span>[length]); <span class="comment">// C++11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// or for reference counted objects</span></span><br><span class="line"><span class="keyword">auto</span> myobj = <span class="built_in">std</span>::make_shared&lt;MyClass&gt;(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// myobj is automatically freed for you whenever it is no longer used.</span></span><br></pre></td></tr></table></figure>
<h4 id="25-用std-array-或-std-vector-代替C风格的数组"><a href="#25-用std-array-或-std-vector-代替C风格的数组" class="headerlink" title="25.用std::array 或 std::vector 代替C风格的数组"></a>25.用std::array 或 std::vector 代替C风格的数组</h4><hr>
<p>这两个都使用内存连续分配的，可以完全代替C数组。如果想获得最原生C数组的性能，可以用std::array，它还可以结合STL的算法，非常方便。另外，避免使用std::shared_ptr来指向一个数组，用std::unique_ptr代替。</p>
<h4 id="26-使用C-风格的转换代替C风格的转换"><a href="#26-使用C-风格的转换代替C风格的转换" class="headerlink" title="26.使用C++风格的转换代替C风格的转换"></a>26.使用C++风格的转换代替C风格的转换</h4><hr>
<p>使用C++风格的转换(static_cast&lt;&gt; dynamic_cast&lt;&gt;)代替C风格的转换,C++风格的转换编译器会加入更多的检查，类型更加安全。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad Idea</span></span><br><span class="line"><span class="keyword">double</span> x = getX();</span><br><span class="line"><span class="keyword">int</span> i = (<span class="keyword">int</span>) x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Not a Bad Idea</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(x);</span><br></pre></td></tr></table></figure>
<h4 id="27-不要定义可变参函数"><a href="#27-不要定义可变参函数" class="headerlink" title="27.不要定义可变参函数"></a>27.不要定义可变参函数</h4><hr>
<p>类似printf,可变参的函数不是类型安全的，错误的输入可能导致异常终止，或者让程序产生未定义行为，未定义行为会导致软件的安全问题，如果你有支持C++ 11的编译器，请使用变参模版来代替。</p>
<p>附加内容： <a href="https://www.dwheeler.com/essays/heartbleed.html" target="_blank" rel="noopener">如何防止下一个类似HeartBleed的漏洞</a></p>
<h4 id="28-避免使用宏"><a href="#28-避免使用宏" class="headerlink" title="28.避免使用宏"></a>28.避免使用宏</h4><p>宏是预处理器(preprocessor)做的事，这个事件在编译器开始编译代码之前，这会让编译器少做了类型检查，因为宏本质是个文本替换，如果出现BUG，调试器很难找出问题源头所在。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad Idea</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14159;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Good Idea</span></span><br><span class="line"><span class="comment">// 类似于Java，Java全局常量也必须定义在类中</span></span><br><span class="line"><span class="keyword">namespace</span> my_project &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Constants</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 如果上面这段宏被展开了，那么实际会变成下面这行:</span></span><br><span class="line">    <span class="comment">//   static const double 3.14159 = 3.14159;</span></span><br><span class="line">    <span class="comment">//这会导致编译出错. 有些时候，这样的错误很难理解.</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">3.14159</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="29-函数参数尽量避免bool类型"><a href="#29-函数参数尽量避免bool类型" class="headerlink" title="29.函数参数尽量避免bool类型"></a>29.函数参数尽量避免bool类型</h4><hr>
<p>这对于阅读代码来说，不会增加更多有意义的信息，有了bool变量，就说明函数的输出依赖了这个条件，导致做了过多的事情，一个函数尽量保证只做一件事并做好一件事。如果遇到需要这样写的函数，就把bool的条件分离出一个单独的函数来处理,或者传入枚举类型，让参数更有意义。</p>
<p><a href="https://mortoray.com/2015/06/15/get-rid-of-those-boolean-function-parameters/" target="_blank" rel="noopener">这篇文章</a>讲述了更多的细节，以及如何解决。</p>
<h4 id="30-尽量避免裸循环"><a href="#30-尽量避免裸循环" class="headerlink" title="30.尽量避免裸循环"></a>30.尽量避免裸循环</h4><hr>
<p>使用C++ 新标准提供的更加高级的语义。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;DeviceCollect::st_port&gt; tcp_ports;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Very Bad Idea</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tcp_ports.size(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//do_something</span></span><br><span class="line">  tcp_ports[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// range for , foreach semantics</span></span><br><span class="line"><span class="comment">// Not a Bad Idea</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp; prot : tcp_ports)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//do_something</span></span><br><span class="line">    port;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Very Good Idea</span></span><br><span class="line">tcp_ports.erase(</span><br><span class="line">		<span class="built_in">std</span>::remove_if(<span class="built_in">std</span>::begin(tcp_ports), <span class="built_in">std</span>::end(tcp_ports),</span><br><span class="line">		[](<span class="keyword">const</span> DeviceCollect::st_port &amp; o) -&gt; <span class="keyword">bool</span> &#123; <span class="keyword">return</span> o.processPath.compare(<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"空"</span>)) == <span class="number">0</span>; &#125;),</span><br><span class="line">		<span class="built_in">std</span>::end(tcp_ports));</span><br></pre></td></tr></table></figure>
<h4 id="31-正确使用关键字override和final"><a href="#31-正确使用关键字override和final" class="headerlink" title="31.正确使用关键字override和final"></a>31.正确使用关键字override和final</h4><hr>
<p>这些关键字能帮助开发者更清晰的理解虚函数是怎样被使用的，如果虚函数的函数签名有变化，override关键字也能捕获一些潜在的错误，导致编译出错。也能<a href="http://stackoverflow.com/questions/7538820/how-does-the-compiler-benefit-from-cs-new-final-keyword" target="_blank" rel="noopener">提示编译器</a>如何更好的优化虚函数。</p>
<h4 id="32-了解使用的类型"><a href="#32-了解使用的类型" class="headerlink" title="32.了解使用的类型"></a>32.了解使用的类型</h4><hr>
<p>这个在条款15也提到过，这里会给出一个<a href="https://www.viva64.com/en/a/0010/" target="_blank" rel="noopener">更详细的参考</a>。</p>
<h4 id="33-避免全局数据"><a href="#33-避免全局数据" class="headerlink" title="33.避免全局数据"></a>33.避免全局数据</h4><hr>
<p>全局数据会导致函数间的无法意料的副作用，也会导致代码间难以并行化，或者不可能并行化。</p>
<h4 id="34-避免静态变量"><a href="#34-避免静态变量" class="headerlink" title="34.避免静态变量"></a>34.避免静态变量</h4><hr>
<p>除了全局数据，静态数据的构造和析构可能不总是能按照你预想的进行。如果你的程序是跨平台的，那么这个噩梦可能成真，请看这么个例子，一个<a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=66830" target="_blank" rel="noopener">g++的BUG</a>引出了共享静态数据析构顺序的一个问题。这个共享静态数据是从动态库中加载的。</p>
<h4 id="35-shared-ptr"><a href="#35-shared-ptr" class="headerlink" title="35.shared_ptr"></a>35.shared_ptr</h4><hr>
<p>该指针<a href="http://stackoverflow.com/questions/18709647/shared-pointer-to-an-immutable-type-has-value-semantics/" target="_blank" rel="noopener">几乎等同于全局变量</a>，因为它可以让不同的代码访问相同的数据。</p>
<h4 id="36-单例模式"><a href="#36-单例模式" class="headerlink" title="36.单例模式"></a>36.单例模式</h4><hr>
<p>单例模式一般都需要保证线程安全，因为单例一般实现是static变量和shared_ptr实现的。</p>
<h4 id="37-互斥量和可变量要一起使用"><a href="#37-互斥量和可变量要一起使用" class="headerlink" title="37.互斥量和可变量要一起使用"></a>37.互斥量和可变量要一起使用</h4><hr>
<ul>
<li>一个可变成员变量如果会被共享就需要被互斥量同步(mutex)，或者把可变量做成原子的（atomic）</li>
<li>如果一个成员变量本身是一个互斥量，它也是可变的，要使用它，必须在const 函数中使用</li>
</ul>
<p>更多详情，请看<a href="https://herbsutter.com/2013/05/24/gotw-6a-const-correctness-part-1-3/" target="_blank" rel="noopener">这里</a>。</p>
<h4 id="38-需要的时候就前置声明"><a href="#38-需要的时候就前置声明" class="headerlink" title="38.需要的时候就前置声明"></a>38.需要的时候就前置声明</h4><hr>
<p>用这段代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// some header file</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClassB</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">doSomething</span>(<span class="title">const</span> <span class="title">MyClass</span> &amp;);</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fuck</span><span class="params">(MyClassB *)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>代替以下代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// some header file</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MyClass.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MyClassB.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">const</span> MyClass &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fuck</span><span class="params">(MyClassB *)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>如果类是模版类，可以这么写：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">MyTemplatedType</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>这样在编译器重新构建依赖的时候，可以有效降低编译时间。</p>
<h4 id="39-避免不必要的模版实例化"><a href="#39-避免不必要的模版实例化" class="headerlink" title="39.避免不必要的模版实例化"></a>39.避免不必要的模版实例化</h4><hr>
<p>模版实例化不是没有代价的，过多的模版实例化，每种类型实例化为一份代码，那么会造成编译出的机器码膨胀，也会加大编译时间。</p>
<p>更多详情，请看<a href="http://articles.emptycrate.com/2015/04/27/template_code_bloat_revisited_a_smaller_makeshared.html" target="_blank" rel="noopener">这篇文章</a>。</p>
<h4 id="40-避免递归模版实例化"><a href="#40-避免递归模版实例化" class="headerlink" title="40.避免递归模版实例化"></a>40.避免递归模版实例化</h4><hr>
<p>递归会让模版实例化瞬间变多，加重编译器负担,造成更加难以理解的代码。</p>
<p>问题解决请看<a href="http://articles.emptycrate.com/2016/05/14/folds_in_cpp11_ish.html" target="_blank" rel="noopener">这篇文章</a>。</p>
<h4 id="41-不要包含无用的头文件"><a href="#41-不要包含无用的头文件" class="headerlink" title="41.不要包含无用的头文件"></a>41.不要包含无用的头文件</h4><hr>
<p>降低编译依赖，减少编译时间。</p>
<h4 id="42-使用初始化列表"><a href="#42-使用初始化列表" class="headerlink" title="42.使用初始化列表"></a>42.使用初始化列表</h4><hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;ModelObject&gt; mos&#123;mo1, mo2&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -or-</span></span><br><span class="line"><span class="keyword">auto</span> mos = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;ModelObject&gt;&#123;mo1, mo2&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Don't do this</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;ModelObject&gt; mos;</span><br><span class="line">mos.push_back(mo1);</span><br><span class="line">mos.push_back(mo2);</span><br></pre></td></tr></table></figure>
<p>初始化列表能带来更大性能的提升，减少对象的拷贝和容器的resize</p>
<h4 id="43-使用move语义"><a href="#43-使用move语义" class="headerlink" title="43.使用move语义"></a>43.使用move语义</h4><hr>
<p>move语义是C++ 11的最大革新了。</p>
<p>相关文章:</p>
<ul>
<li><a href="https://www.zhihu.com/question/50652989" target="_blank" rel="noopener">关于C++右值及std::move()的疑问</a></li>
<li><a href="https://www.zhihu.com/question/55735384" target="_blank" rel="noopener">C++ 中的「移动」在内存或者寄存器中的操作是什么，为什么就比拷贝赋值性能高呢</a></li>
<li><a href="https://www.zhihu.com/question/43513150" target="_blank" rel="noopener">如何理解C++中的move语义</a></li>
</ul>
<p>对于大多数代码，只要这样就可以了:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ModelObject(ModelObject &amp;&amp;) = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure></p>
<p>但是MSVC2013不支持，MSVC2015支持。</p>
<h4 id="44-减少shared-ptr的拷贝"><a href="#44-减少shared-ptr的拷贝" class="headerlink" title="44.减少shared_ptr的拷贝"></a>44.减少shared_ptr的拷贝</h4><hr>
<p>该智能指针允许共享，类似实现Java中的引用计数来保证无资源泄漏，但是拷贝的代价很高，yi你用计数必须是原子的和线程安全的。</p>
<h4 id="45-尽可能降低拷贝或重新赋值"><a href="#45-尽可能降低拷贝或重新赋值" class="headerlink" title="45.尽可能降低拷贝或重新赋值"></a>45.尽可能降低拷贝或重新赋值</h4><hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad Idea</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> somevalue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (caseA) &#123;</span><br><span class="line">  somevalue = <span class="string">"Value A"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  somevalue = <span class="string">"Value B"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Better Idea</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> somevalue = caseA ? <span class="string">"Value A"</span> : <span class="string">"Value B"</span>;</span><br></pre></td></tr></table></figure>
<p>更加复杂的场景可以这样：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad Idea</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> somevalue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (caseA) &#123;</span><br><span class="line">  somevalue = <span class="string">"Value A"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(caseB) &#123;</span><br><span class="line">  somevalue = <span class="string">"Value B"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  somevalue = <span class="string">"Value C"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Better Idea</span></span><br><span class="line"><span class="comment">// 这类似与javascript中的匿名函数立即调用</span></span><br><span class="line"><span class="comment">// (function ()&#123; return "hello" &#125;)()</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> somevalue = [&amp;]()&#123;</span><br><span class="line">    <span class="keyword">if</span> (caseA) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Value A"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (caseB) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Value B"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Value C"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;();</span><br></pre></td></tr></table></figure></p>
<p>IIFE in C++ 11 请看<a href="http://articles.emptycrate.com/2014/12/16/complex_object_initialization_optimization_with_iife_in_c11.html" target="_blank" rel="noopener">这里</a>。</p>
<h4 id="46-不要大量使用异常"><a href="#46-不要大量使用异常" class="headerlink" title="46.不要大量使用异常"></a>46.不要大量使用异常</h4><hr>
<p>这个《Google C++ Coding Style》上有说，这里就不多做解释了。</p>
<h4 id="47-避免使用new"><a href="#47-避免使用new" class="headerlink" title="47.避免使用new"></a>47.避免使用new</h4><hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;ModelObject_Impl&gt;(<span class="keyword">new</span> ModelObject_Impl());</span><br><span class="line"></span><br><span class="line"><span class="comment">// should become</span></span><br><span class="line"><span class="built_in">std</span>::make_shared&lt;ModelObject_Impl&gt;(); <span class="comment">// (it's also more readable and concise)</span></span><br></pre></td></tr></table></figure>
<h4 id="48-优先使用unique-ptr"><a href="#48-优先使用unique-ptr" class="headerlink" title="48. 优先使用unique_ptr"></a>48. 优先使用unique_ptr</h4><hr>
<p>如果能用unique_ptr解决的场景，就不要用shared_ptr。</p>
<p>当前的最佳实践就是，从一个工厂函数中返回一个unique_ptr，如果有需要，再从unique转成shared。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ModelObject_Impl&gt; factory();</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> shared = <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;ModelObject_Impl&gt;(factory());</span><br></pre></td></tr></table></figure>
<h4 id="49-限制变量作用范围"><a href="#49-限制变量作用范围" class="headerlink" title="49.限制变量作用范围"></a>49.限制变量作用范围</h4><hr>
<p>变量应该尽可能的推迟声明，什么时候需要用到再声明，不能像C89那样，全部放在函数开头。这样也影响阅读性。降低变量作用范围同时降低内存的使用,帮助编译器生成更高效的代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Good Idea</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">MyObject <span class="title">obj</span><span class="params">(i)</span></span>;</span><br><span class="line">  <span class="comment">// do something with obj</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bad Idea</span></span><br><span class="line">MyObject obj; <span class="comment">// 无意义的对象初始化</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">  obj = MyObject(i); <span class="comment">// 无必要的赋值操作</span></span><br><span class="line">  <span class="comment">// do something with obj</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// obj还继续占用内存，直到离开它自身的作用范围</span></span><br></pre></td></tr></table></figure>
<h4 id="50-优先使用double，而不是float"><a href="#50-优先使用double，而不是float" class="headerlink" title="50.优先使用double，而不是float"></a>50.优先使用double，而不是float</h4><hr>
<p>当然了，这也得看场景和编译器的优化水平了，double可能比float更高效。<br>使用float，因为精度更低,所以在转换中可能更低效。当然，如果在向量化操作中，如果你牺牲精度而换取高性能，float可能会更加高效。</p>
<p>double是C++浮点数的默认类型<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> a = <span class="number">3.14f</span>; <span class="comment">// 3.14f默认double，会有一层隐式向低精度转换</span></span><br><span class="line"><span class="keyword">double</span> b = <span class="number">3.14f</span>;  <span class="comment">// 由于默认是double 无需转换</span></span><br></pre></td></tr></table></figure></p>
<h4 id="51-优先使用-i而不是i-（可以废弃）"><a href="#51-优先使用-i而不是i-（可以废弃）" class="headerlink" title="51.优先使用++i而不是i++ （可以废弃）"></a>51.优先使用++i而不是i++ （可以废弃）</h4><hr>
<p>当然，现代编译器优化水平相当高了，在for循环中，两者优化出来的机器码都是一样的，但是你无法保证在个别的编译器平台上能这样。</p>
<h4 id="52-char是char，string是string"><a href="#52-char是char，string是string" class="headerlink" title="52. char是char，string是string"></a>52. char是char，string是string</h4><hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad Idea</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; someThing() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good Idea</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; someThing() &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure>
<p>前者会被编译器解析成const char*， 当写入流的时候，会检查末尾’\0’结束符。后者被解释成单个字符，省去了CPU很多操作。</p>
<p>如果在特别场景下大量使用前者，可能前者会慢慢变成性能瓶颈。</p>
<h4 id="53-不要使用std-bind"><a href="#53-不要使用std-bind" class="headerlink" title="53.不要使用std::bind"></a>53.不要使用std::bind</h4><hr>
<p>std::bind 在lambda表达式出现之前可以用，但是之后就没有多大用了。大多数情况下，可以用lambda表达式代替。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad Idea</span></span><br><span class="line"><span class="keyword">auto</span> f = <span class="built_in">std</span>::bind(&amp;my_function, <span class="string">"hello"</span>, <span class="built_in">std</span>::placeholders::_1);</span><br><span class="line">f(<span class="string">"world"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good Idea</span></span><br><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s) &#123; <span class="keyword">return</span> my_function(<span class="string">"hello"</span>, s); &#125;;</span><br><span class="line">f(<span class="string">"world"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="54-善用脚本，拥抱其他语言和框架"><a href="#54-善用脚本，拥抱其他语言和框架" class="headerlink" title="54.善用脚本，拥抱其他语言和框架"></a>54.善用脚本，拥抱其他语言和框架</h4><hr>
<p>静态类型语言与动态类型语言结合才更强劲，参考使用boost::python。<br>该用什么语言完成的工作就用那种语言完成。写Web就用Java拉，前端就javascript啦，不要折腾没用的。</p>
<p><strong>当你每次鄙视一种语言的时候，就失去了一次向它学习的机会。</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://alexiachen.github.io/blog/2017/02/22/cpp-best-practices/" data-id="cjtctj256009dlbqfko9ccf8r" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/C-C/">C/C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/软件工程/">软件工程</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/blog/page/4/">&laquo; Prev</a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/3/">3</a><a class="page-number" href="/blog/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/blog/page/6/">6</a><a class="page-number" href="/blog/page/7/">7</a><a class="page-number" href="/blog/page/8/">8</a><a class="extend next" rel="next" href="/blog/page/6/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/blog/tags/Bloom-Filter/" style="font-size: 10px;">Bloom Filter</a> <a href="/blog/tags/C-C/" style="font-size: 20px;">C/C++</a> <a href="/blog/tags/CERT/" style="font-size: 18.33px;">CERT</a> <a href="/blog/tags/CMake/" style="font-size: 10px;">CMake</a> <a href="/blog/tags/DLL/" style="font-size: 10px;">DLL</a> <a href="/blog/tags/DNS/" style="font-size: 10px;">DNS</a> <a href="/blog/tags/IM/" style="font-size: 13.33px;">IM</a> <a href="/blog/tags/IO/" style="font-size: 10px;">IO</a> <a href="/blog/tags/Java/" style="font-size: 10px;">Java</a> <a href="/blog/tags/Linux/" style="font-size: 13.33px;">Linux</a> <a href="/blog/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/blog/tags/Oracle/" style="font-size: 10px;">Oracle</a> <a href="/blog/tags/Qos/" style="font-size: 11.67px;">Qos</a> <a href="/blog/tags/RFB协议/" style="font-size: 10px;">RFB协议</a> <a href="/blog/tags/SQLite/" style="font-size: 10px;">SQLite</a> <a href="/blog/tags/Scala/" style="font-size: 10px;">Scala</a> <a href="/blog/tags/TCP-IP/" style="font-size: 10px;">TCP/IP</a> <a href="/blog/tags/VNC协议/" style="font-size: 10px;">VNC协议</a> <a href="/blog/tags/Visual-Studio/" style="font-size: 10px;">Visual Studio</a> <a href="/blog/tags/Win32/" style="font-size: 13.33px;">Win32</a> <a href="/blog/tags/Y组合子/" style="font-size: 10px;">Y组合子</a> <a href="/blog/tags/bat/" style="font-size: 10px;">bat</a> <a href="/blog/tags/ioccc/" style="font-size: 10px;">ioccc</a> <a href="/blog/tags/lambda演算/" style="font-size: 10px;">lambda演算</a> <a href="/blog/tags/windows/" style="font-size: 11.67px;">windows</a> <a href="/blog/tags/上下文无关文法/" style="font-size: 10px;">上下文无关文法</a> <a href="/blog/tags/事业/" style="font-size: 10px;">事业</a> <a href="/blog/tags/互联网/" style="font-size: 10px;">互联网</a> <a href="/blog/tags/人生/" style="font-size: 10px;">人生</a> <a href="/blog/tags/传统行业/" style="font-size: 10px;">传统行业</a> <a href="/blog/tags/信息安全/" style="font-size: 10px;">信息安全</a> <a href="/blog/tags/内存模型/" style="font-size: 10px;">内存模型</a> <a href="/blog/tags/函数式编程/" style="font-size: 11.67px;">函数式编程</a> <a href="/blog/tags/单例模式/" style="font-size: 10px;">单例模式</a> <a href="/blog/tags/双向链表/" style="font-size: 10px;">双向链表</a> <a href="/blog/tags/可计算性/" style="font-size: 10px;">可计算性</a> <a href="/blog/tags/同步异步/" style="font-size: 10px;">同步异步</a> <a href="/blog/tags/团队管理/" style="font-size: 11.67px;">团队管理</a> <a href="/blog/tags/多核编程/" style="font-size: 10px;">多核编程</a> <a href="/blog/tags/多线程编程/" style="font-size: 10px;">多线程编程</a> <a href="/blog/tags/天体物理/" style="font-size: 10px;">天体物理</a> <a href="/blog/tags/套路/" style="font-size: 10px;">套路</a> <a href="/blog/tags/学术/" style="font-size: 10px;">学术</a> <a href="/blog/tags/宇宙学/" style="font-size: 10px;">宇宙学</a> <a href="/blog/tags/性能优化/" style="font-size: 10px;">性能优化</a> <a href="/blog/tags/技术/" style="font-size: 10px;">技术</a> <a href="/blog/tags/指令重排序/" style="font-size: 10px;">指令重排序</a> <a href="/blog/tags/操作系统/" style="font-size: 10px;">操作系统</a> <a href="/blog/tags/敏捷开发/" style="font-size: 10px;">敏捷开发</a> <a href="/blog/tags/数据压缩/" style="font-size: 10px;">数据压缩</a> <a href="/blog/tags/数据库/" style="font-size: 10px;">数据库</a> <a href="/blog/tags/数据恢复/" style="font-size: 10px;">数据恢复</a> <a href="/blog/tags/数据结构与算法/" style="font-size: 11.67px;">数据结构与算法</a> <a href="/blog/tags/旅行/" style="font-size: 10px;">旅行</a> <a href="/blog/tags/无线网卡/" style="font-size: 10px;">无线网卡</a> <a href="/blog/tags/有限自动机/" style="font-size: 10px;">有限自动机</a> <a href="/blog/tags/构建工具/" style="font-size: 10px;">构建工具</a> <a href="/blog/tags/模板元编程/" style="font-size: 10px;">模板元编程</a> <a href="/blog/tags/民主/" style="font-size: 11.67px;">民主</a> <a href="/blog/tags/汇编语言/" style="font-size: 10px;">汇编语言</a> <a href="/blog/tags/消息推送/" style="font-size: 10px;">消息推送</a> <a href="/blog/tags/混乱代码/" style="font-size: 10px;">混乱代码</a> <a href="/blog/tags/物联网/" style="font-size: 10px;">物联网</a> <a href="/blog/tags/猎人/" style="font-size: 10px;">猎人</a> <a href="/blog/tags/理想/" style="font-size: 10px;">理想</a> <a href="/blog/tags/理论计算机/" style="font-size: 10px;">理论计算机</a> <a href="/blog/tags/生活/" style="font-size: 13.33px;">生活</a> <a href="/blog/tags/研究/" style="font-size: 10px;">研究</a> <a href="/blog/tags/程序语言理论/" style="font-size: 15px;">程序语言理论</a> <a href="/blog/tags/类型系统/" style="font-size: 10px;">类型系统</a> <a href="/blog/tags/线程/" style="font-size: 10px;">线程</a> <a href="/blog/tags/线程安全/" style="font-size: 10px;">线程安全</a> <a href="/blog/tags/缓存/" style="font-size: 10px;">缓存</a> <a href="/blog/tags/编程范式/" style="font-size: 10px;">编程范式</a> <a href="/blog/tags/编程语言/" style="font-size: 10px;">编程语言</a> <a href="/blog/tags/编译原理/" style="font-size: 11.67px;">编译原理</a> <a href="/blog/tags/美国/" style="font-size: 10px;">美国</a> <a href="/blog/tags/职业生涯/" style="font-size: 10px;">职业生涯</a> <a href="/blog/tags/自然语言处理/" style="font-size: 10px;">自然语言处理</a> <a href="/blog/tags/自由/" style="font-size: 11.67px;">自由</a> <a href="/blog/tags/英语/" style="font-size: 10px;">英语</a> <a href="/blog/tags/装修/" style="font-size: 10px;">装修</a> <a href="/blog/tags/计算机体系结构/" style="font-size: 10px;">计算机体系结构</a> <a href="/blog/tags/计算机科学/" style="font-size: 10px;">计算机科学</a> <a href="/blog/tags/计算机网络/" style="font-size: 11.67px;">计算机网络</a> <a href="/blog/tags/计算理论/" style="font-size: 11.67px;">计算理论</a> <a href="/blog/tags/词法分析/" style="font-size: 10px;">词法分析</a> <a href="/blog/tags/诗歌/" style="font-size: 10px;">诗歌</a> <a href="/blog/tags/语义学/" style="font-size: 10px;">语义学</a> <a href="/blog/tags/调试/" style="font-size: 11.67px;">调试</a> <a href="/blog/tags/软件工程/" style="font-size: 16.67px;">软件工程</a> <a href="/blog/tags/软件开发/" style="font-size: 10px;">软件开发</a> <a href="/blog/tags/软件调试/" style="font-size: 10px;">软件调试</a> <a href="/blog/tags/远程桌面/" style="font-size: 10px;">远程桌面</a> <a href="/blog/tags/逻辑/" style="font-size: 11.67px;">逻辑</a> <a href="/blog/tags/重构/" style="font-size: 10px;">重构</a> <a href="/blog/tags/错误处理/" style="font-size: 10px;">错误处理</a> <a href="/blog/tags/闭包/" style="font-size: 10px;">闭包</a> <a href="/blog/tags/阻塞非阻塞/" style="font-size: 10px;">阻塞非阻塞</a> <a href="/blog/tags/项目管理/" style="font-size: 11.67px;">项目管理</a> <a href="/blog/tags/马尔科夫链/" style="font-size: 10px;">马尔科夫链</a> <a href="/blog/tags/驱动开发/" style="font-size: 10px;">驱动开发</a> <a href="/blog/tags/黑洞/" style="font-size: 10px;">黑洞</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/02/">February 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/01/">January 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2015/11/">November 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2014/11/">November 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2014/09/">September 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2014/08/">August 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2014/07/">July 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2014/06/">June 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2014/05/">May 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2014/03/">March 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2014/02/">February 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2013/07/">July 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2013/06/">June 2013</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2019/03/17/bloom-filter/">实现一个简单的高性能布隆过滤器</a>
          </li>
        
          <li>
            <a href="/blog/2019/03/10/auto-complete-markov-chain/">用马尔科夫链来做自动补全</a>
          </li>
        
          <li>
            <a href="/blog/2018/12/15/manjaro-rtl8821ce/">manjaro下安装配置无线网卡驱动</a>
          </li>
        
          <li>
            <a href="/blog/2018/11/11/cpp-closure/">C++的闭包</a>
          </li>
        
          <li>
            <a href="/blog/2018/10/15/finite-automaton/">最简单的计算机之有限自动机</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 MathxH Chen<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/blog/" class="mobile-nav-link">Home</a>
  
    <a href="/blog/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/blog/about" class="mobile-nav-link">About</a>
  
    <a href="/blog/resume" class="mobile-nav-link">Resume</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">
  <script src="/blog/fancybox/jquery.fancybox.pack.js"></script>


<script src="/blog/js/script.js"></script>



  </div>
</body>
</html>