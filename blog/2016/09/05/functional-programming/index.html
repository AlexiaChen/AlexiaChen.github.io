<html>
<head>
	
	<title>谈谈函数式编程</title>
	<meta name="keywords" content="" />

    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    
    <!--<link rel="stylesheet" href="/blog/css/main.css">-->
	<link href="/blog/css/main.css?v=2" rel="stylesheet" type="text/css" />
    <!--<link rel="stylesheet" href="/blog/css/style.css">-->
    

    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">

    
	<link rel="shortcut icon" type="image/x-icon" href="/blog/favicon.ico?v=2"/>
    

</head>

<body>

<h2 class="title">谈谈函数式编程</h2>
<h1 id="什么是函数式编程"><a href="#什么是函数式编程" class="headerlink" title="什么是函数式编程"></a>什么是函数式编程</h1><hr>
<p>其实有关于函数式编程我有在之前的博文<a href="http://mathxh-love.org/blog/2016/05/19/programming-language/" target="_blank" rel="external">《编程语言为何如此众多》</a>提到过，有兴趣的可以去看看 :)</p>
<p>那么到底什么是函数式呢？听上去好厉害，好高大上的样子。</p>
<p>大家都知道面向对象编程提到的几个特性：封装，继承，多态，一切皆对象。那么其实函数式编程也有它固有的几个特点：不可变量，惰性求值，高阶函数，无副作用，一切皆函数。</p>
<h2 id="从停机问题开始"><a href="#从停机问题开始" class="headerlink" title="从停机问题开始"></a>从停机问题开始</h2><p>调程序的时候经常会遇到死循环的Bug，聪明的你有没有想过发明一个自动检查程序里面有没有死循环的工具呢？不管你有没有过这种想法，反正我有过，可惜答案是，没有！</p>
<p>停机问题在<a href="https://en.wikipedia.org/wiki/Halting_problem" target="_blank" rel="external">wiki</a>上的描述比较学术，又是什么图灵机，又是数学中的集合。因为涉及到<a href="https://en.wikipedia.org/wiki/Theory_of_computation" target="_blank" rel="external">计算理论</a>的东西，为了防止小白看不懂，下面用一个小白话来讲，</p>
<p>停机问题：<strong><font color="red">给定任意一个程序及其输入，判断该程序是否能够在有限次计算以内结束。</font></strong></p>
<h2 id="假设存在停机算法"><a href="#假设存在停机算法" class="headerlink" title="假设存在停机算法"></a>假设存在停机算法</h2><p>如果存在停机算法，那么对于给定任意一个函数以及这个函数的输入,停机算法就能告诉你这个函数会不会结束。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isHalting</span>(<span class="params">func,input</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> if_func_will_halt_on_input;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="利用停机判定"><a href="#利用停机判定" class="headerlink" title="利用停机判定"></a>利用停机判定</h2><p>设一个函数，并调用它自身:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">func</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(isHalting(func,func))&#123;</div><div class="line">        <span class="keyword">while</span>(<span class="literal">true</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 判定自身</span></div><div class="line">foo(foo);</div></pre></td></tr></table></figure></p>
<p>这是一个悖论：<strong><font color="red">当函数foo以foo为输入时，到底停机还是不停机？ </font></strong></p>
<h2 id="lambda演算语法"><a href="#lambda演算语法" class="headerlink" title="lambda演算语法"></a>lambda演算语法</h2><p>停机问题只是个引子，接下来让我们步入正题。</p>
<p>用形式化的表述，<a href="https://en.wikipedia.org/wiki/Lambda_calculus" target="_blank" rel="external">λ演算</a>的语法只有三条：</p>
<ul>
<li>&lt;表达式&gt; ::= &lt;标识符&gt;</li>
<li>&lt;表达式&gt; ::= λ &lt;标识符+&gt; . &lt;表达式&gt;</li>
<li>&lt;表达式&gt; ::= (&lt;表达式&gt; &lt;表达式&gt;)</li>
</ul>
<p>例如，根据以上语法，可以写一个加法函数。注意，这个函数是<strong>匿名</strong>的:<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">λ x y. x + y</div></pre></td></tr></table></figure></p>
<p>之前定义的3条语法，前二条是用于产生函数，第三条用于函数调用。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">; 输出5 </div><div class="line">((λx y. x + y) 2 3) </div><div class="line"></div><div class="line">;为了方便，把匿名函数绑定到一个变量</div><div class="line">let add = λ x y. x + y</div><div class="line">;输出5</div><div class="line">(add 2 3)</div></pre></td></tr></table></figure>
<p>看到这里，其实知道Lisp语言的同学可能就有种似曾相识的感觉了。Lisp语言就是一种函数式编程语言，函数式编程语言就是基于lambda演算发展起来的。细心的人已经发觉，lambda演算与图灵机模型对比，它其实更加侧重于计算的描述，甚至表达式不需要关心函数名，它仅仅是个描述计算过程的计算体。所谓的lambda表达式就是这种计算体的一种叫法，只是在各种编程语言环境下，lambda表达式换了个语法而已。</p>
<h2 id="lambda演算公理"><a href="#lambda演算公理" class="headerlink" title="lambda演算公理"></a>lambda演算公理</h2><p>以下是lambda演算的公理系统:</p>
<p>置换公理</p>
<ul>
<li>λ x y. x + y =&gt; λ a b. a + b</li>
</ul>
<p>代入公理</p>
<ul>
<li>(λx y. x + y) a b =&gt; a + b </li>
</ul>
<h2 id="函数生成器"><a href="#函数生成器" class="headerlink" title="函数生成器"></a>函数生成器</h2><p>lambda演算相当于一个函数生成器:<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let mul = λx y. x*y</div><div class="line">let con = λx y. xy</div><div class="line"></div><div class="line">; 代入</div><div class="line"></div><div class="line">mul 3 5  -­‐&gt; 3 * 5 </div><div class="line">con 'fu' 'ck' --&gt;  'fuck'</div></pre></td></tr></table></figure></p>
<h2 id="定义IF函数"><a href="#定义IF函数" class="headerlink" title="定义IF函数"></a>定义IF函数</h2><p>大家都知道在函数式编程里，一切皆函数，就连什么平时接触到的for，if等语句都不例外。那么在函数式编程里面如何构造一个IF函数呢？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">;第一个参数condition为if函数的判断条件，如为真，则执行true_value,反之，false_value</div><div class="line"></div><div class="line">let if = λ condition true_value false_value .</div><div class="line">         (condition and true_value) or (not condition and false_value)</div><div class="line"></div><div class="line"></div><div class="line">;调用if,输出15</div><div class="line"></div><div class="line">if true (mul 3 5) (add 2 3)</div><div class="line"></div><div class="line">=&gt; (true and (mul 3 5)) or (not true and (add 2 3))</div><div class="line">=&gt; (mul 3 5) or false </div><div class="line">=&gt; (mul 3 5)</div><div class="line">=&gt; 15</div><div class="line"></div><div class="line">;调用if,输出5</div><div class="line"></div><div class="line">if false (mul 3 5) (add 2 3)</div><div class="line"></div><div class="line">=&gt; (false and (mul 3 5)) or (not false and (add 2 3))</div><div class="line">=&gt; false or (add 2 3) </div><div class="line">=&gt; (add 2 3)</div><div class="line">=&gt; 5</div></pre></td></tr></table></figure>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><hr>
<p>来个有意思点的计算，定义一个计算n的阶乘的函数:<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let fact = λ n .</div><div class="line">          if (n == 0) 1 </div><div class="line">                     (mul (n </div><div class="line">                          (fact n - 1)))</div></pre></td></tr></table></figure></p>
<p>问题出现了，我们在定义fact的时候引用的自身（废话，递归不调用自身还叫递归？）。虽然在实际的编译器处理过程中，编译器都可以识别这种定义，但是这不符合严谨的数学公理体系。</p>
<h2 id="如何表达递归"><a href="#如何表达递归" class="headerlink" title="如何表达递归"></a>如何表达递归</h2><p>之前的fact函数不是无法引用自身吗？那么我们把“自身”参数化，那么函数内部就可以引用了。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let P = λ self n .</div><div class="line">        if ( n == 0) 1 (mul </div><div class="line">                        (n</div><div class="line">                         (self n - 1))</div></pre></td></tr></table></figure></p>
<p>然后，再令:<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">let fact n = P (<span class="name">P</span> n)</div><div class="line"></div><div class="line"><span class="comment">; 然后调用,输出24</span></div><div class="line">fact <span class="number">4</span></div><div class="line">-&gt; P (<span class="name">P</span> <span class="number">4</span>)</div><div class="line">-&gt; if (<span class="number">4</span> == <span class="number">0</span>) <span class="number">1</span> (<span class="name">mul</span> <span class="number">4</span> (<span class="name">P</span> (<span class="name">P</span> n-1)))</div><div class="line">-&gt; (<span class="name">mul</span> <span class="number">4</span> (<span class="name">P</span> (<span class="name">P</span> <span class="number">3</span>)))</div><div class="line">-&gt; <span class="number">4</span> * P (<span class="name">P</span> <span class="number">3</span>)</div><div class="line">-&gt; <span class="number">4</span> * <span class="number">3</span> * P (<span class="name">P</span> <span class="number">2</span>)</div><div class="line">-&gt; <span class="number">4</span> * <span class="number">3</span> * <span class="number">2</span> * P (<span class="name">P</span> <span class="number">1</span>)</div><div class="line">-&gt; <span class="number">4</span> * <span class="number">3</span> * <span class="number">2</span> * <span class="number">1</span></div><div class="line">-&gt; <span class="number">24</span></div></pre></td></tr></table></figure></p>
<p>可惜，以上还不是真正的递归,只是每次额外多传入了一个参数，反复调用而已。我们的目的是要一个真正的递归函数,但是lambda演算没有这样一个公理可以在定义函数的时候引用自身，怎么办？</p>
<h2 id="Y组合子与不动点"><a href="#Y组合子与不动点" class="headerlink" title="Y组合子与不动点"></a>Y组合子与不动点</h2><p>不管之前的说法，我们就认定真正的fact是存在的:<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">;之前的函数P，为了方便，乘法表示就不用自定义的函数mul了</div><div class="line">let P = λ self n .</div><div class="line">        if ( n == 0) 1 ( n * self (n - 1))</div><div class="line">                         </div><div class="line">; 函数P接收2个参数，但是我们可以让函数柯里化(Currying),有时候又称部分求值(Partial Evaluation)</div><div class="line">; P接收一个fact，本质上又产生了一个新的单参函数</div><div class="line"></div><div class="line">P (fact) -&gt; λ n .</div><div class="line">        if ( n == 0) 1 ( n * fact (n - 1))</div></pre></td></tr></table></figure></p>
<blockquote>
<p><em>注: <a href="https://en.wikipedia.org/wiki/Currying" target="_blank" rel="external">函数柯里化</a>本质的意义是把一个多参的函数转换成单参函数作为返回值的形式,这样方便优化，有兴趣可以看知乎的讨论，<a href="https://www.zhihu.com/question/20037482" target="_blank" rel="external">柯里化对函数式编程有何意义？</a>, <a href="https://www.zhihu.com/question/30097211" target="_blank" rel="external">如何理解functional programming里的currying与partial application?</a></em></p>
</blockquote>
<p>然后，神奇的事发生了,细心的人发现，函数 P (fact) 与之前定义的函数fact相等，</p>
<ul>
<li>P (fact) = fact</li>
</ul>
<p>我们发现了函数P的一个<a href="https://en.wikipedia.org/wiki/Fixed-point_combinator" target="_blank" rel="external">不动点</a>,什么是不动点呢？就是一个点（广义上的）在一个函数的映射下,函数的值仍然为这个点: f(x) = x 。所以，思路就是找到不动点，如果找到了不动点，就可以把“伪递归”函数P转化为真正的递归函数了。</p>
<p>所以，我们假设需要一个函数Y，</p>
<p>（ To be continue, 时间不够）</p>


<!--<a href="https://alexiachen.github.io/blog/blog/2016/09/05/functional-programming/#disqus_thread" class="article-comment-link">Comments</a>-->
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'undefined'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

<div style="display:none">
<script src="http://s4.cnzz.com/stat.php?id=undefined&web_id=undefined" language="JavaScript"></script>script>
</div>







</body>
</html>