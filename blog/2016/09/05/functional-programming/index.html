<html>
<head><meta name="generator" content="Hexo 3.8.0">
	
	<title>谈谈函数式编程</title>
	<meta name="keywords" content="fzb.me,冯宗宝,冯宗宝的blog">

    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    
	   <link href="/blog/css/main.css?v=3" rel="stylesheet" type="text/css">
    
        <script src="/blog/js/util.js"></script>
        <script>
            if(isMobile()) {
                loadjscssfile('../css/mobile.css', 'css');
            } else {
                loadjscssfile('../css/desktop.css', 'css');
            }
        </script> 
    

    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">

    
	<link rel="shortcut icon" type="image/x-icon" href="/blog/favicon.ico?v=3">
    
    

</head>

<body>


<h2 class="title">谈谈函数式编程</h2>
<!---
<div style="text-align:center;margin-top: -10px;">
<div class="article-category">
发表于2016年9月5日




 </div>
--->


<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#什么是函数式编程"><span class="toc-text">什么是函数式编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#从停机问题开始"><span class="toc-text">从停机问题开始</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#假设存在停机算法"><span class="toc-text">假设存在停机算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用停机判定"><span class="toc-text">利用停机判定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lambda演算语法"><span class="toc-text">lambda演算语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lambda演算公理"><span class="toc-text">lambda演算公理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数生成器"><span class="toc-text">函数生成器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#定义IF函数"><span class="toc-text">定义IF函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#递归"><span class="toc-text">递归</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#如何表达递归"><span class="toc-text">如何表达递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Y组合子与不动点"><span class="toc-text">Y组合子与不动点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构造Y组合子"><span class="toc-text">构造Y组合子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#验证一下"><span class="toc-text">验证一下</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#图灵等价"><span class="toc-text">图灵等价</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#停机问题的等价问题"><span class="toc-text">停机问题的等价问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#现实世界中的函数式编程"><span class="toc-text">现实世界中的函数式编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Haskell"><span class="toc-text">Haskell</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#第一个Haskell程序"><span class="toc-text">第一个Haskell程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#列表"><span class="toc-text">列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模式匹配"><span class="toc-text">模式匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#列表求和"><span class="toc-text">列表求和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#判断回文"><span class="toc-text">判断回文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#删除连续重复元素"><span class="toc-text">删除连续重复元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#惰性求值"><span class="toc-text">惰性求值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#斐波那契数列"><span class="toc-text">斐波那契数列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#斐波那契数列的线性算法"><span class="toc-text">斐波那契数列的线性算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#快速排序"><span class="toc-text">快速排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉树并表示"><span class="toc-text">二叉树并表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#高阶函数"><span class="toc-text">高阶函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#闭包"><span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用闭包实现柯里化"><span class="toc-text">用闭包实现柯里化</span></a></li></ol></li></ol></li></ol>
<h1 id="什么是函数式编程"><a href="#什么是函数式编程" class="headerlink" title="什么是函数式编程"></a>什么是函数式编程</h1><hr>
<p>其实有关于函数式编程我有在之前的博文<a href="http://mathxh-love.org/blog/2016/05/19/programming-language/" target="_blank" rel="noopener">《编程语言为何如此众多》</a>提到过，有兴趣的可以去看看 :)</p>
<p>那么到底什么是函数式呢？听上去好厉害，好高大上的样子。</p>
<p>大家都知道面向对象编程提到的几个特性：封装，继承，多态，一切皆对象。那么其实函数式编程也有它固有的几个特点：不可变量，惰性求值，高阶函数，无副作用，一切皆函数。</p>
<h2 id="从停机问题开始"><a href="#从停机问题开始" class="headerlink" title="从停机问题开始"></a>从停机问题开始</h2><p>调程序的时候经常会遇到死循环的Bug，聪明的你有没有想过发明一个自动检查程序里面有没有死循环的工具呢？不管你有没有过这种想法，反正我有过，可惜答案是，没有！</p>
<p>停机问题在<a href="https://en.wikipedia.org/wiki/Halting_problem" target="_blank" rel="noopener">wiki</a>上的描述比较学术，又是什么图灵机，又是数学中的集合。因为涉及到<a href="https://en.wikipedia.org/wiki/Theory_of_computation" target="_blank" rel="noopener">计算理论</a>的东西，为了防止小白看不懂，下面用一个小白话来讲，</p>
<p>停机问题：<strong><font color="red">给定任意一个程序及其输入，判断该程序是否能够在有限次计算以内结束。</font></strong></p>
<h2 id="假设存在停机算法"><a href="#假设存在停机算法" class="headerlink" title="假设存在停机算法"></a>假设存在停机算法</h2><p>如果存在停机算法，那么对于给定任意一个函数以及这个函数的输入,停机算法就能告诉你这个函数会不会结束。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isHalting</span>(<span class="params">func,input</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> if_func_will_halt_on_input;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="利用停机判定"><a href="#利用停机判定" class="headerlink" title="利用停机判定"></a>利用停机判定</h2><p>设一个函数，并调用它自身:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">func</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isHalting(func,func))&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判定自身</span></span><br><span class="line">foo(foo);</span><br></pre></td></tr></table></figure></p>
<p>这是一个悖论：<strong><font color="red">当函数foo以foo为输入时，到底停机还是不停机？ </font></strong></p>
<h2 id="lambda演算语法"><a href="#lambda演算语法" class="headerlink" title="lambda演算语法"></a>lambda演算语法</h2><p>停机问题只是个引子，接下来让我们步入正题。</p>
<p>用形式化的表述，<a href="https://en.wikipedia.org/wiki/Lambda_calculus" target="_blank" rel="noopener">λ演算</a>的语法只有三条：</p>
<ul>
<li>&lt;表达式&gt; ::= &lt;标识符&gt;</li>
<li>&lt;表达式&gt; ::= λ &lt;标识符+&gt; . &lt;表达式&gt;</li>
<li>&lt;表达式&gt; ::= (&lt;表达式&gt; &lt;表达式&gt;)</li>
</ul>
<p>例如，根据以上语法，可以写一个加法函数。注意，这个函数是<strong>匿名</strong>的:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">λ x y. x + y</span><br></pre></td></tr></table></figure></p>
<p>之前定义的3条语法，前二条是用于产生函数，第三条用于函数调用。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 输出5 </span></span><br><span class="line">((λx y. x + y) <span class="number">2</span> <span class="number">3</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">;为了方便，把匿名函数绑定到一个变量</span></span><br><span class="line">let add = λ x y. x + y</span><br><span class="line"><span class="comment">;输出5</span></span><br><span class="line">(<span class="name">add</span> <span class="number">2</span> <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>看到这里，其实知道Lisp语言的同学可能就有种似曾相识的感觉了。Lisp语言就是一种函数式编程语言，函数式编程语言就是基于lambda演算发展起来的。细心的人已经发觉，lambda演算与图灵机模型对比，它其实更加侧重于计算的描述，甚至表达式不需要关心函数名，它仅仅是个描述计算过程的计算体。所谓的lambda表达式就是这种计算体的一种叫法，只是在各种编程语言环境下，lambda表达式换了个语法而已。</p>
<h2 id="lambda演算公理"><a href="#lambda演算公理" class="headerlink" title="lambda演算公理"></a>lambda演算公理</h2><p>以下是lambda演算的公理系统:</p>
<p>置换公理</p>
<ul>
<li>λ x y. x + y =&gt; λ a b. a + b</li>
</ul>
<p>代入公理</p>
<ul>
<li>(λx y. x + y) a b =&gt; a + b </li>
</ul>
<h2 id="函数生成器"><a href="#函数生成器" class="headerlink" title="函数生成器"></a>函数生成器</h2><p>lambda演算相当于一个函数生成器:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let mul = λx y. x*y</span><br><span class="line">let con = λx y. xy</span><br><span class="line"></span><br><span class="line"><span class="comment">; 代入</span></span><br><span class="line"></span><br><span class="line">mul 3 5  -­‐&gt; 3 * 5 </span><br><span class="line">con 'fu' 'ck' --&gt;  'fuck'</span><br></pre></td></tr></table></figure></p>
<h2 id="定义IF函数"><a href="#定义IF函数" class="headerlink" title="定义IF函数"></a>定义IF函数</h2><p>大家都知道在函数式编程里，一切皆函数，就连什么平时接触到的for，if等语句都不例外。那么在函数式编程里面如何构造一个IF函数呢？</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;第一个参数condition为if函数的判断条件，如为真，则执行true_value,反之，false_value</span></span><br><span class="line"></span><br><span class="line">let if = λ condition true_value false_value .</span><br><span class="line">         (<span class="name">condition</span> and true_value) or (<span class="name">not</span> condition and false_value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;调用if,输出15</span></span><br><span class="line"></span><br><span class="line">if true (<span class="name">mul</span> <span class="number">3</span> <span class="number">5</span>) (<span class="name">add</span> <span class="number">2</span> <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">=&gt; (<span class="name">true</span> and (<span class="name">mul</span> <span class="number">3</span> <span class="number">5</span>)) or (<span class="name">not</span> true and (<span class="name">add</span> <span class="number">2</span> <span class="number">3</span>))</span><br><span class="line">=&gt; (<span class="name">mul</span> <span class="number">3</span> <span class="number">5</span>) or false </span><br><span class="line">=&gt; (<span class="name">mul</span> <span class="number">3</span> <span class="number">5</span>)</span><br><span class="line">=&gt; <span class="number">15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;调用if,输出5</span></span><br><span class="line"></span><br><span class="line">if false (<span class="name">mul</span> <span class="number">3</span> <span class="number">5</span>) (<span class="name">add</span> <span class="number">2</span> <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">=&gt; (<span class="name">false</span> and (<span class="name">mul</span> <span class="number">3</span> <span class="number">5</span>)) or (<span class="name">not</span> false and (<span class="name">add</span> <span class="number">2</span> <span class="number">3</span>))</span><br><span class="line">=&gt; false or (<span class="name">add</span> <span class="number">2</span> <span class="number">3</span>) </span><br><span class="line">=&gt; (<span class="name">add</span> <span class="number">2</span> <span class="number">3</span>)</span><br><span class="line">=&gt; <span class="number">5</span></span><br></pre></td></tr></table></figure>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><hr>
<p>来个有意思点的计算，定义一个计算n的阶乘的函数:<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let fact = λ n .</span><br><span class="line">          if (<span class="name">n</span> == <span class="number">0</span>) <span class="number">1</span> </span><br><span class="line">                     (<span class="name">mul</span> (<span class="name">n</span> </span><br><span class="line">                          (<span class="name">fact</span> n - <span class="number">1</span>)))</span><br></pre></td></tr></table></figure></p>
<p>问题出现了，我们在定义fact的时候引用的自身（废话，递归不调用自身还叫递归？）。虽然在实际的编译器处理过程中，编译器都可以识别这种定义，但是这不符合严谨的数学公理体系。</p>
<h2 id="如何表达递归"><a href="#如何表达递归" class="headerlink" title="如何表达递归"></a>如何表达递归</h2><p>之前的fact函数不是无法引用自身吗？那么我们把“自身”参数化，那么函数内部就可以引用了。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let P = λ self n .</span><br><span class="line">        if ( <span class="name">n</span> == <span class="number">0</span>) <span class="number">1</span> (<span class="name">mul</span> </span><br><span class="line">                        (<span class="name">n</span></span><br><span class="line">                         (<span class="name">self</span> n - <span class="number">1</span>))</span><br></pre></td></tr></table></figure></p>
<p>然后，再令:<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let fact n = P (<span class="name">P</span> n)</span><br><span class="line"></span><br><span class="line"><span class="comment">; 然后调用,输出24</span></span><br><span class="line">fact <span class="number">4</span></span><br><span class="line">-&gt; P (<span class="name">P</span> <span class="number">4</span>)</span><br><span class="line">-&gt; if (<span class="number">4</span> == <span class="number">0</span>) <span class="number">1</span> (<span class="name">mul</span> <span class="number">4</span> (<span class="name">P</span> (<span class="name">P</span> n-1)))</span><br><span class="line">-&gt; (<span class="name">mul</span> <span class="number">4</span> (<span class="name">P</span> (<span class="name">P</span> <span class="number">3</span>)))</span><br><span class="line">-&gt; <span class="number">4</span> * P (<span class="name">P</span> <span class="number">3</span>)</span><br><span class="line">-&gt; <span class="number">4</span> * <span class="number">3</span> * P (<span class="name">P</span> <span class="number">2</span>)</span><br><span class="line">-&gt; <span class="number">4</span> * <span class="number">3</span> * <span class="number">2</span> * P (<span class="name">P</span> <span class="number">1</span>)</span><br><span class="line">-&gt; <span class="number">4</span> * <span class="number">3</span> * <span class="number">2</span> * <span class="number">1</span></span><br><span class="line">-&gt; <span class="number">24</span></span><br></pre></td></tr></table></figure></p>
<p>可惜，以上还不是真正的递归,只是每次额外多传入了一个参数，反复调用而已。我们的目的是要一个真正的递归函数,但是lambda演算没有这样一个公理可以在定义函数的时候引用自身，怎么办？</p>
<h2 id="Y组合子与不动点"><a href="#Y组合子与不动点" class="headerlink" title="Y组合子与不动点"></a>Y组合子与不动点</h2><p>不管之前的说法，我们就认定真正的fact是存在的:<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;之前的函数P，为了方便，乘法表示就不用自定义的函数mul了</span></span><br><span class="line">let P = λ self n .</span><br><span class="line">        if ( <span class="name">n</span> == <span class="number">0</span>) <span class="number">1</span> ( <span class="name">n</span> * self (n - 1))</span><br><span class="line">                         </span><br><span class="line">; 函数P接收2个参数，但是我们可以让函数柯里化(Currying),有时候又称部分求值(Partial Evaluation)</span><br><span class="line">; P接收一个fact，本质上又产生了一个新的单参函数</span><br><span class="line"></span><br><span class="line">P (fact) -&gt; λ n .</span><br><span class="line">        if ( n == 0) 1 ( n * fact (<span class="name">n</span> - <span class="number">1</span>))</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><em>注: <a href="https://en.wikipedia.org/wiki/Currying" target="_blank" rel="noopener">函数柯里化</a>本质的意义是把一个多参的函数转换成单参函数作为返回值的形式,这样方便优化，有兴趣可以看知乎的讨论，<a href="https://www.zhihu.com/question/20037482" target="_blank" rel="noopener">柯里化对函数式编程有何意义？</a>, <a href="https://www.zhihu.com/question/30097211" target="_blank" rel="noopener">如何理解functional programming里的currying与partial application?</a></em></p>
</blockquote>
<p>然后，神奇的事发生了,细心的人发现，函数 P (fact) 与之前定义的函数fact相等，</p>
<ul>
<li>P (fact) = fact</li>
</ul>
<p>我们发现了函数P的一个<a href="https://en.wikipedia.org/wiki/Fixed-point_combinator" target="_blank" rel="noopener">不动点</a>,什么是不动点呢？就是一个点（广义上的）在一个函数的映射下,函数的值仍然为这个点: f(x) = x 。所以，思路就是找到不动点，如果找到了不动点，就可以把“伪递归”函数P转化为真正的递归函数了。</p>
<p>所以，我们假设需要一个函数Y，它可以找到这个伪递归函数的不动点，即：</p>
<ul>
<li>Y(F) = f = F(Y(F))</li>
</ul>
<p>其中F(f) = f, 那么就有</p>
<ul>
<li>Y(P) = fact</li>
</ul>
<p>只要有了Y，就可以把伪递归函数变换成真递归函数了。</p>
<h2 id="构造Y组合子"><a href="#构造Y组合子" class="headerlink" title="构造Y组合子"></a>构造Y组合子</h2><p>一起来一睹Y组合子的尊容吧:</p>
<ul>
<li>let Y = λ F. G(G)</li>
<li>其中G =  λ self. F(self(self))</li>
</ul>
<h2 id="验证一下"><a href="#验证一下" class="headerlink" title="验证一下"></a>验证一下</h2><p>Y(P)<br>= G(G)  , 其中G = λ self. P(self(self))<br>= P(G(G))<br>= λ n. if (n==0) 1 (n <em> G(G) n - 1)<br>假设 Y(P) = fact, 那么<br>Y(P) = fact = λ n. if (n==0) 1 (n </em> fact n-1)</p>
<p>这就是我们梦寐以求的真正的递归函数!</p>
<p>所以，当我们想定义递归函数的时候，只需要增加一个self参数，按伪递归的方法定义，然后再用Y组合子一套用，就变成我们想要的真递归了。</p>
<h1 id="图灵等价"><a href="#图灵等价" class="headerlink" title="图灵等价"></a>图灵等价</h1><p>以上已经成功地推导出了Y组合子，就相当于在λ演算公理体系中推导出了一条定理：</p>
<ul>
<li>可以在定义函数的过程中引用自身</li>
</ul>
<p>这条定理是证明λ演算与图灵机等价的一个重要步骤。</p>
<p>那么这两个不同的计算模型等价意为着什么呢？</p>
<p>意味着它的计算能力与我们现实生活中的物理计算机的计算能力是一致的，图灵机的工作模型更接近于物理上的机器，冯诺依曼架构就是图灵机的物理实现。换句话说，也就是说，我们写的任何程序都能用λ演算来描述，同时λ演算描述的函数一定可以由计算机计算。</p>
<h2 id="停机问题的等价问题"><a href="#停机问题的等价问题" class="headerlink" title="停机问题的等价问题"></a>停机问题的等价问题</h2><p>回想之前的停机问题，即不可判定一个图灵机在给定任意输入的时候是否可以停机。</p>
<p>这个命题在λ演算中的等价命题是：</p>
<font color="red"><strong>不存在一个算法能判定任何两个λ函数是否等价，即对于所有的n，有f(n)=g(n)</strong></font>


<h1 id="现实世界中的函数式编程"><a href="#现实世界中的函数式编程" class="headerlink" title="现实世界中的函数式编程"></a>现实世界中的函数式编程</h1><p>之前都是在分析λ演算的理论，是数学化的思维，下面就请看基于λ演算发展出来的函数式语言是什么样子？ 用工程化的思维来看看现实世界的函数式编程。</p>
<h2 id="Haskell"><a href="#Haskell" class="headerlink" title="Haskell"></a>Haskell</h2><p>Haskell是一种纯函数式编程语言，它追求的是最纯粹的函数式，名字是为了纪念Haskell Curry而命名的。之前提到的Y组合子就是这位老哥发现的，此外他还提出了函数柯里化(Currying)，即部分求值。</p>
<p>Haskell中的一切都是函数，甚至没有命令式编程（面向过程或面向对象）中变量的概念。它的变量全部都是只允许一次赋值，然后不可改变，就像数学推导中对变量的赋值一样。</p>
<p>Haskell还没有一般意义上的控制流，如for循环等，取而代之的是递归。</p>
<p>Haskell还有两个重要的特性，即无副作用和惰性求值。</p>
<p>无副作用指的是任何函数在给定同样输入的情况下每次调用的结果都一样，跟数学中的函数是一样的。而惰性求值指的是函数除非需要，否则不会立即计算。</p>
<h3 id="第一个Haskell程序"><a href="#第一个Haskell程序" class="headerlink" title="第一个Haskell程序"></a>第一个Haskell程序</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">let</span> max a b = <span class="keyword">if</span> a&gt;b <span class="keyword">then</span> a <span class="keyword">else</span> b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title">max</span> <span class="number">3</span> <span class="number">4</span>   <span class="comment">-- print 4</span></span><br><span class="line"></span><br><span class="line"><span class="title">max</span> <span class="number">1.001</span> <span class="number">1</span> <span class="comment">-- print 1.001</span></span><br><span class="line"></span><br><span class="line"><span class="title">max</span> <span class="string">"MathxH"</span> <span class="string">"ChenAlex1233"</span>  <span class="comment">-- print "ChenAlex1233"</span></span><br></pre></td></tr></table></figure>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>Haskell中的列表定义是这样的：</p>
<ul>
<li><p>list X :: = [] || elem : (list X)<br>即：</p>
</li>
<li><p>空列表 = []</p>
</li>
<li>[1] = 1:[]</li>
<li>[1,2,3] = 1:2:3:[]</li>
</ul>
<p>输入2:1:3:7:8:[] 可以看到<br>[2,1,3,7,8]</p>
<h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h3><p>定义：</p>
<ul>
<li>let first (elem:rest) = elem</li>
</ul>
<p>输入first [1,3] 可以看到结果是1。<br>elem:rest 是Haskell的函数参数模式匹配。<br>对于列表[1,3],实质上是1:3:[], elem匹配了1，rest匹配了3:[]， 也就是[3]。</p>
<h3 id="列表求和"><a href="#列表求和" class="headerlink" title="列表求和"></a>列表求和</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">accumulate</span> [] = <span class="number">0</span></span><br><span class="line"><span class="title">accumulate</span> (elem:rest) = elem + accumulate rest</span><br><span class="line"><span class="title">main</span> = print (accumulate [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment">-- print 6</span></span><br></pre></td></tr></table></figure>
<h3 id="判断回文"><a href="#判断回文" class="headerlink" title="判断回文"></a>判断回文</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="title">palindrome</span> [] = <span class="type">True</span></span><br><span class="line"><span class="title">palindrome</span> [_] = <span class="type">True</span></span><br><span class="line"><span class="title">palindrome</span> (elem:rest) = (elem == last rest) &amp;&amp; (palindrome(init rest)) <span class="comment">-- init:返回一个列表中除了最后一个元素的其他元素</span></span><br><span class="line"></span><br><span class="line"><span class="title">palindrome</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>] <span class="comment">-- print True</span></span><br><span class="line"><span class="title">palindrome</span> [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]   <span class="comment">-- print False</span></span><br><span class="line"><span class="title">palindrome</span> <span class="string">"madam"</span>  <span class="comment">-- print True</span></span><br></pre></td></tr></table></figure>
<h3 id="删除连续重复元素"><a href="#删除连续重复元素" class="headerlink" title="删除连续重复元素"></a>删除连续重复元素</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">cut</span> cond [] = []</span><br><span class="line"><span class="title">cut</span> cond (elem:rest) = <span class="keyword">if</span> cond elem <span class="keyword">then</span> </span><br><span class="line">                         cut cond rest <span class="keyword">else</span></span><br><span class="line">                         elem:rest</span><br><span class="line"><span class="title">compress</span> [] = []</span><br><span class="line"><span class="title">compress</span> (elem:rest) = elem : compress (cut (== elem) rest)</span><br><span class="line"></span><br><span class="line"><span class="title">compress</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>]  <span class="comment">-- print [1,2,3]</span></span><br><span class="line"><span class="title">compress</span> <span class="string">"aaabbaccc"</span>  <span class="comment">-- print "abac"</span></span><br></pre></td></tr></table></figure>
<p>下面来点华丽的推导过程：</p>
<p>  compress [1,2,2,2,3,3]<br>=&gt; 1 : compress (cut (== 1) [2,2,2,3,3])<br>=&gt; 1 : compress (if (== 1) 2 then cut (== 1) [2,2,3,3] else [2,2,2,3,3])<br>=&gt; 1 : compress [2,2,2,3,3]<br>=&gt; 1 : 2 : compress (cut (== 2) [2,2,3,3])<br>=&gt; 1 : 2 : compress (if (== 2) 2 then cut (== 2) [2,3,3] else [2,2,3,3])<br>=&gt; 1 : 2 : compress (cut (== 2) [2,3,3])<br>=&gt; 1 : 2 : compress (if (== 2) 2 then cut (== 2) [3,3] else [2,3,3])<br>=&gt; 1 : 2 : compress (cut (== 2) [3,3])<br>=&gt; 1 : 2 : compress (if (== 2) 3 then cut (== 2) [3] else [3,3])<br>=&gt; 1 : 2 : compress [3,3]<br>=&gt; 1 : 2 : 3 : compress (cut (== 3) [3])<br>=&gt; 1 : 2 : 3 : compress (if (== 3) 3 then cut (== 3) [] else [3])<br>=&gt; 1 : 2 : 3 : compress (cut (== 3) [])<br>=&gt; 1 : 2 : 3 : compress []<br>=&gt; 1 : 2 : 3 : []<br>=&gt; [1,2,3]</p>
<h3 id="惰性求值"><a href="#惰性求值" class="headerlink" title="惰性求值"></a>惰性求值</h3><p>Haskell中可以定义无穷列表，例如：</p>
<ul>
<li>[1..]表示所有的正整数</li>
<li>[1,3..]表示所有的奇数</li>
</ul>
<p>这在大多数编程语言中都是不可思议的，因为大多数语言都是及早求值(early evaluation)，Haskell的惰性求值(lazy evaluation)特性可以让列表按需取用。</p>
<p>例如[1,3..] !! 42 可以返回结果85</p>
<h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><p>如何用Haskell实现斐波那契数列呢？最符合数学化的描述方法是:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fib</span> <span class="number">0</span> = <span class="number">1</span></span><br><span class="line"><span class="title">fib</span> <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="title">fib</span> a = fib (a - <span class="number">1</span>) + fib (a - <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>不巧的是，这个算法是O(2^N)的，因为Haskell编译器还没有聪明到可以实现递归记忆化。</p>
<h3 id="斐波那契数列的线性算法"><a href="#斐波那契数列的线性算法" class="headerlink" title="斐波那契数列的线性算法"></a>斐波那契数列的线性算法</h3><p>让我们利用无穷列表来实现线性算法！ 一行代码就可以了：</p>
<ul>
<li>fib = 1:1:zipWith (+) fib (tail fib)</li>
</ul>
<p>fib !! 4是5，  fib !! 42 是433494437<br>fib !! 1000输出：<br>7033036771142281582183525487718354977018<br>1269836358732742604905087154537118196933<br>5797422494945626117334877504492417659910<br>8818636326545022364710601205337412127386<br>7339111198139373125598767690091902245245<br>323403501 </p>
<p>解释下以上代码:</p>
<p>tail返回列表除了第一项以外的后面内容，例如 tail [1..] 返回 [2..]</p>
<p>zipWith是将两个列表的每个元素通过一个函数非别计算，并返回结果的列表，例如：</p>
<ul>
<li>zipWith (*) [2,3,5] [1,2,3] 返回[2,6,15]</li>
</ul>
<p>于是乎，fib  =  1:1:zipWith  (+)  fib  (tail  fib)  生成了一个无穷列表，前面两个元素都是1，后面的元素由现有列表错位相加而成，即:</p>
<pre><code>[1,  1,  2,  3,  5,  8,  13,  21…]   //fib    
</code></pre><p>+  [1,  2,  3,  5,  8,  13,  21,  34…]   //tail  fib<br>=  [2,  3,  5,  8,  13,  21,  34,  55…] </p>
<p>由于惰性求值，列表不会被立即计算，只有当我们用到其中元素的时候才会算。 </p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">qsort</span> (elem:rest) = (qsort lesser) ++ [elem] ++ (qsort greater)</span><br><span class="line">   <span class="keyword">where</span></span><br><span class="line">    lesser = filter (&lt; elem) rest</span><br><span class="line">    greater = filter (&gt;= elem) rest</span><br></pre></td></tr></table></figure>
<p>++ 用于列表连接<br>filter返回列表中满足条件的元素组成的列表</p>
<h3 id="二叉树并表示"><a href="#二叉树并表示" class="headerlink" title="二叉树并表示"></a>二叉树并表示</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Tree</span> a = <span class="type">Empty</span> | <span class="type">Node</span> a (<span class="type">Tree</span> <span class="title">a</span>) (<span class="type">Tree</span> <span class="title">a</span>)</span></span><br><span class="line"><span class="title">tree</span> = <span class="type">Node</span> 'd'</span><br><span class="line">    (<span class="type">Node</span> 'b'</span><br><span class="line">       (<span class="type">Node</span> 'a' <span class="type">Empty</span> <span class="type">Empty</span>)</span><br><span class="line">       (<span class="type">Node</span> 'c' <span class="type">Empty</span> <span class="type">Empty</span>)</span><br><span class="line">    )</span><br><span class="line">    (<span class="type">Node</span> 'e'</span><br><span class="line">      <span class="type">Empty</span></span><br><span class="line">      (<span class="type">Node</span> 'g'</span><br><span class="line">        (<span class="type">Node</span> 'f' <span class="type">Empty</span> <span class="type">Empty</span>)</span><br><span class="line">        <span class="type">Empty</span></span><br><span class="line">      )</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<p>以上代码构建了一个二叉树，是这样的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    d</span><br><span class="line">   / \</span><br><span class="line">  b   e</span><br><span class="line"> / \   \</span><br><span class="line">a   c   g</span><br><span class="line">       /</span><br><span class="line">      f</span><br></pre></td></tr></table></figure>
<p>下面对这个二叉树进行中序遍历:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">inorder</span>  <span class="type">Empty</span>  =  [] </span><br><span class="line"><span class="title">inorder</span>  (<span class="type">Node</span>  value  left  right)  = </span><br><span class="line"><span class="title">inorder</span>  left  ++  [value]  ++  inorder  right </span><br><span class="line"></span><br><span class="line"><span class="title">inorder</span> tree  <span class="comment">-- print "abcdefg"</span></span><br></pre></td></tr></table></figure>
<p>然后求树的高度:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">height</span>  <span class="type">Empty</span>  =  <span class="number">0</span> </span><br><span class="line"><span class="title">height</span>  (<span class="type">Node</span>  value  left  right)  =  </span><br><span class="line"><span class="title">max</span>  (height  left)  (height  right)  +  <span class="number">1</span> </span><br><span class="line"></span><br><span class="line"><span class="title">height</span> tree <span class="comment">-- print 4</span></span><br></pre></td></tr></table></figure>
<h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>高阶函数的参数是函数，通过部分求值可以返回函数。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">traverse</span>  func  zero  <span class="type">Empty</span>  =  zero </span><br><span class="line"><span class="title">traverse</span>  func  zero  (<span class="type">Node</span>  value  left  right)  = </span><br><span class="line"><span class="title">func</span>  value  </span><br><span class="line">(traverse  func  zero  left)  </span><br><span class="line">(traverse  func  zero  right) </span><br><span class="line"><span class="title">height_func</span>  _  a  b  =  max  a  b  +  <span class="number">1</span> </span><br><span class="line"></span><br><span class="line"><span class="title">traverse</span>  height_func  <span class="number">0</span>  tree  <span class="comment">-- print 4</span></span><br></pre></td></tr></table></figure>
<p>中序遍历函数：</p>
<p>inorder_func  value  left  right  =  left  ++<br>[value]  ++  right </p>
<p>通过部分求值产生低阶函数：</p>
<p>inorder  =  traverse  inorder_func  [] </p>
<p>inorder tree  – print “abcdefg”</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">make_closure</span>(<span class="params"></span>)  </span>&#123; </span><br><span class="line">  <span class="keyword">var</span>  inner_varible  =  <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">return</span>  <span class="function"><span class="keyword">function</span>  (<span class="params"></span>)  </span>&#123; </span><br><span class="line">    <span class="keyword">return</span>  inner_varible++; </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span>  counter  =  make_closure(); </span><br><span class="line">counter();  <span class="comment">//  0 </span></span><br><span class="line">counter();  <span class="comment">//  1</span></span><br></pre></td></tr></table></figure>
<h3 id="用闭包实现柯里化"><a href="#用闭包实现柯里化" class="headerlink" title="用闭包实现柯里化"></a>用闭包实现柯里化</h3><p>多数编程语言无法部分求值，原因是柯里化与参数表机制冲突。但可以用闭包实现。但是Java，C++ 11等主流编程语言对于闭包的支持就是半残。下面用js来表达吧。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pow</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x ^ y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对pow函数部分求值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">pow5</span>(<span class="params">x</span>)  </span>&#123; </span><br><span class="line">  <span class="keyword">return</span>  pow(x,  <span class="number">5</span>); </span><br><span class="line">&#125; </span><br><span class="line">pow5(<span class="number">2</span>);  <span class="comment">//输出  32</span></span><br></pre></td></tr></table></figure>
<p>上面的代码实质上是:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">pow5</span>(<span class="params">x</span>)  </span>&#123; </span><br><span class="line">  <span class="keyword">return</span>  <span class="function"><span class="keyword">function</span> (<span class="params">x, <span class="number">5</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x ^ <span class="number">5</span>;</span><br><span class="line">&#125;;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>EOF</p>


<!--<a href="https://alexiachen.github.io/blog/2016/09/05/functional-programming/#disqus_thread" class="article-comment-link">Comments</a>
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = ''; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
-->
<div style="display:none">
<script src="http://s4.cnzz.com/stat.php?id=&web_id=" language="JavaScript"></script>script>
</div>






</body>
</html>